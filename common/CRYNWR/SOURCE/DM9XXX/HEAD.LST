Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
.\head.asm						     Page 1 - 1


				;*****************************************************************************
				;* Name : HEAD.ASM
				;*
				;* All rights reserved by DAVICOM, 1996
				;*
				;* Description :
				;*
				;* Functions :
				;*
				;* Author : Spenser Tsai
				;*
				;* Date : 05/17/96'
				;*
				;* Change Notes :
				;* Date - Modifier
				;*     Cause :
				;*  Modified :
				;*    Result :
				;*
				;
				; Maintainers:
				;
				; John H.T. Ho		htho
				;
				;
				; Revision History:
				;
				; Date	     Modfier.	Modification Descriptions
				; ---------- ---------- ------------------------------------------
				; 2000.6.27	htho	fix noise level setting bug
				;
				;*****************************************************************************
				;  Copyright, 1996-1998, Spenser Tsai, DAVICOM

				.model tiny
				.386

				include defs.asm
			      C ;;*******************************************************
			      C ;* Program name : DEFS.ASM
			      C ;* Modified By : Spenser Tsai
			      C ;* Date : 10/04/97' (DAVICOM)
			      C ;********************************************************
 = 0001			      C majver		equ	MAJ_VER 	;version number of the infrastructure.
			      C 
 = 0004			      C version 	equ	MIN_VER 	;Major Version number of the program
			      C 
 = 0000			      C dm9100_version	equ	GEN_VER 	;version number of the generic 9100 driver.
			      C 
 = 0010			      C MAX_ADDR_LEN	equ	16		;maximum number of bytes in our address.
			      C 
 = 000A			      C MAX_HANDLE	equ	10		;maximum number of handles.
			      C 
 = 0008			      C MAX_P_LEN	equ	8		;maximum type length
			      C 
			      C ;;MAX_MULTICAST   equ	  8		  ;maximum number of multicast addresses.
 = 000E			      C MAX_MULTICAST	equ	14		 ;maximum number of multicast addresses.
			      C 
			      C ;  Copyright, 1988-1992, Russell Nelson, Crynwr Software
			      C 
			      C ;   This program is free software; you can redistribute it and/or modify
			      C ;   it under the terms of the GNU General Public License as published by
			      C ;   the Free Software Foundation, version 1.
			      C ;
			      C ;   This program is distributed in the hope that it will be useful,
			      C ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
			      C ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
			      C ;   GNU General Public License for more details.
			      C ;
			      C ;   You should have received a copy of the GNU General Public License
			      C ;   along with this program; if not, write to the Free Software
			      C ;   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
			      C 
 = 0009			      C HT	equ	09h
 = 000D			      C CR	equ	0dh
 = 000A			      C LF	equ	0ah
			      C 
			      C ;
			      C ;  Packet Driver Error numbers
 = 0000			      C NO_ERROR	equ	0		;no error at all.
			      C   ifndef SMCINC
 = 0001			      C BAD_HANDLE	equ	1		;invalid handle number
			      C   endif
 = 0002			      C NO_CLASS	equ	2		;no interfaces of specified class found
 = 0003			      C NO_TYPE 	equ	3		;no interfaces of specified type found
 = 0004			      C NO_NUMBER	equ	4		;no interfaces of specified number found
			      C   ifndef SMCINC
 = 0005			      C BAD_TYPE	equ	5		;bad packet type specified
			      C   endif
 = 0006			      C NO_MULTICAST	equ	6		;this interface does not support
			      C 					;multicast
 = 0007			      C CANT_TERMINATE	equ	7		;this packet driver cannot terminate
 = 0008			      C BAD_MODE	equ	8		;an invalid receiver mode was specified
 = 0009			      C NO_SPACE	equ	9		;operation failed because of
			      C 					;insufficient space
 = 000A			      C TYPE_INUSE	equ	10		;the type had previously been accessed,
			      C 					;and not released.
 = 000B			      C BAD_COMMAND	equ	11		;the command was out of range, or not
			      C 					;implemented
 = 000C			      C CANT_SEND	equ	12		;the packet couldn't be sent (usually
			      C 					;hardware error)
 = 000D			      C CANT_SET	equ	13		;hardware address couldn't be changed
			      C 					;(more than 1 handle open)
 = 000E			      C BAD_ADDRESS	equ	14		;hardware address has bad length or
			      C 					;format
 = 000F			      C CANT_RESET	equ	15		;Couldn't reset interface (more than
			      C 					;1 handle open).
 = 0010			      C BAD_IOCB	equ	16		;an invalid iocb was specified
			      C 
			      C ;a few useful Ethernet definitions.
 = 003C			      C RUNT		equ	60		;smallest legal size packet, no fcs
 = 05EA			      C GIANT		equ	1514		;largest legal size packet, no fcs
 = 0006			      C EADDR_LEN	equ	6		;Ethernet address length.
 = 0001			      C ARCADDR_LEN	equ	1
			      C 
 = 0001			      C BLUEBOOK	equ	1
 = 000B			      C IEEE8023	equ	11
			      C 
			      C 
			      C ;this macro does a "rep movsb" with a static count.
			      C repmov	macro	count
			      C 	rept	(count) / 2
			      C 	movsw
			      C 	endm
			      C 	rept	(count) MOD 2
			      C 	movsb
			      C 	endm
			      C 	endm
			      C 
			      C ;moves a segment register into another segment register.
			      C movseg	macro	to, from
			      C 	push	from
			      C 	pop	to
			      C 	endm
			      C 
			      C ;add a word to a dword.
			      C add2	macro	n,a			; inc a 32 bit integer
			      C 	add	n.offs,a		;increment the low word
			      C 	adc	n.segm,0		;increment the high word
			      C 	endm
			      C 
			      C ;this macro writes the given character to the given row and column on
			      C ;  an CGA.
			      C to_scrn macro	r, c, ch
			      C 	local	again
			      C 	push	bx
			      C 	push	es
			      C 	mov	bx,0b800h
			      C 	mov	es,bx
			      C 	mov	bx,es:[r*160+c*2]
			      C again:
			      C 	inc	bh
			      C 	and	bh,07h
			      C 	je	again			;; don't use black.
			      C 	mov	bl,ch
			      C 	mov	es:[r*160+c*2],bx
			      C 	pop	es
			      C 	pop	bx
			      C 	endm
			      C 
			      C 
			      C 
 0004			      C segmoffs	struc			; defines offs as 0, segm as 2
 0000  0000		      C offs		dw	?
 0002  0000		      C segm		dw	?
			      C segmoffs	ends
			      C 
 = 0001			      C CY	equ	0001h
 = 0200			      C EI	equ	0200h
			      C 
 0014			      C iocb		struc			; as_send_pkt structure
 0000  00000000		      C   buffer	  dd	  ?		  ; Pointer to the buffer
 0004  0000		      C   len		  dw	  ?		  ; Its length
 0006  00		      C   flags 	  db	  ?		  ; Some flags
 0007  00		      C   ret_code	  db	  ?		  ; Completion code
 0008  00000000		      C   upcall	  dd	  ?		  ; I/O completion upcall
 000C  00000000		      C   next		  dd	  ?		  ; Private next pointer (queue)
 0010  0004 [		      C   resv		  db	  4 dup (?)	  ; Unused private data
        00
       ]
			      C iocb		ends
			      C 
 = 0001			      C DONE	equ	1		; I/O complete flag
 = 0002			      C CALLME	equ	2		; Please upcall me flag
			      C 
			      C 
			      C send_queueempty macro
			      C ; Check if send queue is empty.
			      C ; Enter with interrupts disabled.
			      C ; Exit with zr (zero) if empty, nz (not zero) if not.
			      C ; Destroys ax.
			      C 	mov ax, word ptr send_head	; Queue empty?
			      C 	or ax,	word ptr send_head+2
			      C 	endm
			      C 
			      C send_peekqueue	macro
			      C ; Peek into the queue and get the next entry.
			      C ; Enter with interrupts disabled.
			      C ; Exit with es:di -> iocb.
			      C 	les di, send_head	; Get head segment:offset
			      C 	endm
			      C 
			      C ; Bits in sys_features
 = 0002			      C SYS_MCA equ	02		; a micro channel computer
 = 0040			      C TWO_8259	equ	40h		; 2nd 8259 exists
			      C 
			      C ; Bits in flagbyte
 = 0001			      C CALLED_ETOPEN	equ	1		; have called etopen
 = 0002			      C D_OPTION	equ	2		; delayed initialization
 = 0004			      C N_OPTION	equ	4		; Novell protocol conversion
 = 0008			      C W_OPTION	equ	8		; Windows upcall checking.
 = 0010			      C U_OPTION	equ	10h		; Terminate the driver.
			      C ;;-+
			      C ;;S_OPTION	  EQU	  20h		  ; 10Mb Speed
			      C ;;F_OPTION	  EQU	  40h		  ; Full Duplex
			      C ;;SF_OPTION	  EQU	  60h		  ; Selected speed & mode
			      C ;;XS_OPTION	  EQU	  80h		  ; 100Mb Speed
			      C ;;A_OPTION	  EQU	  100h		  ; Auto-Negotination & Full-Duplex
			      C ;;AF_OPTION	  EQU	  140h		  ; Full Duplex
 = 0020			      C H_OPTION	EQU	20h		; 10Mb Half Duplex
 = 0040			      C F_OPTION	EQU	40h		; 10Mb Full Duplex
 = 0080			      C XH_OPTION	EQU	80h		; 100Mb Half Duplex
 = 0100			      C XF_OPTION	EQU	100h		; 100Mb Full Duplex
 = 0200			      C A_OPTION	EQU	200h		; Auto-Negotiation
 = 0400			      C T_OPTION	EQU	400h		; HomePNA
			      C ;;-+
 = 0200			      C B_OPTION	EQU	200h		; BNC
			      C 
 0005			      C table_multicast       struc
 0000  0000		      C   table_maxnum	    dw	    0	    ; max number of multicast addresses
 0002  0000		      C   table_current     dw	    0	    ; current number of multicast addresses
 0004  00		      C   table_multiaddr   db	    0	    ; 16 byte sets of multicast addresses
			      C table_multicast       ends
			      C  
			      C 

 0000				code	segment para public
					assume	cs:code, ds:code

					public	phd_environ

					org	2ch

 002C 0000			phd_environ	dw	?

					public	phd_dioa

					org	80h

 0080				phd_dioa	label	byte			;; Parameter location

				;;******************************************
				;; Driver Start point
				;;******************************************
					org	100h

					extrn	start_1: near
 0100				start:
 0100  E9 0000 E			jmp	start_1 			;; locate at tail.asm
 0103  50 4B 54 20 44 52		db	"PKT DRVR"                              ;;Packet driver the label of entry point
       56 52

					extrn	branding_msg: byte

 010B  0000 E				dw	branding_msg

					even				;put the stack on a word boundary.

 010E  0080 [				dw	128 dup(?)		;128 words of stack.
        0000
       ]

					PUBLIC	our_stack
 020E				our_stack	label	byte

					extrn	int_no: byte

					public	entry_point, sys_features, flagword, is_186, is_286, is_386

 020E 00 00 00 00		entry_point	db	?,?,?,? 	; interrupt to communicate.

 0212 00			sys_features	db	0		; 2h = MC   40h = 2nd 8259

 0213 00			is_186		db	0		;=0 if 808[68], =1 if 80[123]86.

 0214 00			is_286		db	0		;=0 if 80[1]8[68], =1 if 80[234]86.

 0215 00			is_386		db	0		;=0 if 80[12]8[68], =1 if 80[34]86.

 0216 0000			flagword	dw	0

 0218 00			original_mask	db	0		;=0 if interrupt was originally on.

				;;IFDEF DISPLAY
				;;
				;;CR EQU 0Dh	  ; ASCII Carriage Return
				;;LF EQU 0Ah	  ; ASCII Line Feed
				;;
				;;Show_isr_ok	      DB ' Software Interrupt happed.. '
				;;		      DB CR,LF
				;;Show_isr_ok_len     EQU $ - Show_isr_ok
				;;
				;;ENDIF   ;;DISPLAY

					even



 021A				functions	label	word
 021A  049D R				dw	f_not_implemented	;0
 021C  04A1 R				dw	f_driver_info		;1
 021E  05B5 R				dw	f_access_type		;2
 0220  067E R				dw	f_release_type		;3
 0222  068E R				dw	f_send_pkt		;4
 0224  0728 R				dw	f_terminate		;5
 0226  078C R				dw	f_get_address		;6
 0228  07F3 R				dw	f_reset_interface	;7
 022A  080A R				dw	f_stop			;8	;; Not in the Specification
 022C  049D R				dw	f_not_implemented	;9
 022E  081B R				dw	f_get_parameters	;10
				;;	  dw	  f_not_implemented	  ;11
 0230  06BB R				dw	f_as_send_pkt		;11	;; Specification define 11, not 12
 0232  06BB R				dw	f_as_send_pkt		;12
 0234  06EB R				dw	f_drop_pkt		;13	;; Not in the Specification
 0236  049D R				dw	f_not_implemented	;14
 0238  049D R				dw	f_not_implemented	;15
 023A  049D R				dw	f_not_implemented	;16
 023C  049D R				dw	f_not_implemented	;17
 023E  049D R				dw	f_not_implemented	;18
 0240  049D R				dw	f_not_implemented	;19
 0242  04ED R				dw	f_set_rcv_mode		;20
 0244  0521 R				dw	f_get_rcv_mode		;21
 0246  052C R				dw	f_set_multicast_list	;22
 0248  0564 R				dw	f_get_multicast_list	;23
 024A  0598 R				dw	f_get_statistics	;24
 024C  07A4 R				dw	f_set_address		;25

				;external data supplied by device-dependent module:
					extrn	driver_class: byte
					extrn	driver_type: byte
					extrn	driver_name: byte
					extrn	driver_function: byte
					extrn	parameter_list: byte
					extrn	rcv_modes: word 	;count of modes followed by mode handles.

				;external code supplied by device-dependent module:
					extrn	send_pkt: near
					extrn	as_send_pkt: near
					extrn	drop_pkt: near
					extrn	terminate: near
				;;	extrn	reset_interface: near
					extrn	xmit: near
				;;	  extrn   recv: near
					extrn	etopen: near
				;;	  extrn   set_multicast_list: near
					extrn	timer_isr: near

 0018				per_handle	struc
 0000  00			  in_use	  db	  0		  ;non-zero if this handle is in use.
 0001  0008 [			  packet_type	  db	  MAX_P_LEN dup(0);associated packet type.
        00
       ]
 0009  0000			  packet_type_len dw	  0		  ;associated packet type length.
 000B  00000000			  receiver	  dd	  0		  ;receiver handler.
 000F  0008 [			  receiver_sig	  db	  8 dup(?)	  ;signature at the receiver handler.
        00
       ]
 0017  00			  class 	  db	  ?		  ;interface class
				per_handle	ends

 024E  000A [			handles 	per_handle MAX_HANDLE dup(<>)	;; MAX_HANDLE = 10
        00
        0008 [
	 00
	] 0000 00000000
        0008 [
	 00
	] 00
       ]

 033E				end_handles	label	byte



					public	multicast_count, multicast_addrs, multicast_broad

 033E 0000			multicast_count dw	0		;count of stored multicast addresses.

 0340 FF FF FF FF FF FF		multicast_broad db	0ffh,0ffh,0ffh,0ffh,0ffh,0ffh	; entry for broadcast

 0346  0054 [			multicast_addrs db	MAX_MULTICAST*EADDR_LEN dup(?)
        00
       ]



				;the device-dependent code reads the board's address from ROM in the

				;initialization code.

					public	address_len, rom_address, my_address

 039A 0006			address_len	dw	EADDR_LEN		;default to Ethernet.

 039C  0010 [			rom_address	db	MAX_ADDR_LEN dup(?)	;our address in ROM.
        00
       ]

 03AC  0010 [			my_address	db	MAX_ADDR_LEN dup(?)	;our current address.
        00
       ]


					PUBLIC	rcv_mode_num
 03BC 0003			rcv_mode_num	dw	3



 03BE 0000			free_handle	dw	0		; temp, a handle not in use

 03C0 0000			found_handle	dw	0		; temp, handle for our packet

 03C2 00000000			receive_ptr	dd	0		; the pkt receive service routine



					public	send_head, send_tail

 03C6 00000000			send_head	dd	0		; head of transmit queue

 03CA 00000000			send_tail	dd	0		; tail of transmit queue

					PUBLIC errors_in, bytes_out, packets_out, bytes_in, errors_out
 03CE				statistics_list label	dword
 03CE 00000000			  packets_in	  dd	  0
 03D2 00000000			  packets_out	  dd	  0
 03D6 00000000			  bytes_in	  dd	  0
 03DA 00000000			  bytes_out	  dd	  0
 03DE 00000000			  errors_in	  dd	  0
 03E2 00000000			  errors_out	  dd	  0
 03E6 00000000			  packets_dropped dd	  0		;dropped due to no type handler.


 03EA				savespss	label	dword

 03EA 0000			savesp		dw	?		;saved during the stack swap.

 03EC 0000			savess		dw	?



 03EE 00000000			their_recv_isr	dd	0		; original owner of board int

					PUBLIC	their_timer
 03F2 00000000			their_timer	dd	0



				;
				; The following structure is used to access the registers pushed by the
				; packet driver interrupt handler.  Don't change this structure without also
				; changing the "bytes" structure given below.
				;

 0018				regs	struc				; stack offsets of incoming regs
 0000  0000			  _ES	  dw	  ?
 0002  0000			  _DS	  dw	  ?
 0004  0000			  _BP	  dw	  ?
 0006  0000			  _DI	  dw	  ?
 0008  0000			  _SI	  dw	  ?
 000A  0000			  _DX	  dw	  ?
 000C  0000			  _CX	  dw	  ?
 000E  0000			  _BX	  dw	  ?
 0010  0000			  _AX	  dw	  ?
 0012  0000			  _IP	  dw	  ?
 0014  0000			  _CS	  dw	  ?
 0016  0000			  _F	  dw	  ?			  ; flags, Carry flag is bit 0
				regs	ends



				;

				; bits in the _F register.

				;

 = 0001				CY	equ	0001h

 = 0200				EI	equ	0200h





				;
				; This structure is a bytewise version of the "regs" structure above.
				;

 0012				bytes	struc				  ; stack offsets of incoming regs
 0000  0000				  dw	  ?			  ; es, ds, bp, di, si are 16 bits
 0002  0000				  dw	  ?
 0004  0000				  dw	  ?
 0006  0000				  dw	  ?
 0008  0000				  dw	  ?
 000A  00			  _DL	  db	  ?
 000B  00			  _DH	  db	  ?
 000C  00			  _CL	  db	  ?
 000D  00			  _CH	  db	  ?
 000E  00			  _BL	  db	  ?
 000F  00			  _BH	  db	  ?
 0010  00			  _AL	  db	  ?
 0011  00			  _AH	  db	  ?
				bytes	ends



					public	their_isr

 03F6 00000000			their_isr	dd	0		; original owner of pkt driver int

				;;******************************************
				;; Upper layer called entry point
				;;
					public	our_isr
 03FA				our_isr:
 03FA  EB 46				jmp	short our_isr_0 	;the required signature.
 03FC  90				nop
 03FD  50 4B 54 20 44 52		db	'PKT DRVR',0
       56 52 00

 0406				our_isr_open:
 0406  50				push	ax			; save lots of registers
 0407  53				push	bx
 0408  51				push	cx
 0409  52				push	dx
 040A  56				push	si
 040B  57				push	di
 040C  55				push	bp
 040D  1E				push	ds
 040E  06				push	es

 040F  E8 0000 E			call	etopen			; init the card
 0412  72 1A				jc	our_isr_no_init

 0414  BE 039C R			mov	si,offset rom_address	;copy their original address to
					movseg	es,ds
 0417  1E		     1		push	ds
 0418  07		     1		pop	es
 0419  BF 03AC R			mov	di,offset my_address	;  their current address.
 041C  B9 0008				mov	cx,MAX_ADDR_LEN/2
 041F  F3/ A5				rep	movsw

 0421  83 3E 0008 E 00			cmp	rcv_modes+2[3*2],0	;does mode 3 exist?
 0426  F9				stc				;make sure we generate an error!
 0427  74 05				je	our_isr_no_init 	;no.
 0429  FF 16 0008 E			call	rcv_modes+2[3*2]	;  call it.
 042D  F8				clc

 042E				our_isr_no_init:
 042E  07				pop	es			; restore lots of registers
 042F  1F				pop	ds
 0430  5D				pop	bp
 0431  5F				pop	di
 0432  5E				pop	si
 0433  5A				pop	dx
 0434  59				pop	cx
 0435  5B				pop	bx
 0436  58				pop	ax

 0437  B6 0F				mov	dh,CANT_RESET		; (actually can't initialize)
 0439  72 3E				jc	our_isr_error
 043B  83 0E 0216 R 01			or	flagword,CALLED_ETOPEN	; remember this fact
 0440  EB 1C				jmp	short our_isr_cont

 0442				our_isr_0:

					assume	ds:nothing
 0442  50				push	ax
 0443  53				push	bx
 0444  51				push	cx
 0445  52				push	dx
 0446  56				push	si
 0447  57				push	di
 0448  55				push	bp
 0449  1E				push	ds
 044A  06				push	es

				;;IFDEF DISPLAY
				;;
				;;EXTRN   PortPrintMessage : NEAR
				;;	  mov	  ax, cs
				;;	  push	  ds
				;;	  mov	  ds, ax
				;;	  mov	  si, OFFSET show_isr_ok
				;;	  mov	  cx, Show_isr_ok_len
				;;	  call	  PortPrintMessage
				;;	  pop	  ds
				;;	  jmp	  Our_isr_return
				;;
				;;ENDIF   ;;DISPLAY
 044B  FC				cld
 044C  8C CB				mov	bx,cs			;set up ds.
 044E  8E DB				mov	ds,bx
					assume	ds:code
 0450  8B EC				mov	bp,sp			;we use bp to access the original regs.
 0452  83 66 16 FE			and	_F[bp],not CY		;start by clearing the carry flag.

				  if 0
				  endif

 0456  F7 06 0216 R 0001		test	flagword,CALLED_ETOPEN	; have we initialized the card?
 045C  74 A8				jz	our_isr_open		; no

 045E				our_isr_cont:
 045E  8A DC				mov	bl,ah			;jump to the correct function.
 0460  32 FF				xor	bh,bh
 0462  83 FB 19				cmp	bx,25			;only twenty five functions right now.
 0465  77 1D				ja	f_bad_command
 0467  03 DB				add	bx,bx			;*2

				;
				; The functions are called with all the original registers except
				; BX, DH, and BP.  They do not need to preserve any of them.  If the
				; function returns with cy clear, all is well.	Otherwise dh=error number.
				;
 0469  FF 97 021A R			call	functions[bx]
					assume	ds:nothing
 046D  72 0A				jc	our_isr_error

 046F				our_isr_return:
 046F  07				pop	es
 0470  1F				pop	ds
 0471  5D				pop	bp
 0472  5F				pop	di
 0473  5E				pop	si
 0474  5A				pop	dx
 0475  59				pop	cx
 0476  5B				pop	bx
 0477  58				pop	ax
 0478  CF				iret

 0479				our_isr_error:
					assume	ds:nothing
 0479  8B EC				mov	bp,sp			;we use bp to access the original regs.
 047B  88 76 0B				mov	_DH[bp],dh
 047E  83 4E 16 01			or	_F[bp],CY		;return their carry flag.
 0482  EB EB				jmp	short our_isr_return

 0484				f_bad_command:
					assume	ds:code
					extrn	bad_command_intercept: near
 0484  8B 5E 0E				mov	bx,_BX[bp]
 0487  E8 0000 E			call	bad_command_intercept
 048A  89 5E 0E				mov	_BX[bp],bx
 048D  89 56 0A				mov	_DX[bp],dx
 0490  73 DD				jnc	our_isr_return
 0492  EB E5				jmp	our_isr_error

					public	re_enable_interrupts
 0494				re_enable_interrupts:
				; Possibly re-enable interrupts.  We put this here so that other routines
				; don't need to know how we put things on the stack.
 0494  F7 46 16 0200			test	_F[bp], EI		; Were interrupts enabled on pkt driver entry?
 0499  74 01				je	re_enable_interrupts_1	; No.
 049B  FB				sti				; Yes, re-enable interrupts now.

 049C				re_enable_interrupts_1:

 049C  C3				ret

 049D				f_not_implemented:
 049D  B6 0B				mov	dh,BAD_COMMAND
 049F  F9				stc
 04A0  C3				ret

				;--------------------------------------------------------------------+
				; Name : f_driver_info
				;
				; Description: Returns information about the interface.
				;
				; Enter : AH = 1, AL = 255, BX = handle (option).
				;
				; Return :
				;	Non-errors :	Carry flag clear
				;			Version 	BX
				;			Clear		CH
				;			Type		DX
				;			Number		CL
				;			Name		DS:SI	(Driver Name)
				;			Functionality	AL
				;						1 = Basic functions.
				;						2 = Basic and Extended.
				;						5 = Basic and High-performance.
				;						6 = Basic, High-performance,
				;						    Extended.
				;					      255 = Not installed.
				; Destroied registers : AX & BX.
				;
				;---------------------------------------------------------------------+

 04A1				f_driver_info:
				;	As of 1.08, the handle is optional, so we no longer verify it.
				;	call	verify_handle

 04A1  80 7E 10 FF			cmp	_AL[bp],0ffh		; correct calling convention?
 04A5  75 44				jne	f_driver_info_1 	; ne = incorrect, fail

									;For enhanced PD, if they call
 04A7  81 7E 0E 0000			cmp	_BX[bp],offset handles	;with a handle, give them the
									;class they think it is
 04AC  72 17				jb	default_handle
 04AE  81 7E 0E 0000			cmp	_BX[bp],offset end_handles ;otherwise default to first class
 04B3  73 10				jae	default_handle

 04B5  8B 5E 0E				mov	bx, _BX[bp]
 04B8  80 3F 00				cmp	[bx].in_use,0		;if it's not in use, it's bad.
 04BB  74 08				je	default_handle
 04BD  8A 47 17				mov	al, [bx].class
 04C0  88 46 0D				mov	_CH[bp], al
 04C3  EB 06				jmp	short got_handle

 04C5				default_handle:
 04C5  A0 0000 E			mov	al,driver_class
 04C8  88 46 0D				mov	_CH[bp],al

 04CB				got_handle:
 04CB  C7 46 0E 0001			mov	_BX[bp],majver		;version
 04D0  A0 0000 E			mov	al,driver_type
 04D3  98				cbw
 04D4  89 46 0A				mov	_DX[bp],ax
 04D7  C6 46 0C 00			mov	_CL[bp],0		;number zero.
 04DB  8C 5E 02				mov	_DS[bp],ds		; point to our name in their ds:si
 04DE  C7 46 08 0000			mov	_SI[bp],offset driver_name
 04E3  A0 0000 E			mov	al,driver_function
 04E6  88 46 10				mov	_AL[bp],al
 04E9  F8				clc
 04EA  C3				ret

 04EB				f_driver_info_1:
 04EB  F9				stc
 04EC  C3				ret
				;;-------------------------------------------------------------------------

				;--------------------------------------------------------------------+
				; Name : f_set_rcv_mode
				;
				; Description: Set the receive mode on the interface associated with handle.
				;		Can't use this function in the mutli-handle.
				;
				; Enter : AH = 20
				;		BX = handle
				;		CX = mode
				;
				; Return :
				;	error return - carry flag set, DH = error code.
				;
				;	Non-error return - carry flag clear, AX = handle.
				;
				; Destroied registers :
				;
				;---------------------------------------------------------------------+
					public f_set_rcv_mode
 04ED				f_set_rcv_mode:
 04ED  E8 0351				call	verify_handle
 04F0  3B 0E 03BC R			cmp	cx,rcv_mode_num 	;are we already using that mode?
 04F4  74 25				je	f_set_rcv_mode_4	;yes, no need to check anything.

 04F6  8B D3				mov	dx,bx			;remember our handle.
 04F8  E8 0335				call	count_handles		;is ours the only open handle?
									;; Return cx = Number of open handle
 04FB  80 F9 01				cmp	cl,1
 04FE  75 1D				jne	f_set_rcv_mode_1	;no, don't change the receive mode.

 0500  8B 4E 0C				mov	cx,_CX[bp]		;get the desired receive mode.
 0503  3B 0E 0000 E			cmp	cx,rcv_modes		;do they have this many modes?
 0507  73 14				jae	f_set_rcv_mode_1	;no - must be a bad mode for us.

 0509  8B D9				mov	bx,cx
 050B  D1 E3				shl	bx, 1			;we're accessing words, not bytes.
				;;	  add	  bx,bx 		  ;we're accessing words, not bytes.
 050D  8B 87 0002 E			mov	ax,rcv_modes[bx]+2	;get the handler for this mode.
 0511  0B C0				or	ax,ax			;do they have one?
 0513  74 08				je	f_set_rcv_mode_1	;no - must be a bad mode for us.

 0515  89 0E 03BC R			mov	rcv_mode_num,cx 	;yes - remember the number and
 0519  FF D0				call	ax			;  call it.
 051B				f_set_rcv_mode_4:
 051B  F8				clc
 051C  C3				ret

 051D				f_set_rcv_mode_1:
 051D  B6 08				mov	dh,BAD_MODE
 051F  F9				stc
 0520  C3				ret
				;;--------------------------------------------------------------------------

				;--------------------------------------------------------------------+
				; Name : f_get_rcv_mode
				;
				; Description: Return the current receive mode of the interface associated
				;		with handle.
				;
				; Enter : AH = 21
				;		BX = handle
				;
				; Return :
				;	error return - carry flag set, DH = error code.
				;
				;	Non-error return - carry flag clear, AX = mode number.
				;
				; Destroied registers :
				;
				;---------------------------------------------------------------------+
					PUBLIC	f_get_rcv_mode
 0521				f_get_rcv_mode:
 0521  E8 031D				call	verify_handle
 0524  A1 03BC R			mov	ax,rcv_mode_num 	;return the current receive mode.
 0527  89 46 10				mov	_AX[bp],ax
 052A  F8				clc
 052B  C3				ret
				;;--------------------------------------------------------------------------

				EXTRN	MulticastTable : BYTE
				EXTRN	AddMulticastAddress : NEAR

				;--------------------------------------------------------------------+
				; Name : f_set_multicast_list
				;
				; Description:
				;
				; Enter : AH = 22
				;	     ES:DI = pointer of multicast table
				;		CX = length of bytes
				;
				; Return :
				;	error return - carry flag set, DH = error code.
				;
				;	Non-error return - carry flag clear.
				;
				; Destroied registers :
				;
				;---------------------------------------------------------------------+
					PUBLIC	f_set_multicast_list
 052C				f_set_multicast_list:
				;following instruction not needed because cx hasn't been changed.
				;	mov	cx,_CX[bp]		;Tell them how much room they have.

				;verify that they supplied an even number of EADDR's.
 052C  8B C1				mov	ax,cx
 052E  33 D2				xor	dx,dx
 0530  BB 0006				mov	bx,EADDR_LEN
 0533  F7 F3				div	bx
 0535  0B D2				or	dx,dx			;zero remainder?
 0537  75 23				jne	f_set_multicast_list_2	;no, we don't have an even number of
									;  addresses.
 0539  8B D8				mov	bx, ax			;; Save number of address
 053B  8B C8				mov	cx, ax
 053D				multi_bit_chk:
 053D  26: 8A 05			mov  al, BYTE PTR es:[di]	; Get first byte of address
 0540  24 01				and  al, 01h			; Check least significant bit
 0542  74 18				jz	f_set_multicast_list_2
 0544  83 C7 06				add	di, EADDR_LEN
 0547  E2 F4				loop	multi_bit_chk

				;;	  cmp	  ax,MAX_MULTICAST	  ;is this too many?
				;;	  ja	  f_set_multicast_list_3  ;yes - return NO_SPACE
				; Verify Multicast Table space.
 0549  8B 16 0000 E			mov	dx, MulticastTable.table_maxnum
 054D  2B 16 0002 E			sub	dx, MulticastTable.table_current
 0551  3B C2				cmp	ax, dx
 0553  77 0B				ja	f_set_multicast_list_3	;yes - return NO_SPACE

 0555				f_set_multicast_list_1:
				;;	  mov	  multicast_count,ax	  ;remember the number of addresses.
				;;	  movseg  es,cs
				;;	  mov	  di,offset multicast_addrs
				;;	  push	  ds
				;;	  mov	  ds,_ES[bp]		  ; get ds:si -> new list.
				;;	  mov	  si,_DI[bp]
				;;	  push	  cx
				;;	  rep	  movsb
				;;	  pop	  cx
				;;	  pop	  ds

 0555  8B 76 06				mov	si,_DI[bp]		;; ES:SI -> new address list
 0558  E8 0000 E			call	AddMulticastAddress	;; BX = number of address to added
				;;	  call	  set_multicast_list
 055B  C3				ret

 055C				f_set_multicast_list_2:
 055C  B6 0E				mov	dh,BAD_ADDRESS
 055E  F9				stc
 055F  C3				ret

 0560				f_set_multicast_list_3:
 0560  B6 09				mov	dh,NO_SPACE
 0562  F9				stc
 0563  C3				ret
				;;----------------------------------------------------------------------------


				;--------------------------------------------------------------------+
				; Name : f_get_multicast_list
				;
				; Description: address list point to length bytes of multicast address.
				;
				; Enter : AH = 23
				;
				; Return :
				;	error return - carry flag set, DH = error code.
				;
				;	Non-error return : carry flag clear.
				;				ES:DI = address list.
				;				   CX = Length of bytes
				;
				; Destroied registers : BX, AX, CX, SI, DI, ES
				;
				;---------------------------------------------------------------------+
					PUBLIC	f_get_multicast_list
 0564				f_get_multicast_list:
 0564  BB 0000 E			mov	bx, OFFSET MulticastTable
 0567  8B F3				mov	si, bx
 0569  83 C6 04				add	si, 4			     ;; Point to first address
 056C  8C D8				mov	ax, ds
 056E  8E C0				mov	es, ax				;; ES = DS
 0570  BF 0346 R			mov	di, OFFSET multicast_addrs
 0573  8B 0E 0002 E			mov	cx, MulticastTable.table_current	;; Number of multicast address
 0577  8B D9				mov	bx, cx				;; save number of address
 0579  83 F9 00				cmp	cx, 0			;; Don't move data if no multicast addr.
 057C  74 08				je	gmt_return

 057E				multicast_move:
 057E  A5				movsw
 057F  A5				movsw
 0580  A5	movsw
 0581  83 C6 0A				add	si, 10				;; Skip to next address
 0584  E2 F8				loop	multicast_move

 0586				gmt_return:
 0586  8C 5E 00				mov	_ES[bp],ds		;return what we have remembered.
 0589  C7 46 06 0000			mov	_DI[bp],offset multicast_addrs
 058E  B8 0006				mov	ax,EADDR_LEN		;multiply the count by the length.
				;;	  mul	  multicast_count
 0591  F7 E3				mul	bx
 0593  89 46 0C				mov	_CX[bp],ax		;because they want total bytes.
 0596  F8				clc
 0597  C3				ret
				;;--------------------------------------------------------------------------

				;--------------------------------------------------------------------+
				; Name : f_get_statistics
				;
				; Description: Returns a pointer to a statistics structure for the interface.
				;
				; Enter : AH = 24
				;		BX = handle
				;
				; Return :
				;	error return - carry flag set, DH = error code.
				;
				;	Non-error return : carry flag clear.
				;				DS:SI = statistics sturcture.
				;
				; Destroied registers :
				;
				;---------------------------------------------------------------------+

 0598				f_get_statistics:
 0598  E8 02A6				call	verify_handle		;just in case.
 059B  8C 5E 02				mov	_DS[bp],ds
 059E  C7 46 08 0000			mov	_SI[bp],offset statistics_list
 05A3  F8				clc
 05A4  C3				ret
				;;-------------------------------------------------------------------------




				;; Called by f_access_type
 05A5				access_type_class:
 05A5  B6 02				mov	dh,NO_CLASS
 05A7  F9				stc
 05A8  C3				ret



				;; Called by f_access_type
 05A9				access_type_type:
 05A9  B6 03				mov	dh,NO_TYPE
 05AB  F9				stc
 05AC  C3				ret


				;; Called by f_access_type
 05AD				access_type_number:
 05AD  B6 04				mov	dh,NO_NUMBER
 05AF  F9				stc
 05B0  C3				ret


				;; Called by f_access_type
 05B1				access_type_bad:
 05B1  B6 05				mov	dh,BAD_TYPE
 05B3  F9				stc
 05B4  C3				ret



				;register caller of pkt TYPE

				;--------------------------------------------------------------------+
				; Name : f_access_type
				;
				; Description: Initiate access to packets of the specified type.
				;		This could get Handle & Receiver function entry point.
				;
				; Enter : AH = 2
				;		AL:	Class
				;		BX:	Type
				;		DL:	Number
				;	     DS:SI:	Type Name
				;		CX:	type length
				;	     ES:DI:	Receiver function
				;
				; Return :
				;	error return - carry flag set, DH = error code.
				;
				;	Non-error return - carry flag clear, AX = handle.
				;
				; Destroied registers : AX, BX, CX, DX, SI, DI, DS, ES
				;
				;---------------------------------------------------------------------+
					PUBLIC f_access_type
 05B5				f_access_type:
 05B5  BB 0000 E			mov	bx, offset driver_class

 05B8				access_type_9:
 05B8  8A 07				mov	al, [bx]		;get the next class.
 05BA  43				inc	bx
 05BB  0A C0				or	al,al			;end of the list?
 05BD  74 E6				je	access_type_class	;class failed (story of my life)
				;;-- Check Class
 05BF  38 46 10				cmp	_AL[bp],al		;our class?
 05C2  75 F4				jne	access_type_9		;no, try again

 05C4				access_type_1:
 05C4  83 7E 0E FF			cmp	_BX[bp],-1		;generic type?
 05C8  74 09				je	access_type_2		;yes.
 05CA  A0 0000 E			mov	al,driver_type
 05CD  98				cbw
 05CE  39 46 0E				cmp	_BX[bp],ax		;our type?
 05D1  75 D6				jne	access_type_type	;no.

 05D3				access_type_2:
 05D3  80 7E 0A 00			cmp	_DL[bp],0		;generic number?
 05D7  74 06				je	access_type_3
 05D9  80 7E 0A 01			cmp	_DL[bp],1		;our number?
 05DD  75 CE				jne	access_type_number

 05DF				access_type_3:
 05DF  83 7E 0C 08			cmp	_CX[bp],MAX_P_LEN	;is the type length too long? (8)
 05E3  77 CC				ja	access_type_bad 	;yes - can't be ours.

				; now we do two things--look for an open handle, and check the existing
				; handles to see if they're replicating a packet type.
 05E5  C7 06 03BE R 0000		mov	free_handle,0		;remember no free handle yet.
 05EB  BB 024E R			mov	bx,offset handles

 05EE				access_type_4:		;; Serach start
 05EE  80 3F 00				cmp	[bx].in_use,0		;is this handle in use?
 05F1  74 2D				je	access_type_5		;no - don't check the type.
 05F3  8A 46 10				mov	al, _AL[bp]		;is this handle the same class as
 05F6  3A 47 17				cmp	al, [bx].class		;  they're want?
 05F9  75 30				jne	short access_type_6
 05FB  8E 46 02				mov	es,_DS[bp]		;get a pointer to their type
 05FE  8B 7E 08				mov	di,_SI[bp]		;  from their ds:si to our es:di
 0601  8B 4E 0C				mov	cx,_CX[bp]		;get the minimum of their length
									;  and our length.  As currently
									;  implemented, only one receiver
									;  gets the packets, so we have to
									;  ensure that the shortest prefix
									;  is unique.

 0604  3B 4F 09				cmp	cx,[bx].packet_type_len ;Are we less specific than they are?
 0607  72 03				jb	access_type_8		;no.
 0609  8B 4F 09				mov	cx,[bx].packet_type_len ;yes - use their count.

 060C				access_type_8:
 060C  8D 77 01				lea	si,[bx].packet_type
 060F  0B C9				or	cx,cx			; pass-all TYPE? (zero TYPE length)
 0611  75 05				jne	access_type_7		; ne = no
 0613  BB 0326 R			mov	bx,offset handles+(MAX_HANDLE-1)*(size per_handle)
 0616  EB 08				jmp	short access_type_5	; put pass-all last

 0618				access_type_7:
 0618  F3/ A6				repe	cmpsb
 061A  75 0F				jne	short access_type_6	;go look at the next one.

 061C				access_type_inuse:
 061C  B6 0A				mov	dh,TYPE_INUSE		;a handle has been assigned for TYPE
 061E  F9				stc				;and we can't assign another
 061F  C3				ret

 0620				access_type_5:				;handle is not in use
 0620  83 3E 03BE R 00			cmp	free_handle,0		;found a free handle yet?
 0625  75 04				jne	access_type_6		;yes.
 0627  89 1E 03BE R			mov	free_handle,bx		;remember a free handle

 062B				access_type_6:
 062B  83 C3 18				add	bx,(size per_handle)	;go to the next handle.
 062E  81 FB 033E R			cmp	bx,offset end_handles	;examined all handles?
 0632  72 BA				jb	access_type_4		;no, continue.
 0634  8B 1E 03BE R			mov	bx,free_handle		;did we find a free handle?
 0638  0B DB				or	bx,bx
 063A  74 3E				je	access_type_space	;no - return error.
 063C  C6 07 01				mov	[bx].in_use,1		;remember that we're using it.
 063F  8B 46 06				mov	ax,_DI[bp]		;remember the receiver type.
 0642  89 47 0B				mov	[bx].receiver.offs,ax
 0645  8B 46 00				mov	ax,_ES[bp]
 0648  89 47 0D				mov	[bx].receiver.segm,ax

 064B  1E				push	ds

 064C  8C D8				mov	ax,ds		;; ES = DS
 064E  8E C0				mov	es,ax
 0650  8E 5E 02				mov	ds,_DS[bp]		;remember their type.
 0653  8B 76 08				mov	si,_SI[bp]
 0656  8B 4E 0C				mov	cx,_CX[bp]
 0659  26: 89 4F 09			mov	es:[bx].packet_type_len,cx	; remember the TYPE length
 065D  8D 7F 01				lea	di,[bx].packet_type
 0660  F3/ A4				rep	movsb

 0662  26: C5 77 0B			lds	si,es:[bx].receiver	;copy the first 8 bytes
 0666  8D 7F 0F				lea	di,[bx].receiver_sig	; to the receiver signature.
 0669  B9 0004				mov	cx,8/2
 066C  F3/ A5				rep	movsw

 066E  1F				pop	ds

 066F  8A 46 10				mov	al, _AL[bp]
 0672  88 47 17				mov	[bx].class, al
 0675  89 5E 10				mov	_AX[bp],bx		;return the handle to them.

 0678  F8				clc

 0679  C3				ret
				;;--------------------------------------------------------------------------

				;; Called by f_access_type
 067A				access_type_space:
 067A  B6 09				mov	dh,NO_SPACE
 067C  F9				stc
 067D  C3				ret


				;--------------------------------------------------------------------+
				; Name : f_release_type
				;
				; Description: This function ends access to packets associated with
				;		a handle.
				;
				; Enter : AH = 3
				;		BX = Handle
				;
				; Return :
				;		Error - carry flag set, DH = error code.
				;	    Non-error - carry flag clear.
				;
				; Destroied registers :
				;
				;---------------------------------------------------------------------+
					PUBLIC f_release_type
 067E				f_release_type:
 067E  E8 01C0				call	verify_handle		;mark this handle as being unused.
 0681  C6 07 00				mov	[bx].in_use,0

 0684  E8 01A9				call	count_handles		;All handles gone now?

 0687  80 F9 00				cmp	cl,0
 068A  75 00				jne	f_release_type_1	;no, don't change the receive mode.

				  if 0
				  endif

 068C				f_release_type_1:
 068C  F8				clc
 068D  C3				ret
				;;--------------------------------------------------------------------------



				;--------------------------------------------------------------------+
				; Name : f_send_pkt
				;
				; Description: Transmit legth bytes of data, starting at buffer.
				;
				; Enter : AH = 4
				;		CX = length.
				;	     DS:SI = buffer
				;
				; Return :
				;		Error - carry flag set, DH = error code.
				;	    Non-error - carry flag clear.
				;
				; Destroied registers :
				;
				;---------------------------------------------------------------------+
				IFDEF OK
				ENDIF	;; OK

				EXTRN	PortPrintMessage : NEAR

					PUBLIC	f_send_pkt
 068E				f_send_pkt:

				; Enter with ds:si -> buffer, cx = length
				; XXX Should re-enable interrupts here, but some drivers are broken.
				; Possibly re-enable interrupts.
				;	test _F[bp], EI 	; Were interrupts enabled on pkt driver entry?
				;	je	f_send_pkt_1	; No.
				;	sti			; Yes, re-enable interrupts now.
				;f_send_pkt_1:

				;following two instructions not needed because si and cx haven't been changed.
				;	mov	si,_SI[bp]
				;	mov	cx,_CX[bp]	; count of bytes in the packet.

				.386
				;;	  inc	 packets_out


				;;	  xor	  eax, eax
				;;	  mov	  ax, cx
				;;	  add	 bytes_out,eax		  ;add up the received bytes.
 068E  1E				push	ds
 068F  8E 5E 02				mov	ds,_DS[bp]	; address of buffer from caller's ds.
					assume	ds:nothing, es:nothing

				IFDEF OK
				ENDIF	;; OK

				; If -n option take Ethernet encapsulated Novell IPX packets (from BYU's
				; PDSHELL) and change them to be IEEE 802.3 encapsulated.

 = 000C				EPROT_OFF	equ	EADDR_LEN*2

 0692  2E: F7 06 0216 R			test	cs:flagword,N_OPTION
       0004
 0699  75 05				jnz	f_send_pkt_2
 069B  E8 0000 E			call	send_pkt
 069E  1F				pop	ds

				;;-- Delay
				;;	  pusha
				;;	  popa

				IFDEF OK
				ENDIF	;; OK

 069F  C3				ret

 06A0				f_send_pkt_2:
 06A0  81 7C 0C 3781			cmp	ds:[si].EPROT_OFF,3781h ; if not Novell (prot 8137)
 06A5  75 0F				jne	f_send_pkt_3		;  don't tread on it
 06A7  50				push	ax			; get scratch reg
 06A8  8B 44 10				mov	ax,[si].EPROT_OFF+4	; get len
 06AB  86 E0				xchg	ah,al
 06AD  40				inc	ax			; make even (rounding up)
 06AE  24 FE				and	al,0feh
 06B0  86 E0				xchg	ah,al
 06B2  89 44 0C				mov	ds:[si].EPROT_OFF,ax	; save in prot field
 06B5  58				pop	ax			; restore old contents

 06B6				f_send_pkt_3:
 06B6  E8 0000 E			call	send_pkt
 06B9  1F				pop	ds
 06BA  C3				ret
				;;---------------------------------------------------------------------------

				;--------------------------------------------------------------------+
				; Name : f_as_send_pkt
				;
				; Description: Transmit legth bytes of data, starting at buffer.
				;		When the application's data has been copied out of the buffer,
				;		and the application can safely modify or re-use the buffer.
				;
				;
				; Enter : AH = 11 or 12
				;	     ES:DI = iocb structure
				;     * following are described in the specification.
				;     * 	CX = length.
				;     *      DS:SI = buffer
				;     *      ES:DI = upcall function
				;
				; Return :
				;		Error - carry flag set, DH = error code.
				;	    Non-error - carry flag clear.
				;
				; Destroied registers :
				;
				; Notes:
				;	04/24/96 - as_send_pkt is not implemented yet.
				;
				;---------------------------------------------------------------------+
					assume	ds:code

 06BB				f_as_send_pkt:

				;es:di -> iocb.
 06BB  F6 06 0000 E 04			test	driver_function,4	; is this a high-performance driver? (2)
 06C0  74 25				jz	f_as_send_pkt_2 	; no. ;; not 5 or 6

				; Possibly re-enable interrupts.
 06C2  F7 46 16 0200			test _F[bp], EI 		; Were interrupts enabled on pkt driver entry?
 06C7  74 01				je	f_as_send_pkt_1 	; No.
 06C9  FB				sti				; Yes, re-enable interrupts now.

 06CA				f_as_send_pkt_1:
 06CA  1E				push	ds			; set up proper ds for the buffer
 06CB  26: C5 35			lds	si,es:[di].buffer	; ds:si -> buffer(upper layer)
					assume	ds:nothing
 06CE  26: 8B 4D 04			mov	cx,es:[di].len		; cx = length
 06D2  66| 2E: FF 06 03D2 R		inc    packets_out
 06D8  66| 0F B7 C1			movzx	eax, cx
 06DC  66| 2E: 01 06 03DA R		add    bytes_out,eax		; add up the received bytes.

				;ds:si -> buffer, cx = length, es:di -> iocb.
 06E2  E8 0000 E			call	as_send_pkt		;; Not yet implements
 06E5  1F				pop	ds
					assume	ds:code
 06E6  C3				ret

 06E7				f_as_send_pkt_2:
 06E7  B6 0B				mov dh, BAD_COMMAND		; return an error.
 06E9  F9				stc
 06EA  C3				ret
				;;------------------------------------------------------------------------



				;--------------------------------------------------------------------+
				; Name : f_drop_pkt
				;
				; Description: This function is not described in the specification.
				;
				;
				; Enter : AH = 13
				;
				; Return :
				;		Error - carry flag set, DH = error code.
				;	    Non-error - carry flag clear.
				;
				; Destroied registers :
				;
				;---------------------------------------------------------------------+

 06EB				f_drop_pkt:

				; es:di -> iocb.
 06EB  F6 06 0000 E 04			test	driver_function,4	; is this a high-performance driver?
 06F0  74 F5				jz	f_as_send_pkt_2 	; no.
 06F2  1E				push	ds			; Preserve ds
 06F3  BE 03C6 R			mov	si,offset send_head	; Get head offset

 06F6				dp_loop:
 06F6  8B 04				mov	ax,ds:[si]		; Get offset
 06F8  8B 54 02				mov	dx,ds:[si+2]		; Get segment
 06FB  8B D8				mov	bx,ax
 06FD  0B DA				or	bx,dx			; End of list?
 06FF  74 22				je	dp_endlist		; Yes

 0701  3B C7				cmp	ax,di			; Offsets equal?
 0703  75 15				jne	dp_getnext		; No

 0705  8C C3				mov	bx,es
 0707  3B D3				cmp	dx,bx			; Segments equal?
 0709  75 0F				jne	dp_getnext		; No

 070B  E8 0000 E			call	drop_pkt		; Pass to driver ;; Not implement yet
 070E  26: C4 7D 0C			les	di,es:[di].next 	; Get next segment:offset
 0712  89 3C				mov	ds:[si],di		; Set next offset
 0714  8C 44 02				mov	ds:[si+2],es		; Set next segment
 0717  1F				pop	ds			; Restore ds
 0718  F8				clc
 0719  C3				ret

 071A				dp_getnext:
 071A  8E DA				mov	ds,dx			; Get next segment
 071C  8B F0				mov	si,ax			; Get next iocb offset
 071E  8D 74 0C				lea	si,ds:[si].next 	; Get next iocb next ptr offset
 0721  EB D3				jmp	dp_loop 		; Try again

 0723				dp_endlist:
 0723  1F				pop	ds			; Restore ds
 0724  B6 10				mov	dh,BAD_IOCB		; Return error
 0726  F9				stc				; Set carry
 0727  C3				ret
				;;--------------------------------------------------------------------------



				;--------------------------------------------------------------------+
				; Name : f_terminate
				;
				; Description: Terminate the driver associated with handle.
				;		Release memory.
				;
				; Enter : AH = 5
				;		BX = Handle.
				;
				; Return :
				;		Error - carry flag set, DH = error code.
				;	    Non-error - carry flag clear.
				;
				; Destroied registers :
				;
				;---------------------------------------------------------------------+

 0728				f_terminate:
 0728  E8 0116				call	verify_handle		; must have a handle
 072B  C6 07 00				mov	[bx].in_use,0		; mark handle as free
 072E  E8 00FF				call	count_handles		; all handles gone?
									; return CL = Number of handles
 0731  0A C9				or	cl,cl
 0733  75 53				jne	f_terminate_4		; no, can't exit completely

				;;;;++, 2000.6.27, htho, fix noise level bug
					extrn	Reset_MAC_PHY: near
 0735  E8 0000 E			call	Reset_MAC_PHY
				;;;;++
				;
				; Now disable interrupts
				;
 0738  A0 0000 E			mov	al,int_no
 073B  0A C0				or	al,al			;are they using a hardware interrupt?
 073D  74 1F				je	f_terminate_no_irq	;no.
 073F  80 3E 0218 R 00			cmp	original_mask,0 	;was it enabled?
 0744  74 03				je	f_terminate_no_mask	;yes, don't mask it now.
 0746  E8 0190				call	maskint

 0749				f_terminate_no_mask:
				;
				; Now return the interrupt to their handler.
				;
 0749  B4 25				mov	ah,25h			;get the old interrupt into es:bx
 074B  A0 0000 E			mov	al,int_no
 074E  04 08				add	al,8
 0750  3C 10				cmp	al,8+8			;is it a slave 8259 interrupt?
 0752  72 02				jb	f_terminate_3		;no.
 0754  04 60				add	al,70h - (8+8)		;map it to the real interrupt.

 0756				f_terminate_3:
 0756  1E				push	ds
 0757  C5 16 03EE R			lds	dx,their_recv_isr
 075B  CD 21				int	21h
 075D  1F				pop	ds

 075E				f_terminate_no_irq:
 075E  83 3E 03F4 R 00			cmp	their_timer.segm,0	;did we hook the timer interrupt?
 0763  74 0B				je	f_terminate_no_timer
				;; -+, 971230, Hu-Tiong, inherent bug of public domain code
 0765  B8 2508				mov	ax,2508h		;restore the timer interrupt.
				;;;;	mov	ax,251Ch		;restore the timer interrupt.
				;; -+
 0768  1E				push	ds
 0769  C5 16 03F2 R			lds	dx,their_timer
 076D  CD 21				int	21h
 076F  1F				pop	ds

 0770				f_terminate_no_timer:
 0770  E8 0000 E			call	terminate		;terminate the hardware.
									;; Do nothing
 0773  A0 020E R			mov	al,entry_point	;release our_isr.
 0776  B4 25				mov	ah,25h
 0778  1E				push	ds
 0779  C5 16 03F6 R			lds	dx,their_isr
 077D  CD 21				int	21h
 077F  1F				pop	ds
				;
				; Now free our memory
				;
					movseg	es,cs
 0780  0E		     1		push	cs
 0781  07		     1		pop	es
 0782  B4 49				mov	ah,49h
 0784  CD 21				int	21h
 0786  F8				clc
 0787  C3				ret

 0788				f_terminate_4:
 0788  B6 07				mov	dh, CANT_TERMINATE
 078A  F9				stc
 078B  C3				ret
				;;--------------------------------------------------------------------------



				;--------------------------------------------------------------------+
				; Name : f_get_address
				;
				; Description: Get the current local net address.
				;
				; Enter : AH = 6
				;		BX = Handle.
				;	     ES:DI = store address buffer.
				;		CX = buffer size
				;
				; Return :
				;		Error - carry flag set, DH = error code.
				;	    Non-error - carry flag clear, CX = copied length.
				;
				; Destroied registers :
				;
				;---------------------------------------------------------------------+

 078C				f_get_address:
				;	call	verify_handle
				;	mov	es,_ES[bp]		; get new one
				;	mov	di,_DI[bp]		; get pointer, es:di is ready
				;	mov	cx,_CX[bp]		;Tell them how much room they have.

 078C  3B 0E 039A R			cmp	cx,address_len		;is there enough room for our address?
 0790  72 0E				jb	get_address_space	;no.
 0792  8B 0E 039A R			mov	cx,address_len		;yes - get our address length.
 0796  89 4E 0C				mov	_CX[bp],cx		;Tell them how long our address is.
 0799  BE 03AC R			mov	si,offset my_address	;copy it into their area.
 079C  F3/ A4				rep	movsb
 079E  F8				clc
 079F  C3				ret

 07A0				get_address_space:
 07A0  B6 09				mov	dh,NO_SPACE
 07A2  F9				stc
 07A3  C3				ret

				;;----------------------------------------------------------------------------


				EXTRN	PortUpdateReceiveFilter : NEAR
				;--------------------------------------------------------------------+
				; Name : f_set_address
				;
				; Description:
				;
				; Enter : AH = 25
				;		ES:DI = address.
				;		   CX = length
				;
				; Return :
				;		Error - carry flag set, DH = error code.
				;	    Non-error - carry flag clear, CX = length.
				;
				; Destroied registers :
				;
				;---------------------------------------------------------------------+

 07A4				f_set_address:
 07A4  E8 0089				call	count_handles
 07A7  80 F9 01				cmp	cl,1			;more than one handle in use?
 07AA  77 33				ja	f_set_address_inuse	;yes - we can't set the address

 07AC  8B 4E 0C				mov	cx,_CX[bp]		;get the desired address length.
 07AF  80 FD 00				cmp	ch,0
 07B2  3A 0E 0003 E			cmp	cl,parameter_list[3]	;is it the right length?
 07B6  77 2B				ja	f_set_address_too_long	;no.

 07B8  8E 5E 00				mov	ds,_ES[bp]		; set new one
					assume	ds:nothing
 07BB  8B 76 06				mov	si,_DI[bp]		; set pointer, ds:si is ready
 07BE  8C C8				mov	ax,cs
 07C0  8E C0				mov	es,ax
 07C2  BF 03AC R			mov	di,offset my_address
 07C5  F3/ A4				rep	movsb
 07C7  8E D8				mov	ds,ax			;restore ds.
					assume	ds:code
 07C9  8B 4E 0C				mov	cx,_CX[bp]		;get the desired address length.
 07CC  BE 03AC R			mov	si,offset my_address

				;;	call	set_address
 07CF  E8 0000 E			call	PortUpdateReceiveFilter

 07D2  72 13				jc	f_set_address_err	;Did it work?
 07D4  8A 0E 0003 E			mov	cl,parameter_list[3]
 07D8  32 ED				xor	ch,ch
 07DA  89 4E 0C				mov	_CX[bp],cx		;yes - return our address length.
 07DD  F8				clc
 07DE  C3				ret

 07DF				f_set_address_inuse:
 07DF  B6 0D				mov	dh,CANT_SET
 07E1  F9				stc
 07E2  C3				ret

 07E3				f_set_address_too_long:
 07E3  B6 09				mov	dh,NO_SPACE
 07E5  F9				stc
 07E6  C3				ret

 07E7				f_set_address_err:

				;we get here with cy set - leave it set.
 07E7  BE 039C R			mov	si,offset rom_address	;we can't set the address, restore
 07EA  BF 03AC R			mov	di,offset my_address	;  to original.
 07ED  B9 0008				mov	cx,MAX_ADDR_LEN/2
 07F0  F3/ A5				rep	movsw
 07F2  C3				ret
				;;--------------------------------------------------------------------------



				;--------------------------------------------------------------------+
				; Name : f_reset_interface
				;
				; Description: Resets the interface associated with handle to a known
				;		state, aborting any transmits in process and reinitializing
				;		the receiver.
				;	       (1)The local net address is reset to the default(from ROM),
				;		(2)the multicast list is cleared, and (3)the receive mode
				;		is set to 3(own address & broadcasts).
				;	       (4)If multiple handles are open, these actions might seriously
				;		disrupt other applications using the interface,
				;		so CANT_RESET should be returned.
				;
				; Enter : AH = 7
				;		BX = Handle.
				;
				; Return :
				;		Error - carry flag set, DH = error code.
				;	    Non-error - carry flag clear, CX = copied length.
				;
				; Destroied registers :
				;
				;---------------------------------------------------------------------+

 07F3				f_reset_interface:
 07F3  E8 004B				call	verify_handle		;; Handle is real.
 07F6  72 0D				jc	reset_bad_handle
 07F8  E8 0035				call	count_handles		;; (4)
 07FB  80 F9 01				cmp	cl, 1
 07FE  77 06				ja	multihandle

 0800  E8 0000 E			call	PortUpdateReceiveFilter ;; (1), (2), (3)
				;;	call	reset_interface
 0803  F8				clc
 0804  C3				ret

 0805				reset_bad_handle:
 0805  C3				ret

 0806				multihandle:
 0806  F9				stc
 0807  B6 0F				mov	dh, CANT_RESET
 0809  C3				ret
				;;-------------------------------------------------------------------------




				;--------------------------------------------------------------------+
				; Name : f_stop
				;
				; Description: This function is not specified in the PC/TCP Version 1.09
				;		Packet Driver Specification.
				;	       Stop the packet driver doing upcalls.
				;	       Also a following terminate will always succed
				;	       (no in use handles any longer).
				;
				; Enter : AH = 8
				;
				; Return :
				;	    carry flag clear.
				;
				; Destroied registers :
				;
				;---------------------------------------------------------------------+

 080A				f_stop:
 080A  BB 024E R			mov	bx,offset handles

 080D				f_stop_2:
 080D  C6 07 00				mov	[bx].in_use,0
 0810  83 C3 18				add	bx,(size per_handle)	; next handle
 0813  81 FB 033E R			cmp	bx,offset end_handles
 0817  72 F4				jb	f_stop_2
 0819  F8				clc
 081A  C3				ret
				;;--------------------------------------------------------------------------


				;--------------------------------------------------------------------+
				; Name : f_get_parameters
				;
				; Description: High-performance driver function.
				;
				;
				; Enter : AH = 10
				;
				; Return :
				;	    carry flag clear.
				;
				; Destroied registers :
				;
				;---------------------------------------------------------------------+
 081B				f_get_parameters:

				;strictly speaking, this function only works for high-performance drivers.
 081B  F6 06 0000 E 04			test	driver_function,4	;is this a high-performance driver?
 0820  75 04				jne	f_get_parameters_1	;yes.
 0822  B6 0B				mov	dh,BAD_COMMAND		;no - return an error.
 0824  F9				stc
 0825  C3				ret

 0826				f_get_parameters_1:
 0826  8C 4E 00				mov	_ES[bp],cs
 0829  C7 46 06 0000			mov	_DI[bp],offset parameter_list
 082E  F8				clc
 082F  C3				ret
				;;---------------------------------------------------------------------------




				;--------------------------------------------------------------------+
				; Name : count_handles
				;
				; Description: Count handles currently in use.
				;
				; Enter :
				;
				; Return : CL = Number of handles currently in use.
				;
				; Destroied registers :
				;
				;---------------------------------------------------------------------+
 0830				count_handles:
				;exit with cl = number of handles currently in use.
 0830  BB 024E R			mov	bx,offset handles
 0833  B1 00				mov	cl,0			;number of handles in use.

 0835				count_handles_1:
 0835  02 0F				add	cl,[bx].in_use		;is this handle in use?
 0837  83 C3 18				add	bx,(size per_handle)	;go to the next handle.
 083A  81 FB 033E R			cmp	bx,offset end_handles
 083E  72 F5				jb	count_handles_1

 0840  C3				ret
				;;--------------------------------------------------------------------



				;--------------------------------------------------------------------+
				; Name : verify_handle
				;
				; Description: Ensure that handle is real.
				;
				; Enter :
				; Return : Error - carry flag set.
				;
				; Destroied registers :
				;
				;---------------------------------------------------------------------+

 0841				verify_handle:
				;Ensure that their handle is real.  If it isn't, we pop off our return
				;address, and return to *their* return address with cy set.
 0841  8B 5E 0E				mov	bx,_BX[bp]		;get the handle they gave us
 0844  81 FB 024E R			cmp	bx,offset handles
 0848  72 0C				jb	verify_handle_bad	;no - must be bad.
 084A  81 FB 033E R			cmp	bx,offset end_handles
 084E  73 06				jae	verify_handle_bad	;no - must be bad.
 0850  80 3F 01				cmp	[bx].in_use,1		;if it's not in use, it's bad.
 0853  75 01				jne	verify_handle_bad
 0855  C3				ret

 0856				verify_handle_bad:
 0856  B6 01				mov	dh,BAD_HANDLE
 0858  83 C4 02				add	sp,2			;pop off our return address.
 085B  F9				stc
 085C  C3				ret

					public	set_recv_isr
 085D				set_recv_isr:
 085D  B4 35				mov	ah,35h			;get the old interrupt into es:bx
 085F  A0 0000 E			mov	al,int_no		; board's interrupt vector
 0862  0A C0				or	al,al
 0864  74 3E				je	set_isr_no_irq
 0866  04 08				add	al,8
 0868  3C 10				cmp	al,8+8			;is it a slave 8259 interrupt?
 086A  72 02				jb	set_recv_isr_1		;no.
 086C  04 60				add	al,70h - 8 - 8		;map it to the real interrupt.

				EXTRN	InterruptMain : NEAR

 086E				set_recv_isr_1:
 086E  CD 21				int	21h
 0870  89 1E 03EE R			mov	their_recv_isr.offs,bx	;remember the old seg:off.
 0874  8C 06 03F0 R			mov	their_recv_isr.segm,es

 0878  B4 25				mov	ah,25h			;now set our recv interrupt.
				;;	  mov	  dx,offset recv_isr
 087A  BA 0000 E			mov	dx, OFFSET InterruptMain
 087D  CD 21				int	21h

 087F  80 3E 0000 E CF			cmp	byte ptr timer_isr,0cfh ;is there just an iret at their handler?
 0884  74 15				je	set_isr_no_timer	;yes, don't bother hooking the timer.

				;;-+, 980929, Hu-Tiong
				;;	mov	ax,351Ch		;get the old interrupt into es:bx
 0886  B8 3508				mov	ax,3508h		;get the old interrupt into es:bx
				;;-+
 0889  CD 21				int	21h

 088B  89 1E 03F2 R			mov	their_timer.offs,bx	;remember the old seg:off.
 088F  8C 06 03F4 R			mov	their_timer.segm,es

				;;-+, 980929, Hu-Tiong
				;;	mov	ax,251Ch		  ;now set our recv interrupt.
 0893  B8 2508				mov	ax,2508h		  ;now set our recv interrupt.
				;;-+
 0896  BA 0000 E			mov	dx,offset timer_isr
 0899  CD 21				int	21h

 089B				set_isr_no_timer:
 089B  A0 0000 E			mov	al,int_no		; Now enable interrupts
 089E  E8 005B				call	unmaskint
 08A1  A2 0218 R			mov	original_mask,al

 08A4				set_isr_no_irq:
 08A4  C3				ret



				;;	  public  count_in_err
				;;
				;;count_in_err:
				;;
				;;	  assume  ds:nothing
				;;
				;;	  add	 errors_in,1
				;;
				;;	  ret
				;;
				;;
				;;
				;;	  public  count_out_err
				;;
				;;count_out_err:
				;;
				;;	  assume  ds:nothing
				;;
				;;	  inc	 errors_out
				;;
				;;	  ret

 000C				recv_isr_frame	struc
 0000  0000			  recv_isr_ds	  dw	  ?
 0002  0000			  recv_isr_dx	  dw	  ?
 0004  0000			  recv_isr_ax	  dw	  ?
 0006  0000			  recv_isr_ip	  dw	  ?
 0008  0000			  recv_isr_cs	  dw	  ?
 000A  0000			  recv_isr_f	  dw	  ?
				recv_isr_frame	ends

				IFDEF OK
				ENDIF	;;OK


 08A5 00			recv_exiting_flag	db	0	;nonzero if recv_exiting will be run.

 08A6 00000000			recv_exiting_addr	dd	?



					public	schedule_exiting

 08AA				schedule_exiting:

				;call this routine to schedule a subroutine that gets run after the

				;recv_isr.  This is done by stuffing routine's address in place

				;of the recv_isr iret's address.  This routine should push the flags when it

				;is entered, and should jump to recv_exiting_exit to leave.

				;enter with ax = address of routine to run.

 08AA  80 3E 08A5 R 00			cmp	recv_exiting_flag,0	;is it already scheduled?

 08AF  75 18				jne	schedule_exiting_1	;yes, don't do it again!

 08B1  FE 06 08A5 R			inc	recv_exiting_flag	;set the flag.

 08B5  C4 3E 03EA R			les	di,savespss		;make es:di -> their stack.

 08B9  26: 87 45 06			xchg	ax,es:[di].recv_isr_ip	;stuff our routine's address in,

 08BD  A3 08A6 R			mov	recv_exiting_addr.offs,ax	;and save the original address.

 08C0  8C C8				mov	ax,cs

 08C2  26: 87 45 08			xchg	ax,es:[di].recv_isr_cs

 08C6  A3 08A8 R			mov	recv_exiting_addr.segm,ax

 08C9				schedule_exiting_1:

 08C9  C3				ret



					public	recv_exiting_exit

 08CA				recv_exiting_exit:

				;recv_exiting jumps here to exit, after pushing the flags.

 08CA  FA				cli				;protect the following semaphore.

 08CB  C6 06 08A5 R 00			mov	recv_exiting_flag,0

 08D0  FF 36 08A8 R			push	recv_exiting_addr.segm

 08D4  FF 36 08A6 R			push	recv_exiting_addr.offs

 08D8  CF				iret





					public	maskint

 08D9				maskint:
 08D9  0A C0				or	al,al			;are they using a hardware interrupt?
 08DB  74 1E				je	maskint_1		;no, don't mask off the timer!
					assume	ds:code

 08DD  BA 0021				mov	dx,21h			;assume the master 8259.
 08E0  3C 08				cmp	al,8			;using the slave 8259 on an AT?
 08E2  72 05				jb	mask_not_irq2
 08E4  BA 00A1				mov	dx,0a1h 		;go disable it on slave 8259
 08E7  2C 08				sub	al,8

 08E9				mask_not_irq2:
 08E9  8A C8				mov	cl,al
 08EB  EC				in	al,dx			;disable them on the correct 8259.
 08EC  B4 01				mov	ah,1			;set the bit.
 08EE  D2 E4				shl	ah,cl
 08F0  0A C4				or	al,ah

				;
				; 500ns Stall required here, per INTEL documentation for eisa machines
				; - gft - 910617
				;
 08F2  50				push	ax
 08F3  E4 61				in	al,61h	; 1.5 - 3 uS should be plenty
 08F5  E4 61				in	al,61h
 08F7  E4 61				in	al,61h
 08F9  58				pop	ax
 08FA  EE				out	dx,al

 08FB				maskint_1:
 08FB  C3				ret

				;--------------------------------------------------------------------+
				; Name : unmaskint
				;
				; Description: Enable the interrupt.
				;
				; Enter : AL = interrupt number.
				;
				; Return :
				;	CL = 0 if the interrupt had been enabled.
				;	AL = Interrupt Mask Register.
				;
				; Destroied registers :
				;
				;---------------------------------------------------------------------+
					public	unmaskint
 08FC				unmaskint:
				;exit with cl = 0 if the interrupt had been enabled.
					assume	ds:code
 08FC  BA 0021				mov	dx,21h			;assume the master 8259.
 08FF  8A C8				mov	cl,al
 0901  80 F9 08				cmp	cl,8			;using the slave 8259 on an AT?
 0904  72 1A				jb	unmask_not_irq2 	;no
 0906  EC				in	al,dx			;get master mask (21h)
 0907  50				push	ax
 0908  E4 61				in	al,61h			;wait lots of time.
 090A  E4 61				in	al,61h
 090C  E4 61				in	al,61h
 090E  58				pop	ax
 090F  24 FB				and	al,not (1 shl 2)	; and clear slave cascade bit in mask
 0911  EE				out	dx,al			;set new master mask (enable slave int)

				;
				; 500ns Stall required here, per INTEL documentation for eisa machines
				; - gft - 910617
				;
 0912  50				push	ax
 0913  E4 61				in	al,61h	; 1.5 - 3 uS should be plenty
 0915  E4 61				in	al,61h
 0917  E4 61				in	al,61h
 0919  58				pop	ax
 091A  BA 00A1				mov	dx,0a1h 		;go enable int on slave 8259
 091D  80 E9 08				sub	cl,8

 0920				unmask_not_irq2:
 0920  EC				in	al,dx			;enable interrupts on the correct 8259.
 0921  B4 01				mov	ah,1			;clear the bit.
 0923  D2 E4				shl	ah,cl
 0925  8A C8				mov	cl,al			;remember the original mask.
 0927  22 CC				and	cl,ah			;; Return CL=0 if all enable
 0929  80 F9 00				cmp	cl, 0
 092C  74 0D				je	unmask_ret		;; All enable
 092E  F6 D4				not	ah
 0930  22 C4				and	al,ah
				;
				; 500ns Stall required here, per INTEL documentation for eisa machines
				; - gft - 910617
				;
 0932  50				push	ax
 0933  E4 61				in	al,61h	; 1.5 - 3 uS should be plenty
 0935  E4 61				in	al,61h
 0937  E4 61				in	al,61h
 0939  58				pop	ax
 093A  EE				out	dx,al

 093B				unmask_ret:
 093B  C3				ret


					public	recv_locate

 093C				recv_locate:
				;called when we want to determine what to do with a received packet.
				;enter with es:di -> packet type, dl = packet class.
				;exit with cy if the packet is not desired, or nc if we know its type.
					assume	ds:code, es:nothing

				; If -n option take IEEE 802.3 encapsulated packets that could be Novell IPX
				; and make them Ethernet encapsulated Novell IPX packets (for PDSHELL).
 093C  F7 06 0216 R 0004		test	flagword,N_OPTION
 0942  74 28				jz	not_n_op

				; Make IEEE 802.3-like packets that could be Novell IPX into BlueBook class
				; Novell type 8137 packets.
 0944  80 FA 0B				cmp	dl,IEEE8023		;Is this an IEEE 802.3 packet?
 0947  75 12				jne	recv_not_802_3		;no
 0949  26: 83 3D FF			cmp	word ptr es:[di],0ffffh ;if this word not ffff
 094D  75 1D				jne	recv_not_8137		;  then not Novell
 094F  83 EF 02				sub	di,2			; back it up to the 8137 word.
 0952  26: C7 05 3781			mov	es:[di],3781h		; fake as Novell protocol (8137)
 0957  B2 01				mov	dl,BLUEBOOK
 0959  EB 11				jmp	short recv_not_8137

 095B				recv_not_802_3:
				; Convert incoming Ethernet type 8137 IPX packets to type 8138, as with -n in
				; effect we can't send type 8137, and it will only confuse Netware.
 095B  80 FA 01				cmp	dl,BLUEBOOK		;Is this a BLUEBOOK packet?
 095E  75 0C				jne	recv_not_8137		;no, don't change it.
 0960  26: 81 3D 3781			cmp	word ptr es:[di],3781h	;Is it an 8137 packet?
 0965  75 05				jne	recv_not_8137		;no, don't change it.
 0967  26: C7 05 3881			mov	es:[di],word ptr 3881h	;yes, mung it slightly.

 096C				recv_not_8137:

 096C				not_n_op:
 096C  BB 024E R			mov	bx,offset handles

 096F				recv_find_1:
 096F  80 3F 00				cmp	[bx].in_use,0		;is this handle in use?
 0972  74 26				je	recv_find_2		;no - don't check the type.
 0974  8B 47 0B				mov	ax,[bx].receiver.offs	;do they have a receiver?
 0977  0B 47 0D				or	ax,[bx].receiver.segm
 097A  74 1E				je	recv_find_2		;no - they're not serious about it.

				;per request by the UK people, we match on IEEE 802.3 classes, then types.
				;for all others, we match on type, then class.	This lets their software work
				;without breaking BLUEBOOK type length=0 clients.
 097C  80 7F 17 0B			cmp	[bx].class,IEEE8023	;is this an IEEE 802.3 handle
 0980  75 05				jne	recv_find_7		;no.
 0982  80 FA 0B				cmp	dl,IEEE8023		;is the packet also IEEE 802.3?
 0985  75 13				jne	recv_find_2		;no, give up on it now.

				;; BlueBook
 0987				recv_find_7:
 0987  8B 4F 09				mov	cx,[bx].packet_type_len ;compare the packets.
 098A  8D 77 01				lea	si,[bx].packet_type
 098D  E3 1B				jcxz	recv_find_3		;if cx is zero, they want them all.
 098F  38 57 17				cmp	[bx].class, dl		;is this the right class?
 0992  75 06				jne	recv_find_2		;no- don't bother
 0994  57				push	di
 0995  F3/ A6				repe	cmpsb
 0997  5F				pop	di
 0998  74 10				je	recv_find_3		;we've got it!

 099A				recv_find_2:
				;; in_use=0.
 099A  83 C3 18				add	bx,(size per_handle)	;go to the next handle.
 099D  81 FB 033E R			cmp	bx,offset end_handles
 09A1  72 CC				jb	recv_find_1
 09A3  66| FF 06 03E6 R			inc    packets_dropped		;count it as dropped.
				;;	  sti
 09A8  F9				stc
 09A9  C3				ret

 09AA				recv_find_3:
				;; frame_type_len = 0
				;; Class match.
 09AA  89 1E 03C0 R			mov	found_handle,bx 	;remember what our handle was.
 09AE  F8				clc
 09AF  C3				ret


					public	recv_find, recv_found

 09B0				recv_find:
				;called when we want to determine what to do with a received packet.
				;enter with cx = packet length, es:di -> packet type, dl = packet class.
				;exit with es:di = 0 if the packet is not desired, or es:di -> packet buffer
				;  to be filled by the driver.
					assume	ds:code, es:nothing
 09B0  51				push	cx			;preserve packet length.
 09B1  56				push	si			;; preserve descriptor pointer
 09B2  E8 FF87				call	recv_locate		;search for the packet type.
 09B5  5E				pop	si
 09B6  59				pop	cx
 09B7  72 2F				jc	recv_find_5		;we didn't find it -- discard it.

 09B9				recv_found:
				;called to do the first upcall.(Ref. access_type() function )
				;exit with es:di = 0 if the packet is not desired, or es:di -> packet buffer
				;  to be filled by the driver.
 09B9  66| FF 06 03CE R			inc    packets_in
 09BE  66| 01 0E 03D6 R			add    bytes_in, ecx		 ;add up the received bytes.

 09C3  8B 1E 03C0 R			mov	bx,found_handle
 09C7  C4 7F 0B				les	di,[bx].receiver	;remember the receiver upcall.
 09CA  89 3E 03C2 R			mov	receive_ptr.offs,di
 09CE  8C 06 03C4 R			mov	receive_ptr.segm,es
 09D2  F7 06 0216 R 0008		test	flagword,W_OPTION	;did they select the Windows option?
 09D8  74 13				je	recv_find_6		;no, don't check for the upcall.

				; does the receiver signature match whats currently in memory?	if not,
				; jump to fake return
 09DA  56				push	si
 09DB  51				push	cx
 09DC  8D 77 0F				lea	si,[bx].receiver_sig
 09DF  B9 0004				mov	cx,8/2
 09E2  F3/ A7				repe	cmpsw
 09E4  59				pop	cx
 09E5  5E				pop	si
 09E6  74 05				je	recv_find_6

 09E8				recv_find_5:
 09E8  33 FF				xor	di,di			;"return" a null pointer.
 09EA  8E C7				mov	es,di
 09EC  C3				ret

 09ED				recv_find_6:
 09ED  B8 0000				mov	ax,0			;allocate request.
 09F0  F9				stc				;with stc, flags must be an odd number
 09F1  50				push	ax			; save a number that cant be flags
 09F2  9C				pushf				;save flags in case iret used.
 09F3  FF 1E 03C2 R			call	receive_ptr		;ask the client for a buffer.

					; on return, flags should be at top of stack. if an IRET has been used,
					; then 0 will be at the top of the stack
 09F7  5B				pop	bx
 09F8  83 FB 00				cmp	bx,0
 09FB  74 03				je	recv_find_4		;0 is at top of stack
 09FD  83 C4 02				add	sp,2

 0A00				recv_find_4:
 0A00  C3				ret


					public	recv_copy
 0A01				recv_copy:
				;called after we have copied the packet into the buffer.
				;enter with ds:si ->the packet, cx = length of the packet.
				;preserve bx.
					assume	ds:nothing, es:nothing

 0A01  53				push	bx
 0A02  2E: 8B 1E 03C0 R			mov	bx,found_handle

 0A07  B8 0001				mov	ax,1			;store request.
 0A0A  F8				clc				;with clc, flags must be an even number
 0A0B  50				push	ax			; save a number that can't be flags
 0A0C  9C				pushf				;save flags incase iret used.

 0A0D  2E: FF 1E 03C2 R			call	receive_ptr		;ask the client for a buffer.

 0A12  5B				pop	bx
 0A13  83 FB 01				cmp	bx,1			;if this is a 1, IRET was used.
 0A16  74 01				je	recv_copy_1
 0A18  5B				pop	bx
 0A19				recv_copy_1:
 0A19  5B				pop	bx

 0A1A  C3				ret



					public	send_queue

 0A1B				send_queue:

				; Queue an iocb.

				; Enter with es:di -> iocb, interrupts disabled.

				; Destroys ds:si.

					assume	ds:nothing, es:nothing

 0A1B  26: C7 45 0C 0000		mov	es:[di].next.offs,0	; Zero next offset

 0A21  26: C7 45 0E 0000		mov	es:[di].next.segm,0	; Zero next segment

 0A27  2E: 8B 36 03C6 R			mov	si,send_head.offs	; Queue empty?

 0A2C  2E: 0B 36 03C8 R			or	si,send_head.segm

 0A31  75 0C				jnz	sq_notempty		; No

 0A33  2E: 89 3E 03C6 R			mov	send_head.offs,di	; Set head offset

 0A38  2E: 8C 06 03C8 R			mov	send_head.segm,es	; Set head segment

 0A3D  EB 0B				jmp	sq_settail

 0A3F				sq_notempty:				; Queue is not empty

 0A3F  2E: C5 36 03CA R			lds	si,send_tail		; Get tail segment:offset

 0A44  89 7C 0C				mov	ds:[si].next.offs,di	; Set next offset

 0A47  8C 44 0E				mov	ds:[si].next.segm,es	; Set next segment

 0A4A				sq_settail:

 0A4A  2E: 89 3E 03CA R			mov	send_tail.offs,di	; Set tail offset

 0A4F  2E: 8C 06 03CC R			mov	send_tail.segm,es	; Set tail segment

 0A54  C3				ret





					public	send_dequeue

 0A55				send_dequeue:

				; Dequeue an iocb and possibly call its upcall.

				; Enter with device or processor interrupts disabled, ah = return code.

				; Exits with es:di -> iocb; destroys ds:si, ax, bx, cx, dx, bp.

					assume	ds:nothing, es:nothing

 0A55  2E: C4 3E 03C6 R			les	di,send_head		; Get head segment:offset

 0A5A  26: C5 75 0C			lds	si,es:[di].next 	; Get next segment:offset

 0A5E  2E: 89 36 03C6 R			mov	send_head.offs, si	; Set head offset

 0A63  2E: 8C 1E 03C8 R			mov	send_head.segm, ds	; Set head segment

 0A68  26: 80 4D 06 01			or	es:flags[di], DONE	; Mark done

 0A6D  26: 88 65 07			mov	es:ret_code[di], ah	; Set retcode

 0A71  26: F6 45 06 02			test	es:[di].flags,CALLME	; Does he want an upcall?

 0A76  74 17				je	send_dequeue_1		; No.

 0A78  06				push	es			; Push iocb segment

 0A79  57				push	di			;  and offset

 0A7A  F8				clc				; Clear carry.

 0A7B  B8 0001				mov	ax,1			; Push a number that cant be flags.

 0A7E  50				push	ax

 0A7F  9C				pushf				; Save flags in case iret used.

 0A80  26: FF 5D 08			call	es:[di].upcall		; Call the client.

 0A84  58				pop	ax			; Pop first word.

 0A85  83 F8 01				cmp	ax,1			; If this is a 1, IRET was used.

 0A88  74 03				je	send_dequeue_2		; Far return used.

 0A8A  83 C4 02				add	sp,2			; Pop flags.

 0A8D				send_dequeue_2:

 0A8D  5F				pop	di			; Pop iocb segment

 0A8E  07				pop	es			;  and offset

 0A8F				send_dequeue_1:

 0A8F  C3				ret

 0A90				code	ends

					end	start

 
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
.\head.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

add2 . . . . . . . . . . . . . .	Proc
movseg . . . . . . . . . . . . .	Proc
repmov . . . . . . . . . . . . .	Proc
send_peekqueue . . . . . . . . .	Proc
send_queueempty  . . . . . . . .	Proc
to_scrn  . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

bytes  . . . . . . . . . . . . .	 0012
  _DL  . . . . . . . . . . . . .	 000A	     Byte
  _DH  . . . . . . . . . . . . .	 000B	     Byte
  _CL  . . . . . . . . . . . . .	 000C	     Byte
  _CH  . . . . . . . . . . . . .	 000D	     Byte
  _BL  . . . . . . . . . . . . .	 000E	     Byte
  _BH  . . . . . . . . . . . . .	 000F	     Byte
  _AL  . . . . . . . . . . . . .	 0010	     Byte
  _AH  . . . . . . . . . . . . .	 0011	     Byte
iocb . . . . . . . . . . . . . .	 0014
  buffer . . . . . . . . . . . .	 0000	     DWord
  len  . . . . . . . . . . . . .	 0004	     Word
  flags  . . . . . . . . . . . .	 0006	     Byte
  ret_code . . . . . . . . . . .	 0007	     Byte
  upcall . . . . . . . . . . . .	 0008	     DWord
  next . . . . . . . . . . . . .	 000C	     DWord
  resv . . . . . . . . . . . . .	 0010	     Byte
per_handle . . . . . . . . . . .	 0018
  in_use . . . . . . . . . . . .	 0000	     Byte
  packet_type  . . . . . . . . .	 0001	     Byte
  packet_type_len  . . . . . . .	 0009	     Word
  receiver . . . . . . . . . . .	 000B	     DWord
  receiver_sig . . . . . . . . .	 000F	     Byte
  class  . . . . . . . . . . . .	 0017	     Byte
recv_isr_frame . . . . . . . . .	 000C
  recv_isr_ds  . . . . . . . . .	 0000	     Word
  recv_isr_dx  . . . . . . . . .	 0002	     Word
  recv_isr_ax  . . . . . . . . .	 0004	     Word
  recv_isr_ip  . . . . . . . . .	 0006	     Word
  recv_isr_cs  . . . . . . . . .	 0008	     Word
  recv_isr_f . . . . . . . . . .	 000A	     Word
regs . . . . . . . . . . . . . .	 0018
  _ES  . . . . . . . . . . . . .	 0000	     Word
  _DS  . . . . . . . . . . . . .	 0002	     Word
  _BP  . . . . . . . . . . . . .	 0004	     Word
  _DI  . . . . . . . . . . . . .	 0006	     Word
  _SI  . . . . . . . . . . . . .	 0008	     Word
  _DX  . . . . . . . . . . . . .	 000A	     Word
  _CX  . . . . . . . . . . . . .	 000C	     Word
  _BX  . . . . . . . . . . . . .	 000E	     Word
  _AX  . . . . . . . . . . . . .	 0010	     Word
  _IP  . . . . . . . . . . . . .	 0012	     Word
  _CS  . . . . . . . . . . . . .	 0014	     Word
  _F . . . . . . . . . . . . . .	 0016	     Word
segmoffs . . . . . . . . . . . .	 0004
  offs . . . . . . . . . . . . .	 0000	     Word
  segm . . . . . . . . . . . . .	 0002	     Word
table_multicast  . . . . . . . .	 0005
  table_maxnum . . . . . . . . .	 0000	     Word
  table_current  . . . . . . . .	 0002	     Word
  table_multiaddr  . . . . . . .	 0004	     Byte


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_TEXT  . . . . . . . . . . . . .	16 Bit	 0000	  Word	  Public  'CODE'	
_DATA  . . . . . . . . . . . . .	16 Bit	 0000	  Word	  Public  'DATA'	
code . . . . . . . . . . . . . .	16 Bit	 0A90	  Para	  Public  


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . .	Number	 0001h	 
@code  . . . . . . . . . . . . .	Text   	 DGROUP
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP
ARCADDR_LEN  . . . . . . . . . .	Number	 0001h	 
A_OPTION . . . . . . . . . . . .	Number	 0200h	 
AddMulticastAddress  . . . . . .	L Near	 0000	  code	External
BAD_ADDRESS  . . . . . . . . . .	Number	 000Eh	 
BAD_COMMAND  . . . . . . . . . .	Number	 000Bh	 
BAD_HANDLE . . . . . . . . . . .	Number	 0001h	 
BAD_IOCB . . . . . . . . . . . .	Number	 0010h	 
BAD_MODE . . . . . . . . . . . .	Number	 0008h	 
BAD_TYPE . . . . . . . . . . . .	Number	 0005h	 
BLUEBOOK . . . . . . . . . . . .	Number	 0001h	 
B_OPTION . . . . . . . . . . . .	Number	 0200h	 
CALLED_ETOPEN  . . . . . . . . .	Number	 0001h	 
CALLME . . . . . . . . . . . . .	Number	 0002h	 
CANT_RESET . . . . . . . . . . .	Number	 000Fh	 
CANT_SEND  . . . . . . . . . . .	Number	 000Ch	 
CANT_SET . . . . . . . . . . . .	Number	 000Dh	 
CANT_TERMINATE . . . . . . . . .	Number	 0007h	 
CR . . . . . . . . . . . . . . .	Number	 000Dh	 
CY . . . . . . . . . . . . . . .	Number	 0001h	 
DONE . . . . . . . . . . . . . .	Number	 0001h	 
D_OPTION . . . . . . . . . . . .	Number	 0002h	 
EADDR_LEN  . . . . . . . . . . .	Number	 0006h	 
EI . . . . . . . . . . . . . . .	Number	 0200h	 
EPROT_OFF  . . . . . . . . . . .	Number	 000Ch	 
F_OPTION . . . . . . . . . . . .	Number	 0040h	 
GEN_VER  . . . . . . . . . . . .	Text   	 0
GIANT  . . . . . . . . . . . . .	Number	 05EAh	 
HOMEPNA  . . . . . . . . . . . .	Text   	 
HT . . . . . . . . . . . . . . .	Number	 0009h	 
H_OPTION . . . . . . . . . . . .	Number	 0020h	 
IEEE8023 . . . . . . . . . . . .	Number	 000Bh	 
InterruptMain  . . . . . . . . .	L Near	 0000	  code	External
LF . . . . . . . . . . . . . . .	Number	 000Ah	 
MAJ_VER  . . . . . . . . . . . .	Text   	 1
MAX_ADDR_LEN . . . . . . . . . .	Number	 0010h	 
MAX_HANDLE . . . . . . . . . . .	Number	 000Ah	 
MAX_MULTICAST  . . . . . . . . .	Number	 000Eh	 
MAX_P_LEN  . . . . . . . . . . .	Number	 0008h	 
MIN_VER  . . . . . . . . . . . .	Text   	 4
MulticastTable . . . . . . . . .	Byte	 0000	  code	External
NO_CLASS . . . . . . . . . . . .	Number	 0002h	 
NO_ERROR . . . . . . . . . . . .	Number	 0000h	 
NO_MULTICAST . . . . . . . . . .	Number	 0006h	 
NO_NUMBER  . . . . . . . . . . .	Number	 0004h	 
NO_SPACE . . . . . . . . . . . .	Number	 0009h	 
NO_TYPE  . . . . . . . . . . . .	Number	 0003h	 
N_OPTION . . . . . . . . . . . .	Number	 0004h	 
PortPrintMessage . . . . . . . .	L Near	 0000	  code	External
PortUpdateReceiveFilter  . . . .	L Near	 0000	  code	External
RUNT . . . . . . . . . . . . . .	Number	 003Ch	 
Reset_MAC_PHY  . . . . . . . . .	L Near	 0000	  code	External
SINGLE_PORT  . . . . . . . . . .	Text   	 
SW_ONE_PKT . . . . . . . . . . .	Text   	 
SYS_MCA  . . . . . . . . . . . .	Number	 0002h	 
TWO_8259 . . . . . . . . . . . .	Number	 0040h	 
TYPE_INUSE . . . . . . . . . . .	Number	 000Ah	 
T_OPTION . . . . . . . . . . . .	Number	 0400h	 
U_OPTION . . . . . . . . . . . .	Number	 0010h	 
W_OPTION . . . . . . . . . . . .	Number	 0008h	 
XF_OPTION  . . . . . . . . . . .	Number	 0100h	 
XH_OPTION  . . . . . . . . . . .	Number	 0080h	 
access_type_1  . . . . . . . . .	L Near	 05C4	  code	
access_type_2  . . . . . . . . .	L Near	 05D3	  code	
access_type_3  . . . . . . . . .	L Near	 05DF	  code	
access_type_4  . . . . . . . . .	L Near	 05EE	  code	
access_type_5  . . . . . . . . .	L Near	 0620	  code	
access_type_6  . . . . . . . . .	L Near	 062B	  code	
access_type_7  . . . . . . . . .	L Near	 0618	  code	
access_type_8  . . . . . . . . .	L Near	 060C	  code	
access_type_9  . . . . . . . . .	L Near	 05B8	  code	
access_type_bad  . . . . . . . .	L Near	 05B1	  code	
access_type_class  . . . . . . .	L Near	 05A5	  code	
access_type_inuse  . . . . . . .	L Near	 061C	  code	
access_type_number . . . . . . .	L Near	 05AD	  code	
access_type_space  . . . . . . .	L Near	 067A	  code	
access_type_type . . . . . . . .	L Near	 05A9	  code	
address_len  . . . . . . . . . .	Word	 039A	  code	Public
as_send_pkt  . . . . . . . . . .	L Near	 0000	  code	External
bad_command_intercept  . . . . .	L Near	 0000	  code	External
branding_msg . . . . . . . . . .	Byte	 0000	  code	External
bytes_in . . . . . . . . . . . .	DWord	 03D6	  code	Public
bytes_out  . . . . . . . . . . .	DWord	 03DA	  code	Public
count_handles_1  . . . . . . . .	L Near	 0835	  code	
count_handles  . . . . . . . . .	L Near	 0830	  code	
default_handle . . . . . . . . .	L Near	 04C5	  code	
dm9100_version . . . . . . . . .	Number	 0000h	 
dp_endlist . . . . . . . . . . .	L Near	 0723	  code	
dp_getnext . . . . . . . . . . .	L Near	 071A	  code	
dp_loop  . . . . . . . . . . . .	L Near	 06F6	  code	
driver_class . . . . . . . . . .	Byte	 0000	  code	External
driver_function  . . . . . . . .	Byte	 0000	  code	External
driver_name  . . . . . . . . . .	Byte	 0000	  code	External
driver_type  . . . . . . . . . .	Byte	 0000	  code	External
drop_pkt . . . . . . . . . . . .	L Near	 0000	  code	External
end_handles  . . . . . . . . . .	Byte	 033E	  code	
entry_point  . . . . . . . . . .	Byte	 020E	  code	Public
errors_in  . . . . . . . . . . .	DWord	 03DE	  code	Public
errors_out . . . . . . . . . . .	DWord	 03E2	  code	Public
etopen . . . . . . . . . . . . .	L Near	 0000	  code	External
f_access_type  . . . . . . . . .	L Near	 05B5	  code	Public
f_as_send_pkt_1  . . . . . . . .	L Near	 06CA	  code	
f_as_send_pkt_2  . . . . . . . .	L Near	 06E7	  code	
f_as_send_pkt  . . . . . . . . .	L Near	 06BB	  code	
f_bad_command  . . . . . . . . .	L Near	 0484	  code	
f_driver_info_1  . . . . . . . .	L Near	 04EB	  code	
f_driver_info  . . . . . . . . .	L Near	 04A1	  code	
f_drop_pkt . . . . . . . . . . .	L Near	 06EB	  code	
f_get_address  . . . . . . . . .	L Near	 078C	  code	
f_get_multicast_list . . . . . .	L Near	 0564	  code	Public
f_get_parameters_1 . . . . . . .	L Near	 0826	  code	
f_get_parameters . . . . . . . .	L Near	 081B	  code	
f_get_rcv_mode . . . . . . . . .	L Near	 0521	  code	Public
f_get_statistics . . . . . . . .	L Near	 0598	  code	
f_not_implemented  . . . . . . .	L Near	 049D	  code	
f_release_type_1 . . . . . . . .	L Near	 068C	  code	
f_release_type . . . . . . . . .	L Near	 067E	  code	Public
f_reset_interface  . . . . . . .	L Near	 07F3	  code	
f_send_pkt_2 . . . . . . . . . .	L Near	 06A0	  code	
f_send_pkt_3 . . . . . . . . . .	L Near	 06B6	  code	
f_send_pkt . . . . . . . . . . .	L Near	 068E	  code	Public
f_set_address_err  . . . . . . .	L Near	 07E7	  code	
f_set_address_inuse  . . . . . .	L Near	 07DF	  code	
f_set_address_too_long . . . . .	L Near	 07E3	  code	
f_set_address  . . . . . . . . .	L Near	 07A4	  code	
f_set_multicast_list_1 . . . . .	L Near	 0555	  code	
f_set_multicast_list_2 . . . . .	L Near	 055C	  code	
f_set_multicast_list_3 . . . . .	L Near	 0560	  code	
f_set_multicast_list . . . . . .	L Near	 052C	  code	Public
f_set_rcv_mode_1 . . . . . . . .	L Near	 051D	  code	
f_set_rcv_mode_4 . . . . . . . .	L Near	 051B	  code	
f_set_rcv_mode . . . . . . . . .	L Near	 04ED	  code	Public
f_stop_2 . . . . . . . . . . . .	L Near	 080D	  code	
f_stop . . . . . . . . . . . . .	L Near	 080A	  code	
f_terminate_3  . . . . . . . . .	L Near	 0756	  code	
f_terminate_4  . . . . . . . . .	L Near	 0788	  code	
f_terminate_no_irq . . . . . . .	L Near	 075E	  code	
f_terminate_no_mask  . . . . . .	L Near	 0749	  code	
f_terminate_no_timer . . . . . .	L Near	 0770	  code	
f_terminate  . . . . . . . . . .	L Near	 0728	  code	
flagword . . . . . . . . . . . .	Word	 0216	  code	Public
found_handle . . . . . . . . . .	Word	 03C0	  code	
free_handle  . . . . . . . . . .	Word	 03BE	  code	
functions  . . . . . . . . . . .	Word	 021A	  code	
get_address_space  . . . . . . .	L Near	 07A0	  code	
gmt_return . . . . . . . . . . .	L Near	 0586	  code	
got_handle . . . . . . . . . . .	L Near	 04CB	  code	
handles  . . . . . . . . . . . .	per_handle  024E     code	
int_no . . . . . . . . . . . . .	Byte	 0000	  code	External
is_186 . . . . . . . . . . . . .	Byte	 0213	  code	Public
is_286 . . . . . . . . . . . . .	Byte	 0214	  code	Public
is_386 . . . . . . . . . . . . .	Byte	 0215	  code	Public
majver . . . . . . . . . . . . .	Number	 0001h	 
mask_not_irq2  . . . . . . . . .	L Near	 08E9	  code	
maskint_1  . . . . . . . . . . .	L Near	 08FB	  code	
maskint  . . . . . . . . . . . .	L Near	 08D9	  code	Public
multi_bit_chk  . . . . . . . . .	L Near	 053D	  code	
multicast_addrs  . . . . . . . .	Byte	 0346	  code	Public
multicast_broad  . . . . . . . .	Byte	 0340	  code	Public
multicast_count  . . . . . . . .	Word	 033E	  code	Public
multicast_move . . . . . . . . .	L Near	 057E	  code	
multihandle  . . . . . . . . . .	L Near	 0806	  code	
my_address . . . . . . . . . . .	Byte	 03AC	  code	Public
not_n_op . . . . . . . . . . . .	L Near	 096C	  code	
original_mask  . . . . . . . . .	Byte	 0218	  code	
our_isr_0  . . . . . . . . . . .	L Near	 0442	  code	
our_isr_cont . . . . . . . . . .	L Near	 045E	  code	
our_isr_error  . . . . . . . . .	L Near	 0479	  code	
our_isr_no_init  . . . . . . . .	L Near	 042E	  code	
our_isr_open . . . . . . . . . .	L Near	 0406	  code	
our_isr_return . . . . . . . . .	L Near	 046F	  code	
our_isr  . . . . . . . . . . . .	L Near	 03FA	  code	Public
our_stack  . . . . . . . . . . .	Byte	 020E	  code	Public
packets_dropped  . . . . . . . .	DWord	 03E6	  code	
packets_in . . . . . . . . . . .	DWord	 03CE	  code	
packets_out  . . . . . . . . . .	DWord	 03D2	  code	Public
parameter_list . . . . . . . . .	Byte	 0000	  code	External
phd_dioa . . . . . . . . . . . .	Byte	 0080	  code	Public
phd_environ  . . . . . . . . . .	Word	 002C	  code	Public
rcv_mode_num . . . . . . . . . .	Word	 03BC	  code	Public
rcv_modes  . . . . . . . . . . .	Word	 0000	  code	External
re_enable_interrupts_1 . . . . .	L Near	 049C	  code	
re_enable_interrupts . . . . . .	L Near	 0494	  code	Public
receive_ptr  . . . . . . . . . .	DWord	 03C2	  code	
recv_copy_1  . . . . . . . . . .	L Near	 0A19	  code	
recv_copy  . . . . . . . . . . .	L Near	 0A01	  code	Public
recv_exiting_addr  . . . . . . .	DWord	 08A6	  code	
recv_exiting_exit  . . . . . . .	L Near	 08CA	  code	Public
recv_exiting_flag  . . . . . . .	Byte	 08A5	  code	
recv_find_1  . . . . . . . . . .	L Near	 096F	  code	
recv_find_2  . . . . . . . . . .	L Near	 099A	  code	
recv_find_3  . . . . . . . . . .	L Near	 09AA	  code	
recv_find_4  . . . . . . . . . .	L Near	 0A00	  code	
recv_find_5  . . . . . . . . . .	L Near	 09E8	  code	
recv_find_6  . . . . . . . . . .	L Near	 09ED	  code	
recv_find_7  . . . . . . . . . .	L Near	 0987	  code	
recv_find  . . . . . . . . . . .	L Near	 09B0	  code	Public
recv_found . . . . . . . . . . .	L Near	 09B9	  code	Public
recv_locate  . . . . . . . . . .	L Near	 093C	  code	Public
recv_not_802_3 . . . . . . . . .	L Near	 095B	  code	
recv_not_8137  . . . . . . . . .	L Near	 096C	  code	
reset_bad_handle . . . . . . . .	L Near	 0805	  code	
rom_address  . . . . . . . . . .	Byte	 039C	  code	Public
savespss . . . . . . . . . . . .	DWord	 03EA	  code	
savesp . . . . . . . . . . . . .	Word	 03EA	  code	
savess . . . . . . . . . . . . .	Word	 03EC	  code	
schedule_exiting_1 . . . . . . .	L Near	 08C9	  code	
schedule_exiting . . . . . . . .	L Near	 08AA	  code	Public
send_dequeue_1 . . . . . . . . .	L Near	 0A8F	  code	
send_dequeue_2 . . . . . . . . .	L Near	 0A8D	  code	
send_dequeue . . . . . . . . . .	L Near	 0A55	  code	Public
send_head  . . . . . . . . . . .	DWord	 03C6	  code	Public
send_pkt . . . . . . . . . . . .	L Near	 0000	  code	External
send_queue . . . . . . . . . . .	L Near	 0A1B	  code	Public
send_tail  . . . . . . . . . . .	DWord	 03CA	  code	Public
set_isr_no_irq . . . . . . . . .	L Near	 08A4	  code	
set_isr_no_timer . . . . . . . .	L Near	 089B	  code	
set_recv_isr_1 . . . . . . . . .	L Near	 086E	  code	
set_recv_isr . . . . . . . . . .	L Near	 085D	  code	Public
sq_notempty  . . . . . . . . . .	L Near	 0A3F	  code	
sq_settail . . . . . . . . . . .	L Near	 0A4A	  code	
start_1  . . . . . . . . . . . .	L Near	 0000	  code	External
start  . . . . . . . . . . . . .	L Near	 0100	  code	
statistics_list  . . . . . . . .	DWord	 03CE	  code	
sys_features . . . . . . . . . .	Byte	 0212	  code	Public
terminate  . . . . . . . . . . .	L Near	 0000	  code	External
their_isr  . . . . . . . . . . .	DWord	 03F6	  code	Public
their_recv_isr . . . . . . . . .	DWord	 03EE	  code	
their_timer  . . . . . . . . . .	DWord	 03F2	  code	Public
timer_isr  . . . . . . . . . . .	L Near	 0000	  code	External
unmask_not_irq2  . . . . . . . .	L Near	 0920	  code	
unmask_ret . . . . . . . . . . .	L Near	 093B	  code	
unmaskint  . . . . . . . . . . .	L Near	 08FC	  code	Public
verify_handle_bad  . . . . . . .	L Near	 0856	  code	
verify_handle  . . . . . . . . .	L Near	 0841	  code	
version  . . . . . . . . . . . .	Number	 0004h	 
xmit . . . . . . . . . . . . . .	L Near	 0000	  code	External

	   0 Warnings
	   0 Errors
