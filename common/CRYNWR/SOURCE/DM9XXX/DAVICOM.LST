Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Page 1 - 1


				;*****************************************************************************
				;* Name : DAVICOM.ASM
				;*
				;* All rights reserved by DAVICOM, 1996
				;*
				;* Description :
				;*
				;* Functions :
				;*
				;* Author : Spenser Tsai
				;*
				;* Date : 05/17/96'
				;*
				;
				; Maintainers:
				;
				; John H.T. Ho		htho
				;
				;
				; Revision History:
				;
				; Date	     Modfier.	Modification Descriptions
				; ---------- ---------- ------------------------------------------
				; 2000.1.31	htho	background debug
				;*
				;*****************************************************************************
				.model tiny
				.386

					include defs.asm
			      C ;;*******************************************************
			      C ;* Program name : DEFS.ASM
			      C ;* Modified By : Spenser Tsai
			      C ;* Date : 10/04/97' (DAVICOM)
			      C ;********************************************************
 = 0001			      C majver		equ	MAJ_VER 	;version number of the infrastructure.
			      C 
 = 0004			      C version 	equ	MIN_VER 	;Major Version number of the program
			      C 
 = 0000			      C dm9100_version	equ	GEN_VER 	;version number of the generic 9100 driver.
			      C 
 = 0010			      C MAX_ADDR_LEN	equ	16		;maximum number of bytes in our address.
			      C 
 = 000A			      C MAX_HANDLE	equ	10		;maximum number of handles.
			      C 
 = 0008			      C MAX_P_LEN	equ	8		;maximum type length
			      C 
			      C ;;MAX_MULTICAST   equ	  8		  ;maximum number of multicast addresses.
 = 000E			      C MAX_MULTICAST	equ	14		 ;maximum number of multicast addresses.
			      C 
			      C ;  Copyright, 1988-1992, Russell Nelson, Crynwr Software
			      C 
			      C ;   This program is free software; you can redistribute it and/or modify
			      C ;   it under the terms of the GNU General Public License as published by
			      C ;   the Free Software Foundation, version 1.
			      C ;
			      C ;   This program is distributed in the hope that it will be useful,
			      C ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
			      C ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
			      C ;   GNU General Public License for more details.
			      C ;
			      C ;   You should have received a copy of the GNU General Public License
			      C ;   along with this program; if not, write to the Free Software
			      C ;   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
			      C 
 = 0009			      C HT	equ	09h
 = 000D			      C CR	equ	0dh
 = 000A			      C LF	equ	0ah
			      C 
			      C ;
			      C ;  Packet Driver Error numbers
 = 0000			      C NO_ERROR	equ	0		;no error at all.
			      C   ifndef SMCINC
 = 0001			      C BAD_HANDLE	equ	1		;invalid handle number
			      C   endif
 = 0002			      C NO_CLASS	equ	2		;no interfaces of specified class found
 = 0003			      C NO_TYPE 	equ	3		;no interfaces of specified type found
 = 0004			      C NO_NUMBER	equ	4		;no interfaces of specified number found
			      C   ifndef SMCINC
 = 0005			      C BAD_TYPE	equ	5		;bad packet type specified
			      C   endif
 = 0006			      C NO_MULTICAST	equ	6		;this interface does not support
			      C 					;multicast
 = 0007			      C CANT_TERMINATE	equ	7		;this packet driver cannot terminate
 = 0008			      C BAD_MODE	equ	8		;an invalid receiver mode was specified
 = 0009			      C NO_SPACE	equ	9		;operation failed because of
			      C 					;insufficient space
 = 000A			      C TYPE_INUSE	equ	10		;the type had previously been accessed,
			      C 					;and not released.
 = 000B			      C BAD_COMMAND	equ	11		;the command was out of range, or not
			      C 					;implemented
 = 000C			      C CANT_SEND	equ	12		;the packet couldn't be sent (usually
			      C 					;hardware error)
 = 000D			      C CANT_SET	equ	13		;hardware address couldn't be changed
			      C 					;(more than 1 handle open)
 = 000E			      C BAD_ADDRESS	equ	14		;hardware address has bad length or
			      C 					;format
 = 000F			      C CANT_RESET	equ	15		;Couldn't reset interface (more than
			      C 					;1 handle open).
 = 0010			      C BAD_IOCB	equ	16		;an invalid iocb was specified
			      C 
			      C ;a few useful Ethernet definitions.
 = 003C			      C RUNT		equ	60		;smallest legal size packet, no fcs
 = 05EA			      C GIANT		equ	1514		;largest legal size packet, no fcs
 = 0006			      C EADDR_LEN	equ	6		;Ethernet address length.
 = 0001			      C ARCADDR_LEN	equ	1
			      C 
 = 0001			      C BLUEBOOK	equ	1
 = 000B			      C IEEE8023	equ	11
			      C 
			      C 
			      C ;this macro does a "rep movsb" with a static count.
			      C repmov	macro	count
			      C 	rept	(count) / 2
			      C 	movsw
			      C 	endm
			      C 	rept	(count) MOD 2
			      C 	movsb
			      C 	endm
			      C 	endm
			      C 
			      C ;moves a segment register into another segment register.
			      C movseg	macro	to, from
			      C 	push	from
			      C 	pop	to
			      C 	endm
			      C 
			      C ;add a word to a dword.
			      C add2	macro	n,a			; inc a 32 bit integer
			      C 	add	n.offs,a		;increment the low word
			      C 	adc	n.segm,0		;increment the high word
			      C 	endm
			      C 
			      C ;this macro writes the given character to the given row and column on
			      C ;  an CGA.
			      C to_scrn macro	r, c, ch
			      C 	local	again
			      C 	push	bx
			      C 	push	es
			      C 	mov	bx,0b800h
			      C 	mov	es,bx
			      C 	mov	bx,es:[r*160+c*2]
			      C again:
			      C 	inc	bh
			      C 	and	bh,07h
			      C 	je	again			;; don't use black.
			      C 	mov	bl,ch
			      C 	mov	es:[r*160+c*2],bx
			      C 	pop	es
			      C 	pop	bx
			      C 	endm
			      C 
			      C 
			      C 
 0004			      C segmoffs	struc			; defines offs as 0, segm as 2
 0000  0000		      C offs		dw	?
 0002  0000		      C segm		dw	?
			      C segmoffs	ends
			      C 
 = 0001			      C CY	equ	0001h
 = 0200			      C EI	equ	0200h
			      C 
 0014			      C iocb		struc			; as_send_pkt structure
 0000  00000000		      C   buffer	  dd	  ?		  ; Pointer to the buffer
 0004  0000		      C   len		  dw	  ?		  ; Its length
 0006  00		      C   flags 	  db	  ?		  ; Some flags
 0007  00		      C   ret_code	  db	  ?		  ; Completion code
 0008  00000000		      C   upcall	  dd	  ?		  ; I/O completion upcall
 000C  00000000		      C   next		  dd	  ?		  ; Private next pointer (queue)
 0010  0004 [		      C   resv		  db	  4 dup (?)	  ; Unused private data
        00
       ]
			      C iocb		ends
			      C 
 = 0001			      C DONE	equ	1		; I/O complete flag
 = 0002			      C CALLME	equ	2		; Please upcall me flag
			      C 
			      C 
			      C send_queueempty macro
			      C ; Check if send queue is empty.
			      C ; Enter with interrupts disabled.
			      C ; Exit with zr (zero) if empty, nz (not zero) if not.
			      C ; Destroys ax.
			      C 	mov ax, word ptr send_head	; Queue empty?
			      C 	or ax,	word ptr send_head+2
			      C 	endm
			      C 
			      C send_peekqueue	macro
			      C ; Peek into the queue and get the next entry.
			      C ; Enter with interrupts disabled.
			      C ; Exit with es:di -> iocb.
			      C 	les di, send_head	; Get head segment:offset
			      C 	endm
			      C 
			      C ; Bits in sys_features
 = 0002			      C SYS_MCA equ	02		; a micro channel computer
 = 0040			      C TWO_8259	equ	40h		; 2nd 8259 exists
			      C 
			      C ; Bits in flagbyte
 = 0001			      C CALLED_ETOPEN	equ	1		; have called etopen
 = 0002			      C D_OPTION	equ	2		; delayed initialization
 = 0004			      C N_OPTION	equ	4		; Novell protocol conversion
 = 0008			      C W_OPTION	equ	8		; Windows upcall checking.
 = 0010			      C U_OPTION	equ	10h		; Terminate the driver.
			      C ;;-+
			      C ;;S_OPTION	  EQU	  20h		  ; 10Mb Speed
			      C ;;F_OPTION	  EQU	  40h		  ; Full Duplex
			      C ;;SF_OPTION	  EQU	  60h		  ; Selected speed & mode
			      C ;;XS_OPTION	  EQU	  80h		  ; 100Mb Speed
			      C ;;A_OPTION	  EQU	  100h		  ; Auto-Negotination & Full-Duplex
			      C ;;AF_OPTION	  EQU	  140h		  ; Full Duplex
 = 0020			      C H_OPTION	EQU	20h		; 10Mb Half Duplex
 = 0040			      C F_OPTION	EQU	40h		; 10Mb Full Duplex
 = 0080			      C XH_OPTION	EQU	80h		; 100Mb Half Duplex
 = 0100			      C XF_OPTION	EQU	100h		; 100Mb Full Duplex
 = 0200			      C A_OPTION	EQU	200h		; Auto-Negotiation
 = 0400			      C T_OPTION	EQU	400h		; HomePNA
			      C ;;-+
 = 0200			      C B_OPTION	EQU	200h		; BNC
			      C 
 0005			      C table_multicast       struc
 0000  0000		      C   table_maxnum	    dw	    0	    ; max number of multicast addresses
 0002  0000		      C   table_current     dw	    0	    ; current number of multicast addresses
 0004  00		      C   table_multiaddr   db	    0	    ; 16 byte sets of multicast addresses
			      C table_multicast       ends
			      C  
			      C 

 0000				code	segment para public
					assume	cs:code, ds:code
				;;++, 2000.1.31, hu-tiong
				;IFDEF	 DEBUGDOS
				include debug.inc
			      C IFDEF	DEBUGDOS
			      C ENDIF
			      C 
			      C ;-- Cloor Attribute Definitions
			      C ;------------------------------------------------------------------------
 = 0000			      C BLACK		EQU	0		; dark colors
 = 0001			      C BLUE		EQU	1
 = 0002			      C GREEN		EQU	2
 = 0003			      C CYAN		EQU	3
 = 0004			      C RED		EQU	4
 = 0005			      C MAGENTA 	EQU	5
 = 0006			      C BROWN		EQU	6
 = 0007			      C DARKGRAY	EQU	7
 = 0008			      C LIGHTGRAY	EQU	8		; light colors
 = 0009			      C LIGHTBLUE	EQU	9
 = 000A			      C LIGHTGREEN	EQU	10
 = 000B			      C LIGHTCYAN	EQU	11
 = 000C			      C LIGHTRED	EQU	12
 = 000D			      C LIGHTMAGENTA	EQU	13
 = 000E			      C YELLOW		EQU	14
 = 000F			      C WHITE		EQU	15
			      C 
			      C ;-- Macro Definitions
			      C ;------------------------------------------------------------------------
			      C BRUSH_CHAR	macro	ch
			      C IFDEF	DEBUGDOS
			      C 	push	ax
			      C 	mov	al, ch
			      C 	call	b_char
			      C 	pop	ax
			      C ENDIF
			      C 	endm
			      C 
			      C BRUSH_BYTE	macro	bdata
			      C IFDEF	DEBUGDOS
			      C 	push	ax
			      C 	mov	al, bdata
			      C 	call	b_byte
			      C 	pop	ax
			      C ENDIF
			      C 	endm
			      C 
			      C DISP_CHAR	macro	ch, attr, x, y
			      C IFDEF	DEBUGDOS
			      C 	push	ax
			      C 	push	bx
			      C 	push	dx
			      C 
			      C 	mov	dl, x
			      C 	mov	dh, y
			      C 	mov	bh, attr
			      C 	mov	al, ch
			      C 	call	d_char
			      C 
			      C 	pop	dx
			      C 	pop	bx
			      C 	pop	ax
			      C ENDIF
			      C 	endm
			      C 
			      C DISP_BYTE	macro	bdata, attr, x, y
			      C IFDEF	DEBUGDOS
			      C 	push	ax
			      C 	push	bx
			      C 	push	dx
			      C 
			      C 	mov	dl, x
			      C 	mov	dh, y
			      C 	mov	bh, attr
			      C 	mov	al, bdata
			      C 	call	d_byte
			      C 
			      C 	pop	dx
			      C 	pop	bx
			      C 	pop	ax
			      C ENDIF
			      C 	endm
			      C 
			      C  
			      C 
				;ENDIF	 ;-- DEBUGDOS
				;;++

				;*****************************************************************************
				;
				;	UM9008 controller board offsets
				;	IO port definition (BASE in io_addr)
				;*****************************************************************************
 = 0010				NE_DATAPORT	EQU	10h		; UM9008 Port Window.
 = 001F				NE_RESET	EQU	1fh		; Issue a read for reset
 = 0000				EN_OFF		equ	0h

				;;	  include 9100.inc

				; Shared memory management parameters

 = 0040				SM_TSTART_PG	equ	040h	; First page of TX buffer
 = 0046				SM_RSTART_PG	equ	046h	; Starting page of RX ring
 = 0080				SM_RSTOP_PG	equ	080h	; Last page +1 of RX ring

				pause_	macro
				;	jmp	$+2
				;
				; The reason for the pause_ macro is to establish a minimum time between
				; accesses to the card hardware. The assumption is that the fetch and execution
				; of the jmp $+2 instruction will provide this time. In a fast cache machine
				; this may be a false assumption. In a fast cache machine, there may be
				; NO REAL TIME DIFFERENCE between the two I/O instruction streams below:
				;
				;	in	al,dx		in	al,dx
				;	jmp	$+2
				;	in	al,dx		in	al,dx
				;
				; To establish a minimum delay, an I/O instruction must be used. A good rule of
				; thumb is that ISA I/O instructions take ~1.0 microseconds and MCA I/O
				; instructions take ~0.5 microseconds. Reading the NMI Status Register (0x61)
				; is a good way to pause on all machines.
				;
				; The National 8390 Chip (NIC) requires 4 bus clocks between successive
				; chip selects (National DP8390 Data Sheet Addendum, June 1990 -- it took them
				; long enough to figure this out and tell everyone) or the NIC behaves badly.
				; Therefor one I/O instruction should be inserted between each successive
				; NIC I/O instruction that could occur 'back - to - back' on a fast cache
				; machine.
				;   - gft - 910529
				;
					push	ax
					in	al, 61h
					pop	ax
				;
				endm

				reset_8390	macro
					loadport
					setport NE_RESET
					in	al,dx
					longpause
					out	dx,al		; should set command 21, 80

					endm

				terminate_board macro
					endm

					public	int_no, io_addr
 0000 02 00 00 00		int_no		db	2,0,0,0 	;must be four bytes long for get_number.
 0004 6100 0000			io_addr 	dw	6100h,0 	; I/O address for card (jumpers)

					public	driver_class, driver_type, driver_name, driver_function, parameter_list
 0008 01 0B 00			driver_class	db	BLUEBOOK, IEEE8023, 0		;from the packet spec
 000B FFFF			driver_type	dw	0FFFFh		    ;from the packet spec
 000D 44 4D 39 50 4B 54		driver_name	db	'DM9PKT$',0      ;name of the driver.
       24 00
 0015 02			driver_function db	2
 0016				parameter_list	label	byte
 0016  01				db	1	;major rev of packet driver
 0017  09				db	9	;minor rev of packet driver
 0018  0E				db	14	;length of parameter list
 0019  06				db	EADDR_LEN	;length of MAC-layer address
 001A  05EA				dw	GIANT	;MTU, including MAC headers
 001C  0054				dw	MAX_MULTICAST * EADDR_LEN	;buffer size of multicast addrs
 001E  0000				dw	0	;(# of back-to-back MTU rcvs) - 1
 0020  0000				dw	0	;(# of successive xmits) - 1
 0022 0000			int_num dw	0	;Interrupt # to hook for post-EOI
							;processing, 0 == none,

					extrn	is_186: byte		;=0 if 808[68], =1 if 80[123]86.

				;
				;	Block input routine
				;	CX = byte count, es:di = buffer location, ax = buffer address

					public	block_input
 0024				block_input:
				.386
 0024  66| 50				push	eax
 0026  53				push	bx
 0027  52				push	dx		;; test

 0028  8B D9				mov	bx, cx
 002A  0E				push	cs
 002B  1F				pop	ds
 002C  8B F0				mov	si, ax
 002E  C1 E9 02				shr	cx, 2
 0031				blockin_loop:
 0031  66| A5				movsd
 0033  E2 FC				loop	blockin_loop
 0035  83 E3 03				and	bx, 03h
 0038  83 FB 00				cmp    bx, 0
 003B  74 05				je	blockin_exit
 003D  8B CB				mov	cx, bx
 003F				blockin_ext_loop:
 003F  A4				movsb
 0040  E2 FD				loop	blockin_ext_loop
 0042				blockin_exit:
				;;	  mov	  dl, 0 	 ;; test
				;;	  mov	  bx, ax
				;;	  mov	  eax, [bx+38]
				;;	  cli
				;;	  call	  printcur
				;;	  sti
 0042  5A				pop	dx
 0043  5B	pop	bx
 0044  66| 58				pop	eax
 0046  C3				ret

					include Printcur.asm
			      C ;; Data : DWORD -> EAX, DL -> Column
			      C         public pcursor, pcol
 0047 00		      C pcursor         DB      0
 0048 00		      C pcol            DB      0
			      C 
			      C         PUBLIC  Printcur
 0049			      C Printcur        PROC
			      C ;;        cmp     bl, 3
			      C ;;        jmp     dwout
			      C ;;        cmp     bl, 2
			      C ;;        jmp     wout
			      C ;;        cmp     bl, 1
			      C ;;        jmp     bout
 0049  88 16 0048 R	      C mov     pcol, dl
 004D  C6 06 0047 R 41	      C mov     pcursor, 65
			      C 
			      C ;;        public  dwout, wout, bout, digitout
			      C 
			      C ;; Data : DWORD -> DX:AX, WORD -> AX, BYTE -> AL
 0052			      C dwoutX:
 0052  66| 8B D0	      C         mov     edx, eax        ;; DX:AX = EAX
 0055  66| C1 EA 10	      C         shr     edx, 16
			      C 
 0059  B1 30		      C         mov     cl,'0'                  ;prepare to eliminate leading zeroes.
 005B  92		      C         xchg    ax,dx                   ;just output 32 bits in hex.
 005C  E8 0001		      C         call    woutX                 ;output dx.
 005F  92		      C         xchg    ax,dx
			      C 
 0060			      C woutX:
 0060  50		      C         push    ax
 0061  8A C4		      C         mov     al,ah
 0063  E8 0001		      C         call    boutX
 0066  58		      C         pop     ax
			      C 
 0067			      C boutX:
 0067  8A E0		      C         mov     ah,al
 0069  D0 E8		      C         shr     al,1
 006B  D0 E8		      C         shr     al,1
 006D  D0 E8		      C         shr     al,1
 006F  D0 E8		      C         shr     al,1
 0071  E8 0002		      C         call    digitoutX
 0074  8A C4		      C         mov     al,ah
			      C 
 0076			      C digitoutX:
 0076  24 0F		      C         and     al,0fh
 0078  04 90		      C         add     al,90h  ;binary digit to ascii hex digit.
 007A  27		      C         daa
 007B  14 40		      C         adc     al,40h
 007D  27		      C         daa
 007E  38 C8		      C         cmp     al,cl                   ;leading zero?
 0080  74 05		      C         je      digitout_1X
 0082  B1 FF		      C         mov     cl,-1                   ;no more leading zeros.
 0084  E8 0001		      C         call    charoutX
			      C 
 0087			      C digitout_1X:
 0087  C3		      C         ret
 0088			      C Printcur        ENDP
			      C 
			      C ;;        public  charout
 0088			      C charoutX PROC    NEAR
			      C ;;charout:
 0088  50		      C         push    ax                      ;print the char in al.
 0089  52		      C         push    dx
			      C ;;        mov     ah, 0Eh
			      C ;;        mov     bx, 0Fh         ;; Set video attributes for INT 10 call
			      C 
 008A  B4 02		      C         mov     ah, 02h                 ;; Set cursor
 008C  BB 000F		      C         mov     bx, 0Fh
 008F  8A 16 0047 R	      C         mov     dl, pcursor
 0093  8A 36 0048 R	      C         mov     dh, pcol
 0097  CD 10		      C         int     10h
			      C 
 0099  B4 0A		      C         mov     ah, 0Ah
			      C ;;      mov     bx, 0fh
 009B  B9 0001		      C         mov     cx, 1
 009E  CD 10		      C         int     10h             ;; call BIOS INT 10 to print to console
 00A0  FE 06 0047 R	      C         inc     pcursor
			      C 
 00A4  5A		      C         pop     dx
 00A5  58		      C         pop     ax
 00A6  C3		      C         ret
 00A7			      C charoutX         ENDP
			      C 
 00A7			      C printcrlfX               PROC
 00A7			      C linereturnX:
 00A7  50		      C         push    ax
 00A8  B0 0A		      C         mov     al, 0Ah         ;; LF
 00AA  E8 0047		      C         call    charout
 00AD  B0 0D		      C         mov     al, 0Dh         ;; CR
 00AF  E8 0042		      C         call    charout
 00B2  59		      C         pop     cx
 00B3  C3		      C         ret
 00B4			      C printcrlfX       ENDP
			      C 
					include Printdig.asm
			      C 
			      C 
			      C 
			      C ;; Data : DWORD -> EAX, WORD -> AX, BYTE -> AL
			      C ;; Mode : BL = 1 -> byteout, 2 -> wordout, 3 -> dwordout
			      C         PUBLIC  Printdig
 00B4			      C Printdig        PROC    NEAR
 00B4  80 FB 03		      C         cmp     bl, 3
 00B7  74 0A		      C         je     dwout
 00B9  80 FB 02		      C         cmp     bl, 2
 00BC  74 13		      C         je     wout
 00BE  80 FB 01		      C         cmp     bl, 1
 00C1  74 15		      C         je     bout
			      C 
			      C         public  dwout, wout, bout, digitout
			      C 
			      C ;; Data : DWORD -> DX:AX, WORD -> AX, BYTE -> AL
 00C3			      C dwout:
 00C3  66| 8B D0	      C         mov     edx, eax        ;; DX:AX = EAX
 00C6  66| C1 EA 10	      C         shr     edx, 16
			      C 
 00CA  B1 30		      C         mov     cl,'0'                  ;prepare to eliminate leading zeroes.
 00CC  92		      C         xchg    ax,dx                   ;just output 32 bits in hex.
 00CD  E8 0001		      C         call    wout                    ;output dx.
 00D0  92		      C         xchg    ax,dx
			      C 
 00D1			      C wout:
 00D1  50		      C         push    ax
 00D2  8A C4		      C         mov     al,ah
 00D4  E8 0001		      C         call    bout
 00D7  58		      C         pop     ax
			      C 
 00D8			      C bout:
 00D8  8A E0		      C         mov     ah,al
 00DA  C0 E8 04		      C         shr     al, 4
 00DD  E8 0002		      C         call    digitout
 00E0  8A C4		      C         mov     al,ah
			      C 
 00E2			      C digitout:
 00E2  24 0F		      C         and     al,0fh
 00E4  04 90		      C         add     al,90h  ;binary digit to ascii hex digit.
 00E6  27		      C         daa
 00E7  14 40		      C         adc     al,40h
 00E9  27		      C         daa
 00EA  38 C8		      C         cmp     al,cl                   ;leading zero?
 00EC  74 05		      C         je      digitout_1
 00EE  B1 FF		      C         mov     cl,-1                   ;no more leading zeros.
 00F0  E8 0001		      C         call     charout
 00F3			      C digitout_1:
 00F3  C3		      C         ret
			      C 
 00F4			      C Printdig        ENDP
			      C 
			      C         public  charout
 00F4			      C charout PROC    NEAR
			      C ;;charout:
 00F4  50		      C         push    ax                      ;print the char in al.
 00F5  52		      C         push    dx
 00F6  B4 0E		      C         mov     ah, 0Eh
 00F8  BB 000F		      C         mov     bx, 0Fh         ;; Set video attributes for INT 10 call
 00FB  CD 10		      C         int     10h             ;; call BIOS INT 10 to print to console
 00FD  5A		      C         pop     dx
 00FE  58		      C         pop     ax
 00FF  C3		      C         ret
 0100			      C charout         ENDP
			      C 
 0100			      C printcrlf       PROC
 0100			      C linereturn:
 0100  50		      C         push    ax
 0101  B0 0A		      C         mov     al, 0Ah         ;; LF
 0103  E8 FFEE		      C         call    charout
 0106  B0 0D		      C         mov     al, 0Dh         ;; CR
 0108  E8 FFE9		      C         call    charout
 010B  59		      C         pop     cx
 010C  C3		      C         ret
 010D			      C printcrlf       ENDP
			      C 
			      C ;IFDEF OK
			      C ;; Data : WORD -> CX
			      C         PUBLIC  Printwdig
 010D			      C Printwdig        PROC    NEAR
			      C 
 010D  50		      C         push    ax
 010E  8A C4		      C         mov     al,ah
 0110  E8 0001		      C         call    wbout
 0113  58		      C         pop     ax
			      C 
 0114			      C wbout:
 0114  8A E0		      C         mov     ah,al
 0116  C0 E8 04		      C         shr     al, 4
 0119  E8 0002		      C         call    wdigitout
 011C  8A C4		      C         mov     al,ah
			      C 
 011E			      C wdigitout:
 011E  24 0F		      C         and     al,0fh
 0120  04 90		      C         add     al,90h  ;binary digit to ascii hex digit.
 0122  27		      C         daa
 0123  14 40		      C         adc     al,40h
 0125  27		      C         daa
 0126  38 C8		      C         cmp     al,cl                   ;leading zero?
 0128  74 14		      C         je      wdigitout_1
 012A  B1 FF		      C         mov     cl,-1                   ;no more leading zeros.
			      C 
 012C  53		      C         push    bx
 012D  06		      C         push    es
 012E  BB B800		      C         mov     bx, 0b800h
 0131  8E C3		      C         mov     es, bx
 0133  26: 88 04	      C         mov     byte ptr es:[si], al
 0136  46		      C         inc     si
 0137  26: C6 04 0C	      C         mov     byte ptr es:[si], 12
 013B  46		      C         inc     si
 013C  07		      C         pop     es
 013D  5B		      C         pop     bx
			      C 
 013E			      C wdigitout_1:
 013E  C3		      C         ret
 013F			      C Printwdig        ENDP
			      C ;ENDIF   ;;OK
			      C 
					include 9100.asm
			      C ;*****************************************************************************
			      C ;* Name : 9100.ASM
			      C ;*
			      C ;* All rights reserved by DAVICOM, 1996
			      C ;*
			      C ;* Description : Initializes card & setup receive mode.
			      C ;*	Include file :
			      C ;*		timeout.asm
			      C ;*		xmt.asm
			      C ;*		rcv.asm
			      C ;*		srom.asm
			      C ;*		port.asm
			      C ;*		rtdata.asm
			      C ;*		isr.asm
			      C ;*		timer_isr.asm
			      C ;*		etopen.asm
			      C ;*
			      C ;* Functions :
			      C ;*	. etopen		;; Initializes card
			      C ;*	. rcv_mode_1		;; Setup receive mode
			      C ;*	. rcv_mode_2
			      C ;*	. rcv_mode_3
			      C ;*	. rcv_mode_4
			      C ;*	. rcv_mode_5
			      C ;*	. rcv_mode_6
			      C ;*
			      C ;* Author : Spenser Tsai
			      C ;*
			      C ;* Date : 05/17/96
			      C ;*
			      C ;
			      C ; Maintainers:
			      C ;
			      C ; John H.T. Ho		htho
			      C ;
			      C ;
			      C ; Revision History:
			      C ;
			      C ; Date	     Modfier.	Modification Descriptions
			      C ; ---------- ---------- ------------------------------------------
			      C ; 2000.1.31	htho	support 1M HomePNA
			      C ;
			      C ; 2000.3.27	htho	AUTOSENSE_ALARM = 18 -> 6
			      C ;
			      C ; 2000.4.6	htho	port rese while rx hang
			      C ;
			      C ; 2000.6.27	htho	support resend remote command for home pna
			      C ;
			      C ;*
			      C ;*****************************************************************************
			      C 
			      C 
			      C   ife SM_RSTART_PG
			      C   endif
			      C 
			      C 
			      C longpause macro
			      C 	local lp_not_mc
			      C 	push cx
			      C 	push ax
			      C 	mov  cx,1600	; 1.6ms = 1600*1.0us
			      C 	test sys_features,SYS_MCA
			      C 	je   lp_not_mc
			      C 	shl  cx,1	; twice as many loops for Microchannel
			      C lp_not_mc:
			      C 	in al,61h
			      C 	loop lp_not_mc
			      C 	pop  ax
			      C 	pop  cx
			      C endm
			      C 
			      C ;-> the assigned Ethernet address of the card.
			      C 	extrn	rom_address: byte
			      C 
			      C ;-> current address
			      C 	extrn	my_address: byte
			      C 
			      C 	public	mcast_list_bits, mcast_all_flag
 013F 00 00 00 00 00 00	      C mcast_list_bits db	0,0,0,0,0,0,0,0 ;Bit mask from last set_multicast_list
       00 00
 0147 00		      C mcast_all_flag	db	0		;Non-zero if hware should have all
			      C 					; ones in mask rather than this list.
			      C 
			      C 	public	rcv_modes
 0148 0007		      C rcv_modes	dw	7		;number of receive modes in our table.
 014A  0000		      C 		dw	0		;There is no mode zero
 014C  0199 R		      C 		dw	rcv_mode_1
 014E  01AD R		      C 		dw	rcv_mode_2
 0150  01CD R		      C 		dw	rcv_mode_3
 0152  01F2 R		      C 		dw	rcv_mode_4
 0154  0207 R		      C 		dw	rcv_mode_5
 0156  022C R		      C 		dw	rcv_mode_6
			      C 
			      C ;
			      C ;	a temp buffer for the received header
			      C ;
 = 001A			      C RCV_HDR_SIZE	equ	26		; 2 ids @6 + protocol @2+8, + header @4
 0158  001A [		      C rcv_hdr 	db	RCV_HDR_SIZE dup(0)
        00
       ]
			      C 
			      C ;
			      C ;	The board data
			      C ;
			      C 		public	board_data
 = 0020			      C BOARD_DATA_SIZE equ	32
 0172  0020 [		      C board_data	db	BOARD_DATA_SIZE dup(0)
        00
       ]
			      C 
			      C 
			      C 	public bad_command_intercept
 0192			      C bad_command_intercept:
			      C ;called with ah=command, unknown to the skeleton.
			      C ;exit with nc if okay, cy, dh=error if not.
 0192  B6 0B		      C 	mov	dh,BAD_COMMAND
 0194  F9		      C 	stc
 0195  C3		      C 	ret
			      C 
			      C 	public	as_send_pkt
			      C ; The Asynchronous Transmit Packet routine.
			      C ; Enter with es:di -> i/o control block, ds:si -> packet, cx = packet length,
			      C ;   interrupts possibly enabled.
			      C ; Exit with nc if ok, or else cy if error, dh set to error number.
			      C ;   es:di and interrupt enable flag preserved on exit.
 0196			      C as_send_pkt:
 0196  C3		      C 	ret
			      C 
			      C 	public	drop_pkt
			      C ; Drop a packet from the queue.
			      C ; Enter with es:di -> iocb.
 0197			      C drop_pkt:
			      C 	assume	ds:nothing
 0197  C3		      C 	ret
			      C 
			      C 	public	xmit
			      C ; Process a transmit interrupt with the least possible latency to achieve
			      C ;   back-to-back packet transmissions.
			      C ; May only use ax and dx.
 0198			      C xmit:
			      C 	assume	ds:nothing
 0198  C3		      C 	ret
			      C 
			      C ; Routines to set address filtering modes in the DM9100
			      C 	PUBLIC rcv_mode_1
 0199			      C rcv_mode_1:	; Turn off receiver
 0199  52		      C 	push	dx
 019A  66| 50		      C 	push	eax
 019C  2E: 8B 16 2469 R	      C 	mov	dx, p_CR6
 01A1  66| ED		      C 	in	eax, dx
 01A3  66| 83 C8 02	      C 	or	eax, CR6_M_RXSC 	 ;; Stop receive
 01A7  66| EF		      C 	out	dx, eax
 01A9  66| 58		      C 	pop	eax
 01AB  5A		      C 	pop	dx
 01AC  C3		      C 	ret
			      C 
			      C 	PUBLIC	rcv_mode_2
 01AD			      C rcv_mode_2:	; Receive only packets to this interface
 01AD  E8 0C90		      C 	call	XmtSendDummyFrame
 01B0  E8 0C05		      C 	call XmtGetSetupBuffer		;; Return AX near point to buffer
			      C 
 01B3  8B F8		      C 	mov  di, ax			; ES:DI points to start of setup buffer
 01B5  B9 0010		      C 	mov	cx, 16
 01B8			      C only_loop:
 01B8  BE 0000 E	      C 	mov	si, OFFSET my_address
			      C 
 01BB  66| 33 C0	      C 	xor  eax, eax
 01BE  AD		      C 	lodsw				; Load word into AX
 01BF  66| AB		      C 	stosd				; Store dword EAX in setup buffer
 01C1  AD		      C 	lodsw				; Load word into AX
 01C2  66| AB		      C 	stosd				; Store dword EAX in setup buffer
 01C4  AD		      C 	lodsw				; Load word into AX
 01C5  66| AB		      C 	stosd				; Store dword EAX in setup buffer
 01C7  E2 EF		      C 	loop	only_loop
			      C 
 01C9  E8 0BFC		      C 	call	XmtSendSetupFrame
 01CC  C3		      C 	ret
			      C 
			      C 	PUBLIC rcv_mode_3
 01CD			      C rcv_mode_3:	; Mode 2 plus broadcast packets (This is the default)
 01CD  E8 0C70		      C 	call	XmtSendDummyFrame
 01D0  E8 0BE5		      C 	call XmtGetSetupBuffer		;; Return AX near point to buffer
			      C 
 01D3  8B D8		      C 	mov	bx, ax			;; Store setup buffer pointer
 01D5  E8 0062		      C 	call	Fill_FF_Multicast	;; Fill all FF to buffer
			      C 
 01D8  E8 0077		      C 	call	Fill_myaddress_multicast	;; Add address to the first of buffer
			      C 
 01DB  E8 0BEA		      C 	call	XmtSendSetupFrame
			      C 
 01DE  2E: 8B 16 2469 R	      C 	mov	dx, p_CR6
 01E3  66| ED		      C 	in	eax, dx
 01E5  66| 83 E0 BF	      C 	and	eax, not CR6_M_PM
 01E9  66| 25 FFFFFF7F	      C 	and	eax, not CR6_M_PAM
 01EF  66| EF		      C 	out	dx, eax
			      C 
 01F1  C3		      C 	ret
			      C 
 01F2			      C rcv_mode_4:	; Mode 3 plus selected multicast packets
 01F2  E8 0C4B		      C 	call	XmtSendDummyFrame
 01F5  E8 0BC0		      C 	call XmtGetSetupBuffer		;; Return AX near point to buffer
			      C 
 01F8  8B D8		      C 	mov	bx, ax			;; Store setup buffer pointer
 01FA  E8 003D		      C 	call	Fill_FF_Multicast	;; Fill all FF to buffer
 01FD  E8 0052		      C 	call	Fill_myaddress_multicast	;; Add address to the first of buffer
			      C 						;; Return ES:DI-> 1st multicast
 0200  E8 0067		      C 	call	Fill_multicasttable
 0203  E8 0BC2		      C 	call	XmtSendSetupFrame
 0206  C3		      C 	ret
			      C 
 0207			      C rcv_mode_5:	; Mode 3 plus ALL multicast packets
 0207  E8 0C36		      C 	call	XmtSendDummyFrame
 020A  E8 0BAB		      C 	call XmtGetSetupBuffer		;; Return AX near point to buffer
			      C 
 020D  8B D8		      C 	mov	bx, ax			;; Store setup buffer pointer
 020F  E8 0028		      C 	call	Fill_FF_Multicast	;; Fill all FF to buffer
			      C 
 0212  E8 003D		      C 	call	Fill_myaddress_multicast	;; Add address to the first of buffer
			      C 
 0215  E8 0BB0		      C 	call	XmtSendSetupFrame
			      C 
 0218  2E: 8B 16 2469 R	      C 	mov	dx, p_CR6
 021D  66| ED		      C 	in	eax, dx
 021F  66| 83 E0 BF	      C 	and	eax, not CR6_M_PM
 0223  66| 0D 00000080	      C 	or	eax, CR6_M_PAM
 0229  66| EF		      C 	out	dx, eax
			      C 
 022B  C3		      C 	ret
			      C 
 022C			      C rcv_mode_6:	; Receive all packets (Promiscuous physical plus all multi)
 022C  2E: 8B 16 2469 R	      C 	mov	dx, p_CR6	       ;; Set pass all multicast & promiscuous
 0231  66| ED		      C 	in	eax, dx 		;; command
 0233  66| 83 C8 40	      C 	or	eax, CR6_M_PM
 0237  66| EF		      C 	out	dx, eax
			      C 
 0239  C3		      C 	ret
			      C 
			      C 
 023A			      C Fill_FF_Multicast:	;; Enter with AX = setup buffer.
 023A  06		      C 	push	es
			      C 
 023B  8B F8		      C 	mov  di, ax			; ES:DI points to setup buffer
 023D  8C D8		      C 	mov	ax, ds
 023F  8E C0		      C 	mov	es, ax
 0241  B9 00C0		      C 	mov  cx, HW_K_SETUP_FRAME_SIZE	;; (192)
 0244  C1 E9 02		      C 	shr  cx, 2
 0247  66| B8 FFFFFFFF	      C 	mov  eax, 0FFFFFFFFh
 024D  F3/ 66| AB	      C 	rep  stosd			; Setup buffer with local address
			      C 
 0250  07		      C 	pop	es
 0251  C3		      C 	ret
			      C 
 0252			      C Fill_myaddress_multicast:	;;Enter with bx = setup buffer
 0252  06		      C 	push	es
			      C 
 0253  8C D8		      C 	mov	ax, ds
 0255  8E C0		      C 	mov	es, ax
 0257  BE 0000 E	      C 	mov	si, OFFSET my_address
			      C 
 025A  8B FB		      C 	mov  di, bx			; ES:DI points to start of setup buffer
 025C  66| 33 C0	      C 	xor  eax, eax
 025F  AD		      C 	lodsw				; Load word into AX
 0260  66| AB		      C 	stosd				; Store dword EAX in setup buffer
 0262  AD		      C 	lodsw				; Load word into AX
 0263  66| AB		      C 	stosd				; Store dword EAX in setup buffer
 0265  AD		      C 	lodsw				; Load word into AX
 0266  66| AB		      C 	stosd				; Store dword EAX in setup buffer
			      C 
 0268  07		      C 	pop	es
 0269  C3		      C 	ret
			      C 
 026A			      C Fill_multicasttable:	;; Enter with ES:DI -> current pointer of setup buffer
			      C ; Now, determine the number of entries in the MulticastTable, and add
			      C ; those entries to the setup frame.
 026A  06		      C 	push	es
			      C 
 026B  8C D8		      C 	mov	ax, ds
 026D  8E C0		      C 	mov	es, ax
			      C 
 026F  2E: 8B 0E 248E R	      C 	mov  cx, MulticastTable.table_current
 0274  BE 2490 R	      C 	mov  si, OFFSET MulticastTable.table_multiaddr
 0277  2E: 8B 16 248C R	      C 	mov	dx, MulticastTable.table_maxnum
			      C 
 027C			      C purf_loop:
 027C  83 F9 00		      C 	cmp  cx, 0
 027F  74 10		      C 	je   purf_done
			      C 
 0281  AD		      C 	lodsw				; Load word into AX
 0282  66| AB		      C 	stosd				; Store dword EAX in setup buffer
 0284  AD		      C 	lodsw				; Load word into AX
 0285  66| AB		      C 	stosd				; Store dword EAX in setup buffer
 0287  AD		      C 	lodsw				; Load word into AX
 0288  66| AB		      C 	stosd				; Store dword EAX in setup buffer
			      C 
			      C ; 16 bytes storage for each address
 028A  83 C6 0A		      C 	add  si, 10			; DS:SI points to next entry in
			      C 					; MulticastTable
 028D  49		      C 	dec  cx
 028E  4A		      C 	dec	dx
 028F  EB EB		      C 	jmp  purf_loop
			      C 
 0291			      C purf_done:
 0291  83 FA 00		      C 	cmp	dx, 0			;; Fill all multicast space ?
 0294  74 13		      C 	je	purf_exit		;; Yes
 0296  8B CA		      C 	mov	cx, dx
 0298  83 EE 06		      C 	sub	si, 6			;; point to previouse entry
			      C 
 029B			      C pad_loop:
 029B  AD		      C 	lodsw				; Load word into AX
 029C  66| AB		      C 	stosd				; Store dword EAX in setup buffer
 029E  AD		      C 	lodsw				; Load word into AX
 029F  66| AB		      C 	stosd				; Store dword EAX in setup buffer
 02A1  AD		      C 	lodsw				; Load word into AX
 02A2  66| AB		      C 	stosd				; Store dword EAX in setup buffer
			      C 
 02A4  83 EE 06		      C 	sub	si, 6			;; Return to previouse entry
 02A7  E2 F2		      C 	loop	pad_loop
			      C 
 02A9			      C purf_exit:
 02A9  07		      C 	pop	es
 02AA  C3		      C 	ret
			      C 
			      C 	public	terminate
 02AB			      C terminate:
			      C 	terminate_board
 02AB  C3		      C 	ret
			      C 
			      C ; Linkages to non-device-specific routines
			      C ;called when we want to determine what to do with a received packet.
			      C ;enter with cx = packet length, es:di -> packet type, dl = packet class.
			      C ;It returns with es:di = 0 if don't want this type or if no buffer available.
			      C 	extrn	recv_find: near
			      C 
			      C ;called after we have copied the packet into the buffer.
			      C ;enter with ds:si ->the packet, cx = length of the packet.
			      C 	extrn	recv_copy: near
			      C 
			      C ;call this routine to schedule a subroutine that gets run after the
			      C ;recv_isr.  This is done by stuffing routine's address in place
			      C ;of the recv_isr iret's address.  This routine should push the flags when it
			      C ;is entered, and should jump to recv_exiting_exit to leave.
			      C ;enter with ax = address of routine to run.
			      C 	extrn	schedule_exiting: near
			      C 
			      C ;recv_exiting jumps here to exit, after pushing the flags.
			      C 	extrn	recv_exiting_exit: near
			      C 
			      C ;--------------------------------------------------------------------+
			      C ; Name : timer_isr
			      C ;
			      C ; Description:
			      C ;
			      C ; Enter :
			      C ; Return :
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C ;;;;++, 2000.4.6, htho
			      C 	PUBLIC	interval_rx_cnt
 02AC 0000		      C interval_rx_cnt DW	?
			      C ;;;;++
 02AE 0000		      C TxHangCounter	DW	?
 02B0 0000		      C RxHangCounter	DW	?
 02B2 0000		      C TxNumOfHangs	DW	?
 02B4 0000		      C RxNumOfHangs	DW	?
			      C 
 = 0012			      C TX_HANG_VALUE	EQU	18
 = 0012			      C RX_HANG_VALUE	EQU	18
			      C 
			      C ;;TX_HANG_VALUE   EQU	  18
			      C ;;RX_HANG_VALUE   EQU	  18
			      C 
 02B6 44 4D 39 31 30 30	      C Xmt_block_reset 	DB	'DM9100 Debug: Reset adapter because transmit block'
       20 44 65 62 75 67
       3A 20 52 65 73 65
       74 20 61 64 61 70
       74 65 72 20 62 65
       63 61 75 73 65 20
       74 72 61 6E 73 6D
       69 74 20 62 6C 6F
       63 6B
 02E8  0D 0A		      C 			DB	CR, LF
 02EA = 0034		      C Xmt_block_reset_len	EQU	$ - Xmt_block_reset
			      C ;;++, 980310, Hu-Tiong, for Dynamic Auto Sense
			      C ;;-+, 2000.3.27, htho
			      C ;AUTOSENSE_ALARM	 EQU	 18	 ; Auto Sense timer should activated every second
 = 0006			      C AUTOSENSE_ALARM 	EQU	6	; Auto Sense timer should activated every 1/3 second
			      C ;;-+
 02EA 00		      C AutoCount		db	0
 02EB 00		      C TimerSemaphore		db	0
			      C ;;++
			      C ;;++, 980925, Hu-Tiong
 = 0000			      C LINK_PASS		EQU	0
 = 0001			      C LINK_FAIL		EQU	1
 02EC 0000		      C PreviousLinkStatus	dw	LINK_PASS
 = 0000			      C AUTO_STATE_IDLE 	EQU	0
 = 0001			      C AUTO_STATE_START	EQU	1
 02EE 0000		      C AutoState		dw	AUTO_STATE_IDLE
			      C 
 02F0  0400 [		      C stack_buf		dw	1024 dup(?)
        0000
       ]
 0AF0			      C stack_top		label	word
 0AF0 00000000		      C their_stack		dd	?
			      C 
			      C 	include phy.inc
			      C ;; -- PHY Registers
 = 0000			      C PHY_BMCR		EQU	00h
 = 0001			      C PHY_BMSR		EQU	01h
 = 0002			      C PHY_PHYIDR1		EQU	02h
 = 0003			      C PHY_PHYIDR2		EQU	03h
 = 0004			      C PHY_ANAR		EQU	04h
 = 0005			      C PHY_ANLPAR		EQU	05h
 = 0006			      C PHY_ANER		EQU	06h
 = 0012			      C PHY_DCR 		EQU	12h
 = 0013			      C PHY_FCSCR		EQU	13h
 = 0015			      C PHY_DECR		EQU	15h
 = 0016			      C PHY_SRR 		EQU	16h
 = 0017			      C PHY_PCR 		EQU	17h
 = 0018			      C PHY_LBREMR		EQU	18h
 = 0011			      C PHY_DSCSR		EQU	17
 = 0012			      C PHY_10BTCSR		EQU	18
 = 0019			      C PHY_PAR 		EQU	19h
 = 001B			      C PHY_10BTSR		EQU	1Bh
 = 001C			      C PHY_10BTCR		EQU	1Ch
			      C 
			      C ;; -- Pattern thtough CR9 to program PHY
 = 0000			      C PHY_clkL_Write_0	EQU	00000h
 = 00010000		      C PHY_clkH_Write_0	EQU	10000h
 = 00020000		      C PHY_clkL_Write_1	EQU	20000h
 = 00030000		      C PHY_clkH_Write_1	EQU	30000h
			      C 
 = 00040000		      C PHY_clkL_Read		EQU	40000h
 = 00050000		      C PHY_clkH_Read		EQU	50000h
			      C 
 = 00080000		      C CR9_M_MDI	       EQU     80000h
 = 0013			      C CR9_S_MDI	       EQU     19
			      C 
 = 0100			      C BMCR_M_DM		EQU	0100h	       ; Duplex Mode mask.
			      C 
 = 0020			      C BMSR_M_AN		EQU	0020h	       ; Auto-Negotiation complete mask
 = 0004			      C BMSR_M_LS		EQU	0004h	       ; Link Status mask.
			      C 
 = 0001			      C ANER_M_LAA		EQU	0001h	       ; Link Partner Auto-Negotiation Able mask
			      C 
			      C ;;PAR_M_SI10		  EQU	  0040h 	 ; Speed Indication mask
			      C 
			      C ;;--- PHY Chip
 = 0000			      C DSIPHY			EQU	0
 = 0001			      C NSPHY			EQU	1
			      C ;;++, 2000.3.27
 = 0002			      C PNAPHY			EQU	2
			      C ;;++
			      C 
 = 2000			      C NS_OUI_MSB		EQU	0010000000000000B
 = 5C00			      C NS_OUI_LSB		EQU	0101110000000000B
			      C 
			      C  
			      C 
			      C ;;++
			      C 
			      C EXTRN	their_timer : DWORD
			      C 
			      C 	public	timer_isr
 0AF4			      C timer_isr:
			      C ;if the first instruction is an iret, then the timer is not hooked
			      C ;;-+, 980310, Hu-Tiong
			      C ;;	pushf		  ; Save flags
			      C ;;	cli		  ; Block interrupts
 0AF4  FA		      C 	cli
			      C ;;;;++, 2000.6.27, htho, support resend remote command for home pna
			      C ifdef HOMEPNA
			      C ;	extrn	resend_remote_cmd_cnt: byte
			      C ;	extrn	resend_remote_cmd_timer: word
 0AF5  2E: 80 3E 186B R	      C 	cmp	cs:send_remote_cmd, 1
       01
 0AFB  75 0D		      C 	jne	@F
 0AFD  2E: 80 3E 1870 R	      C 	cmp	cs:resend_remote_cmd_cnt, 0
       00
 0B03  74 05		      C 	je	@F
 0B05  2E: FF 06 1871 R	      C 	inc	cs:resend_remote_cmd_timer
 0B0A			      C @@:
			      C endif
			      C ;;;;++
 0B0A  9C		      C 	pushf
 0B0B  2E: FF 1E 0000 E	      C 	call	cs:[their_timer]
			      C 
 0B10  FA		      C 	cli
 0B11  2E: 80 3E 02EB R	      C 	cmp	cs:TimerSemaphore, 0
       00
 0B17  74 01		      C 	je	timer_isr_main
			      C 
 0B19  CF		      C 	iret
 0B1A			      C timer_isr_main:
 0B1A  2E: FE 06 02EB R	      C 	inc	cs:TimerSemaphore
			      C ;;-+
 0B1F  1E		      C 	push	ds			; Save current data segment
 0B20  50		      C 	push	ax
			      C 
 0B21  0E		      C 	push	cs
 0B22  1F		      C 	pop	ds			; DS = CS
			      C 
 0B23  2E: 89 26 0AF0 R	      C 	mov	word ptr their_stack, sp
 0B28  2E: 8C 16 0AF2 R	      C 	mov	word ptr their_stack+2, ss
			      C 
 0B2D  8C C8		      C 	mov	ax, cs
 0B2F  8E D0		      C 	mov	ss, ax
 0B31  BC 0AF0 R	      C 	mov	sp, offset stack_top
 0B34  FB		      C 	sti
			      C 
 0B35  06		      C 	push	es
 0B36  66| 60		      C 	pushad
			      C 
			      C ;;;;++, 2000.6.27, htho, support resend remote command for home pna
			      C ifdef HOMEPNA
 0B38  2E: 80 3E 1870 R	      C 	cmp	resend_remote_cmd_cnt, 0
       00
 0B3E  7E 1B		      C 	jle	@F
 0B40  2E: 81 3E 1871 R	      C 	cmp	resend_remote_cmd_timer, 8 * 18
       0090
 0B47  72 12		      C 	jb	@F
			      C 
 0B49  9C		      C 	pushf
 0B4A  FA		      C 	cli
 0B4B  2E: 81 2E 1871 R	      C 	sub	resend_remote_cmd_timer, 8 * 18
       0090
 0B52  2E: FE 0E 1870 R	      C 	dec	resend_remote_cmd_cnt
 0B57  9D		      C 	popf
			      C 
 0B58  E8 1640		      C 	call	Write_PNA_CR16
 0B5B			      C @@:
			      C endif
			      C ;;;;++
			      C 
 0B5B  2E: 80 3E 02EA R	      C 	cmp	AutoCount, AUTOSENSE_ALARM ; is auto sense timer time-out
       06
 0B61  73 07		      C 	jae	execute_autosense
			      C 
 0B63  2E: FE 06 02EA R	      C 	inc	AutoCount		; incement auto sense timer
 0B68  EB 09		      C 	jmp	CheckTxHangCounter
			      C 
 0B6A			      C execute_autosense:
 0B6A  E8 10D7		      C 	call	DynamicAutoDetect
			      C 
 0B6D  2E: C6 06 02EA R	      C 	mov	AutoCount, 0
       00
			      C 
 0B73			      C CheckTxHangCounter:
			      C ;;++
			      C 
 0B73  2E: 83 3E 02AE R	      C 	cmp  TxHangCounter, 0	; If counter=0 nothing to be done
       00
 0B79  74 3C		      C 	je   RxHangCheck
			      C 
 0B7B  2E: FF 06 02AE R	      C 	inc  TxHangCounter	; Increment TxHangCounter
			      C 
 0B80  2E: 8B 16 2467 R	      C 	mov  dx, p_CR5	       ; If CR5 TXDU bit set - Zero TxHangCounter
 0B85  66| ED		      C 	in   eax, dx
 0B87  66| A9 00000004	      C 	test eax, CR5_M_TXDU	 ;; TU -- Transmit buffer Unavailable
 0B8D  74 11		      C 	jz   Check_Hang 	; Jump if clear
			      C ;;- Clear Transmit buffer Unavailable bit
 0B8F  66| B8 00000004	      C 	mov  eax, CR5_M_TXDU	 ; If set: (1) Clear TU bit.
 0B95  66| EF		      C 	out  dx, eax
 0B97  2E: C7 06 02AE R	      C 	mov  TxHangCounter, 0	; (2) Set TxHangCounter to 0.
       0000
 0B9E  EB 17		      C 	jmp  RxHangCheck
			      C 
 0BA0			      C Check_Hang:
 0BA0  2E: 83 3E 02AE R	      C 	cmp  TxHangCounter, TX_HANG_VALUE  ; See if Tx machine hangs (19)
       12
 0BA6  76 0F		      C 	jbe  RxHangCheck		   ; If not - Exit
			      C 
 0BA8  2E: C7 06 02AE R	      C 	mov  TxHangCounter, 0
       0000
 0BAF  2E: FF 06 02B2 R	      C 	inc  TxNumOfHangs		   ;	    (2) Inc hangs counter
			      C 
 0BB4  E8 1401		      C 	call PortUpdateReceiveFilter
			      C 
 0BB7			      C RxHangCheck:
			      C ;;;;++, 2000.4.6, htho
 0BB7  9C		      C 	pushf
 0BB8  FA		      C 	cli
 0BB9  2E: 83 3E 02AC R	      C 	cmp	interval_rx_cnt, 0
       00
 0BBF  75 12		      C 	jne	CheckRxHangCounter
 0BC1  2E: 8B 16 246D R	      C 	mov	dx, p_CR8
 0BC6  66| ED		      C 	in	eax, dx
 0BC8  66| 83 F8 00	      C 	cmp	eax, 0
 0BCC  74 05		      C 	je	CheckRxHangCounter
			      C 
 0BCE  FB		      C 	sti
 0BCF  E8 13E6		      C 	call	PortUpdateReceiveFilter
 0BD2  FA		      C 	cli
			      C 
 0BD3			      C CheckRxHangCounter:
 0BD3  2E: C7 06 02AC R	      C 	mov	interval_rx_cnt, 0
       0000
 0BDA  9D		      C 	popf
			      C ;;;;++
			      C 
 0BDB  2E: 83 3E 02B0 R	      C 	cmp  RxHangCounter, 0	; If counter=0 nothing to be done
       00
 0BE1  74 2C		      C 	je   Timer_Exit
			      C 
 0BE3  2E: FF 06 02B0 R	      C 	inc  RxHangCounter	; Increment RxHangCounter
			      C 
 0BE8  2E: 83 3E 02B0 R	      C 	cmp  RxHangCounter, RX_HANG_VALUE  ; See if counter too large
       12
 0BEE  76 1F		      C 	jbe  Timer_Exit 		   ; If not - Exit
			      C 
 0BF0  2E: C7 06 02B0 R	      C 	mov  RxHangCounter, 0		  ; 1) Zero RxHangCounter
       0000
			      C 
 0BF7  2E: 8B 36 1028 R	      C 	mov  si, RcvCurrentDescriptor	   ; 2) If Curr receive descriptor
 0BFC  66| 8B 04	      C 	mov  eax, [si].RCV_DESCRIPTOR.RDES0;	host owned - reset Chip.
 0BFF  66| A9 80000000	      C 	test eax, RDES0_M_OWN
 0C05  75 08		      C 	jnz  Timer_Exit
			      C 	;; OWN = Host
 0C07  2E: FF 06 02B4 R	      C 	inc  RxNumOfHangs		   ; Inc RxHangs counter
			      C 
 0C0C  E8 13A9		      C 	call PortUpdateReceiveFilter	   ; Reset Chip.
			      C 
 0C0F			      C Timer_Exit:
 0C0F  66| 61		      C 	popad
 0C11  07		      C 	pop	es
			      C 
 0C12  FA		      C 	cli
 0C13  2E: 8B 26 0AF0 R	      C 	mov	sp, word ptr their_stack
 0C18  2E: 8E 16 0AF2 R	      C 	mov	ss, word ptr their_stack+2
			      C 
 0C1D  58		      C 	pop  ax
 0C1E  1F		      C 	pop  ds 	  ; Restore data segment
			      C ;;-+, 980310, Hu-Tiong
			      C ;;	popf		  ; Restore flags
			      C ;;	jmp  CS:[their_timer]
 0C1F  2E: C6 06 02EB R	      C 	mov	cs:TimerSemaphore, 0
       00
			      C ;;-+
			      C 
 0C25  CF		      C 	iret
			      C ;;-----------------------
			      C include xmt.asm
			      C ;*****************************************************************************
			      C ;* Name : XMT.ASM
			      C ;*
			      C ;* All rights reserved by DAVICOM, 1996
			      C ;*
			      C ;* Description : Transmission initialize, reset, enable, disable, execute,
			      C ;*		multicast and setup frame.
			      C ;*
			      C ;* Functions :
			      C ;*	. XmtInit
			      C ;*	. XmtReset
			      C ;*	. XmtDisable
			      C ;*	. XmtEnable
			      C ;*	. XmtGetSetupBuffer
			      C ;*	. XmtSendSetupFrame
			      C ;*	. XmtSendDummyFrame
			      C ;*	. send_pkt
			      C ;*	. XmtMain
			      C ;*	. AddMulticastAddress
			      C ;*	. MulticastTableSearch
			      C ;*
			      C ;* Author : Spenser Tsai
			      C ;*
			      C ;* Date : 05/17/96
			      C ;*
			      C ;
			      C ; Maintainers:
			      C ;
			      C ; John H.T. Ho		htho
			      C ;
			      C ;
			      C ; Date	     Modfier.	Modification Descriptions
			      C ; ---------- ---------- ------------------------------------------
			      C ; 2000.2.16	htho	dynamicaly keep a image of CR6 in [PortConfigCR6]
			      C ;
			      C ;*
			      C ;*****************************************************************************
			      C .386
			      C 	PUBLIC	NextTxPollPtr, TxPendingCnt
 0C26 0000		      C NextTxPollPtr		DW	0	; Polling command pointer at descriptor
 0C28 0000		      C TxPendingCnt		DW	0
			      C 
			      C 
			      C 	PUBLIC XmtNumBuffers, XmtState
 0C2A 0008		      C XmtNumBuffers	DW	8	; Number of transmit's buffer
 0C2C 0000		      C XmtState	      DW 0    ; Current state of the trasmit object. 1=Active
			      C 			      ; 0=Inactive
			      C 
			      C 	PUBLIC	XmtFrameSize
 0C2E 0000		      C XmtFrameSize	      DW 0    ; Cumulative size of current current TransmitChain
			      C 			      ; frame
			      C 
			      C 	PUBLIC XmtCRCThreshold
 0C30 0000		      C XmtCRCThreshold       DW 0    ; Minimum frame size for which the driver should
			      C 			      ; compute the CRC.  If less than 64, the Tulip's
			      C 			      ; padding will prevent CalcCRC from working
			      C 			      ; correctly.
			      C 	PUBLIC p_XmtBlockVirt, p_XmtRingVirt, p_XmtBlockPhys, p_XmtRingPhys
 0C32 0000		      C p_XmtBlockVirt	      DW 0    ; A virtual NEAR pointer to the base of the
			      C 			      ; transmit buffers
			      C 
 0C34 0000		      C p_XmtRingVirt	      DW 0    ; A virtual NEAR pointer to the base of the
			      C 			      ; transmit descriptor ring
			      C 
 0C36 00000000		      C p_XmtBlockPhys	      DD 0    ; A 32 bit physical pointer to the base of the
			      C 			      ; transmit buffers
			      C 
 0C3A 00000000		      C p_XmtRingPhys	      DD 0    ; A 32 bit physical pointer to the base of the
			      C 			      ; transmit descriptor ring
			      C 
			      C 	PUBLIC XmtCurrentDescriptor
			      C 	PUBLIC TxPollPtr, PreTxPollPtr, Poll1st
 0C3E 0000		      C XmtCurrentDescriptor  DW 0    ; Pointer to current descriptor
 0C40 0000		      C TxPollPtr	      DW 0    ;; Polling command pointer at descriptor
 0C42 0000		      C PreTxPollPtr	      DW 0    ;; Polling command pointer at descriptor
 0C44 01		      C Poll1st 	      DB 1    ;; 1 = never poll
			      C 
			      C ;--------------------------------------------------------------------+
			      C ; Name : XmtInit
			      C ;
			      C ; Description: Initializes the data structures for transmitting.
			      C ;		It must be called before any other calls are made to
			      C ;		XMT.
			      C ;
			      C ; Stack Frame relative to BP (Remember, gang, this is a NEAR call, so the
			      C ;			      first argument appears at BP+4. It's NOT a typo)
			      C ;
			      C ; Enter :
			      C ;	BP+6  DWORD  PhysAddr	 ; Physical Address of Memory Block
			      C ;	BP+4  WORD   VirtAddr	 ; NEAR pointer to Memory Block. DS:VirtAddr
			      C ;
			      C ; Return : Bytes used in AX.
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C 	ALIGN  4
			      C 	PUBLIC XmtInit
 0C48			      C XmtInit PROC NEAR
 0C48  55		      C 	push bp
 0C49  8B EC		      C 	mov  bp,sp
 0C4B  66| 52		      C 	push edx
			      C ;;++, 980415, Hu-Tiong
 0C4D  66| 53		      C 	push	ebx
			      C ;;++
 0C4F  51		      C 	push cx
 0C50  57		      C 	push di
 0C51  56		      C 	push si
			      C 
 0C52  2E: C7 06 0C2C R	      C 	mov  XmtState, 0
       0000
			      C 
 0C59  2E: 83 3E 0C30 R	      C 	cmp  XmtCRCThreshold, 0 	; Has threshold been set already?
       00
 0C5F  75 07		      C 	jne  xi_continue		; If yes, don't do so here.
			      C 
 0C61			      C xi_dont_gen_crc:
 0C61  2E: C7 06 0C30 R	      C 	mov  XmtCRCThreshold, FRAME_MTU+1 ; Above Rev 2.2, set threshold ...
       05EB
			      C 					; ... greater than maximum size
			      C 					;; FRAME_MTU = 1514.
 0C68			      C xi_continue:
 0C68  8B 46 04		      C 	mov  ax, WORD PTR [BP+4]	; Get Virtual address of Memory Block
 0C6B  2E: A3 0C32 R	      C 	mov  p_XmtBlockVirt, ax
 0C6F  2E: A3 0C34 R	      C 	mov  p_XmtRingVirt, ax
 0C73  66| 8B 56 06	      C 	mov  edx, DWORD PTR [BP+6]	; Get Physical address of Memory Block
 0C77  66| 83 FA 00	      C 	cmp  edx, 0			; If address is zero, just return
 0C7B  0F 84 00A4	      C 	je   xinit_return_bytes_used	; bytes used, don't init.
 0C7F  66| 2E: 89 16 0C36 R   C 	mov  p_XmtBlockPhys, edx
 0C85  66| 2E: 89 16 0C3A R   C 	mov  p_XmtRingPhys, edx
 0C8B  2E: A1 0C2A R	      C 	mov  ax, XmtNumBuffers
 0C8F  BA 05F0		      C 	mov  dx, XMT_BUFFER_SIZE
 0C92  F7 E2		      C 	mul  dx
 0C94  66| 0F B7 D0	      C 	movzx edx, ax			; EDX = #buffers * size of buffer
 0C98  2E: 01 16 0C34 R	      C 	add  p_XmtRingVirt, dx		; Add total size of receive buffer...
 0C9D  66| 2E: 01 16 0C3A R   C 	add  p_XmtRingPhys, edx 	; ...space to get offset of desc ring
			      C ;; p_XmtRingVirt/p_XmtRIngPhys are end of entity block.
			      C ;
			      C ; At this point the p_XmtBlock and p_XmtRing pointers are initialized.
			      C ; Now, initialize the descriptors. Registers are used as follows:
			      C ;
			      C ; SI points to descriptor being initialized.
			      C ; DI points to the descriptor's associated transmit buffer
			      C ; EDX is the physical address of the associated transmit buffer
			      C ;
 0CA3  2E: 8B 36 0C34 R	      C 	mov  si, p_XmtRingVirt		;; ? p_XmtBlockVirt ?
 0CA8  2E: 8B 3E 0C32 R	      C 	mov  di, p_XmtBlockVirt
 0CAD  66| 2E: 8B 16 0C36 R   C 	mov  edx, p_XmtBlockPhys
			      C ;;++, 980415, Hu-Tiong
 0CB3  66| 2E: 8B 1E 0C3A R   C 	mov	ebx, p_XmtRingPhys
			      C ;;++
 0CB9  2E: 8B 0E 0C2A R	      C 	mov  cx, XmtNumBuffers		; Get XmtNumBuffers
 0CBE  49		      C 	dec  cx 			; Initialize NumXmtBuffs-1 descriptors
			      C 
 0CBF			      C xinit_loop:
			      C 
 0CBF  66| C7 04 00000000     C 	mov  [si].XMT_DESCRIPTOR.TDES0, 0   ; Set owner to Host, clear status
			      C ;;-+, 980415, Hu-Tiong
			      C ;;	mov  [si].XMT_DESCRIPTOR.TDES1, 0   ; clear all TDES1 control bits
 0CC6  66| C7 44 04	      C 	mov  [si].XMT_DESCRIPTOR.TDES1, TDES1_M_CE   ; clear all TDES1 control bits
       01000000
			      C ;;-+
 0CCE  66| 89 54 08	      C 	mov  [si].XMT_DESCRIPTOR.TDES2, edx ; Point buffer 1 to edx
			      C ;;-+, 980415, Hu-Tiong
			      C ;;	mov  [si].XMT_DESCRIPTOR.TDES3, 0   ; Point buffer 2 to NULL
 0CD2  66| 83 C3 20	      C 	add  ebx, SIZE XMT_DESCRIPTOR
 0CD6  66| 89 5C 0C	      C 	mov  [si].XMT_DESCRIPTOR.TDES3, ebx ; Point buffer 2 to NULL
			      C ;;-+
 0CDA  89 7C 10		      C 	mov  [si].XMT_DESCRIPTOR.p_XmtBuffer, di ; virtual address of buffer
 0CDD  8B C6		      C 	mov  ax, si
 0CDF  83 C0 20		      C 	add  ax, SIZE XMT_DESCRIPTOR	; AX points to next descriptor
 0CE2  89 44 12		      C 	mov  [si].XMT_DESCRIPTOR.p_XmtNext, ax	 ; virt address of next descr
 0CE5  8B F0		      C 	mov  si, ax			; SI points to next descriptor
 0CE7  66| 81 C2 000005F0     C 	add  edx, XMT_BUFFER_SIZE	; EDX holds physical address of next buf
 0CEE  81 C7 05F0	      C 	add  di, XMT_BUFFER_SIZE	; DI points to next buf
 0CF2  E2 CB		      C 	loop xinit_loop 		; Loop while CX != 0
			      C ;
			      C ; Now initialize the last descriptor
			      C ;
 0CF4  66| C7 04 00000000     C 	mov  [si].XMT_DESCRIPTOR.TDES0, 0    ; Set owner to Host, clear status.
			      C ;;-+, 980415, Hu-Tiong
			      C ;;	mov  [si].XMT_DESCRIPTOR.TDES1, TDES1_M_EOR ; end of ring ;; (02000000h)
 0CFB  66| C7 44 04	      C 	mov  [si].XMT_DESCRIPTOR.TDES1, TDES1_M_CE  ; end of ring ;; (02000000h)
       01000000
			      C ;;-+
 0D03  66| 89 54 08	      C 	mov  [si].XMT_DESCRIPTOR.TDES2, edx  ; Point buffer 1 to edx
			      C ;;-+, 980415, Hu-Tiong
			      C ;;	mov  [si].XMT_DESCRIPTOR.TDES3, 0    ; Point buffer 2 to NULL
 0D07  66| 2E: 8B 1E 0C3A R   C 	mov  ebx, p_XmtRingPhys
 0D0D  66| 89 5C 0C	      C 	mov  [si].XMT_DESCRIPTOR.TDES3, ebx ; Point buffer 2 to NULL
			      C ;;-+
 0D11  89 7C 10		      C 	mov  [si].XMT_DESCRIPTOR.p_XmtBuffer, di ; virtual address of buffer
 0D14  2E: A1 0C34 R	      C 	mov  ax, p_XmtRingVirt
 0D18  89 44 12		      C 	mov  [si].XMT_DESCRIPTOR.p_XmtNext, ax	 ; point back to start of ring
			      C ;
			      C ; At this point, the transmit ring of descriptors is initialized, and
			      C ; all ownership bits are set to the Host. All is set for transmit DMA
			      C ; traffic to be delivered to the adapter once the adapter is enabled.
			      C ;
 0D1B  2E: A1 0C34 R	      C 	mov  ax, p_XmtRingVirt
 0D1F  2E: A3 0C3E R	      C 	mov  XmtCurrentDescriptor, ax	; Initialize current descriptor
			      C 
 0D23			      C xinit_return_bytes_used:
 0D23  2E: A1 0C2A R	      C 	mov  ax, XmtNumBuffers		; Get number of Xmt Buffers
 0D27  BA 05F0		      C 	mov  dx, XMT_BUFFER_SIZE	;; 1520
 0D2A  83 C2 20		      C 	add  dx, SIZE XMT_DESCRIPTOR
 0D2D  F7 E2		      C 	mul  dx 			; DX:AX = (BUFFER_SIZE + DESCR_SIZE) *
			      C 					;	       NUMBER_OF_BUFFERS
			      C 					; Note: We discard DX.
			      C 					; AX return value.
 0D2F  5E		      C 	pop  si
 0D30  5F		      C 	pop  di
 0D31  59		      C 	pop  cx
			      C ;;++, 980415, Hu-Tiong
 0D32  66| 5B		      C 	pop	ebx
			      C ;;++
 0D34  66| 5A		      C 	pop  edx
 0D36  5D		      C 	pop  bp
 0D37  C3		      C 	ret
 0D38			      C XmtInit ENDP
			      C 
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Page 2 - 1


			      C 	PAGE
			      C ;--------------------------------------------------------------------+
			      C ; Name : XmtReset
			      C ;
			      C ; Description: Stop transmit & Clear descriptor's OWN bit.
			      C ;
			      C ; Enter : None
			      C ;
			      C ; Return : None
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C 	ALIGN  4
			      C 	PUBLIC XmtReset
 0D38			      C XmtReset PROC NEAR
 0D38  50		      C 	push ax
 0D39  51		      C 	push cx
 0D3A  56		      C 	push si
			      C 
 0D3B  E8 0032		      C 	call XmtDisable
			      C 
 0D3E  2E: 8B 36 0C34 R	      C 	mov  si, p_XmtRingVirt		; Get pointer to base of transmit ring
 0D43  2E: A1 0C2A R	      C 	mov  ax, XmtNumBuffers
 0D47  2E: C7 06 0C28 R	      C 	mov  TxPendingCnt, 0
       0000
 0D4E  2E: 89 36 0C3E R	      C 	mov  XmtCurrentDescriptor, si
 0D53  2E: 89 36 0C26 R	      C 	mov  NextTxPollPtr, si
 0D58  2E: 8B 0E 0C2A R	      C 	mov  cx, XmtNumBuffers		; Get `mtNumBuffers
			      C 
 0D5D			      C xreset_loop:
 0D5D  66| C7 04 00000000     C 	mov  [si].XMT_DESCRIPTOR.TDES0, 0 ; Set ownership to Host, clear status
			      C 
 0D64  8B 74 12		      C 	mov  si, [si].XMT_DESCRIPTOR.p_XmtNext ; SI points to next descriptor
 0D67  E2 F4		      C 	loop xreset_loop		; Loop while CX != 0
			      C 
 0D69  5E		      C 	pop  si
 0D6A  59		      C 	pop  cx
 0D6B  58		      C 	pop  ax
 0D6C  C3		      C 	ret
 0D6D			      C XmtReset ENDP
			      C 
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Page 3 - 1


			      C 	PAGE
			      C ;--------------------------------------------------------------------+
			      C ; Name : XmtDisable
			      C ;
			      C ; Description:
			      C ;	   This function disables the transmission of frames on the adapter
			      C ;			 (Stop)
			      C ;
			      C ; Enter : None
			      C ;
			      C ; Return : None
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C 	   ALIGN  4
			      C 	   PUBLIC XmtDisable
 0D70			      C XmtDisable PROC NEAR
 0D70  66| 50		      C 	push eax
 0D72  52		      C 	push dx
			      C 
 0D73  2E: C7 06 0C2C R	      C 	mov  XmtState, 0
       0000
			      C 
			      C ;;-+, 2000.2.16, hu-tiong
			      C ;	mov  dx, p_CR6		       ;    Stop the transmit process
			      C ;	in   eax, dx
			      C ;	and  eax, NOT CR6_M_TXSC
 0D7A  66| 2E: A1 1878 R      C 	mov	eax, PortConfigCR6
 0D7F  66| 25 FFFFDFFF	      C 	and	eax, NOT CR6_M_TXSC
 0D85  66| 2E: A3 1878 R      C 	mov	PortConfigCR6, eax
			      C ;;-+
 0D8A  E8 138F		      C 	call PortCR6Write
			      C 
 0D8D  5A		      C 	pop  dx
 0D8E  66| 58		      C 	pop  eax
 0D90  C3		      C 	ret
 0D91			      C XmtDisable ENDP
			      C 
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Page 4 - 1


			      C 	PAGE
			      C ;--------------------------------------------------------------------+
			      C ; Name : XmtEnable
			      C ;
			      C ; Description:
			      C ;		This function enable the transmission of frames on the adapter.
			      C ;		And set base of transmit ring to CR4.
			      C ;
			      C ; Enter : None
			      C ;
			      C ; Return : None
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C 	  ALIGN  4
			      C 	  PUBLIC XmtEnable
 0D94			      C XmtEnable PROC NEAR
 0D94  66| 50		      C 	push eax
 0D96  52		      C 	push dx
			      C 
 0D97  2E: C7 06 0C2C R	      C 	mov  XmtState, 1
       0001
			      C 
 0D9E  66| 2E: A1 0C3A R      C 	mov  eax, p_XmtRingPhys 	;    Write CR4 with p_XmtRingPhys
 0DA3  2E: 8B 16 2465 R	      C 	mov  dx, p_CR4
 0DA8  66| EF		      C 	out  dx, eax
			      C 
			      C ;;	  mov  dx, p_CR6		 ;    Start the transmit process
			      C ;;	  in   eax, dx
			      C ;;	  or   eax, CR6_M_ST	 ;;(00002000h)
			      C ;;	  call PortCR6Write
			      C ;;++, 2000.2.16
			      C ;;	mov	eax, PortConfigCR6
			      C ;;	or	eax, CR6_M_TXSC
			      C ;;	mov	eax, PortConfigCR6
			      C ;;	call	PortCR6Write
			      C ;;++
			      C 
 0DAA  2E: A1 0C34 R	      C 	mov  ax, p_XmtRingVirt
 0DAE  2E: A3 0C3E R	      C 	mov  XmtCurrentDescriptor, ax	;    Initialize current descriptor
			      C 
 0DB2  5A		      C 	pop  dx
 0DB3  66| 58		      C 	pop  eax
 0DB5  C3		      C 	ret
 0DB6			      C XmtEnable ENDP
			      C 
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Page 5 - 1


			      C 	PAGE
			      C ;--------------------------------------------------------------------+
			      C ; Name : XmtGetSetupBuffer
			      C ;
			      C ; Description:
			      C ; This function returns a virtual NEAR pointer to the transmit buffer pointed
			      C ; to by XmtCurrentDescriptor. The calling agent builds a DM9100 setup
			      C ; frame in the buffer, and eventually calls XmtSendSetupFrame to transmit the
			      C ; setup frame to the DM9100. Clearly, since this routine returns a
			      C ; pointer based on XmtCurrentDescriptor, the XmtCurrentDescriptor cannot be
			      C ; allowed to  change from the time the buffer is allocated to the time
			      C ; XmtSendSetupFrame is called. It is the calling agent's responsibility to
			      C ; ensure the system interrupts are disabled from just before XmtGetSetupBuffer
			      C ; is called, until the time XmtSendSetupFrame returns.
			      C ;
			      C ; Enter : None
			      C ;
			      C ; Return : AX -> Point to setup frame buffer.
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C 		   ALIGN  4
			      C 		   PUBLIC XmtGetSetupBuffer
 0DB8			      C XmtGetSetupBuffer  PROC  NEAR
 0DB8  9C		      C 	pushf
 0DB9  FA		      C 	cli
 0DBA  56		      C 	push si
 0DBB  2E: 8B 36 0C3E R	      C 	mov  si, XmtCurrentDescriptor
 0DC0  8B 44 10		      C 	mov  ax, [si].XMT_DESCRIPTOR.p_XmtBuffer
 0DC3  5E		      C 	pop  si
 0DC4  9D		      C 	popf
 0DC5  C3		      C 	ret
 0DC6			      C XmtGetSetupBuffer  ENDP
			      C 
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Page 6 - 1


			      C 	PAGE
			      C ;--------------------------------------------------------------------+
			      C ; Name : XmtSendSetupFrame
			      C ;
			      C ; Description:
			      C ; This routine transmits the XmtCurrentDescriptor as a setup frame. This
			      C ; routine assumes that the setup frame has alread been built into the
			      C ; buffer associated with the XmtCurrentDescriptor.
			      C ;
			      C ; Enter : None
			      C ;
			      C ; Return : carry set if setup packet did not complete
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C 		   ALIGN  4
			      C 		   PUBLIC  XmtSendSetupFrame
 0DC8			      C XmtSendSetupFrame  PROC  NEAR
			      C 
 0DC8  FA		      C 	cli
 0DC9  FC		      C 	cld
			      C 
 0DCA  66| 50		      C 	push  eax
 0DCC  66| 53		      C 	push  ebx
 0DCE  52		      C 	push  dx
 0DCF  56		      C 	push  si
			      C 
			      C ;-- setup transmit descriptor for setup frame
 0DD0  2E: 8B 36 0C3E R	      C 	mov	si, XmtCurrentDescriptor	; descriptor for this frame
 0DD5  2E: 89 36 0C26 R	      C 	mov	NextTxPollPtr, si
 0DDA  66| 8B 44 04	      C 	mov	eax, [si].XMT_DESCRIPTOR.TDES1	; field for its previous frame
 0DDE  66| 25 01000000	      C 	and	eax, TDES1_M_CE 		; keep only the TER bit
 0DE4  66| 0D 08000000	      C 	or	eax, TDES1_M_SETF		; Assert the Setup Packet bit
 0DEA  B8 00C0		      C 	mov	ax, HW_K_SETUP_FRAME_SIZE	; Set size to HW_K_SETUP_FRAME_SIZE
 0DED  66| 89 44 04	      C 	mov	[si].XMT_DESCRIPTOR.TDES1, eax	; Write TDES1
 0DF1  66| C7 04 80000000     C 	mov	[si].XMT_DESCRIPTOR.TDES0, TDES0_M_OWN ; Set ownership to 9102/9100
			      C 
			      C ;-- start the transmit process
			      C ;;-+, 2000.2.16, hu-tiong
			      C ;	mov	dx, p_CR6
			      C ;	in	eax, dx
			      C ;	or	eax, CR6_M_TXSC     ;;(00002000h)
 0DF8  66| 2E: A1 1878 R      C 	mov	eax, PortConfigCR6
 0DFD  66| 0D 00002000	      C 	or	eax, CR6_M_TXSC
 0E03  66| 2E: A3 1878 R      C 	mov	PortConfigCR6, eax
			      C ;;-+
 0E08  E8 1311		      C 	call	PortCR6Write
			      C 
			      C ;-- kick the transmit poll demand
 0E0B  2E: 8B 16 245F R	      C 	mov   dx, p_CR1 		; Transmit pooling
 0E10  66| B8 00000001	      C 	mov   eax,1
 0E16  66| EF		      C 	out   dx, eax			; Send the frame
			      C 
 0E18  8B 44 12		      C 	mov   ax, [si].XMT_DESCRIPTOR.p_XmtNext
 0E1B  2E: A3 0C3E R	      C 	mov   XmtCurrentDescriptor, ax	 ; Update XmtCurrentDescriptor
			      C 
 0E1F  2E: A3 0C26 R	      C 	mov	NextTxPollPtr, ax
			      C 
 0E23  51		      C 	push  cx
 0E24  B9 FFFF		      C 	mov   cx, 0FFFFh		; a long loop, but not forever
 0E27			      C xssf_wait:				; if this fails, bind will fail on its own
 0E27  66| F7 04 80000000     C 	test  [si].XMT_DESCRIPTOR.TDES0, TDES0_M_OWN ; setup processing done?
 0E2E  74 03		      C 	je    xssf_loop_done
 0E30  E2 F5		      C 	loop  xssf_wait 		; loop if not yet
 0E32  F9		      C 	stc				; set carry if if there's an error
 0E33			      C xssf_loop_done:
 0E33  59		      C 	pop   cx
			      C 
 0E34  5E		      C 	pop   si
 0E35  5A		      C 	pop   dx
 0E36  66| 5B		      C 	pop   ebx
 0E38  66| 58		      C 	pop   eax
			      C 
 0E3A  C3		      C 	ret
 0E3B			      C XmtSendSetupFrame  ENDP
			      C 
			      C ;--------------------------------------------------------------------+
			      C ; Name : XmtSendDummyFrame
			      C ;
			      C ; Description: Send a dummy frmae for the next setup frame.
			      C ;
			      C ; Enter : None.
			      C ;
			      C ; Return :
			      C ;		error: carry flag set.
			      C ;	    non-error: carry flag claer.
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Page 7 - 1


			      C 	PAGE
			      C ;		    ALIGN  4
			      C 		ALIGN
			      C 		   PUBLIC  XmtSendDummyFrame
 0E40			      C XmtSendDummyFrame  PROC  NEAR
			      C 
 0E40  FA		      C 	cli
 0E41  FC		      C 	cld
			      C 
 0E42  66| 50		      C 	push  eax
 0E44  66| 53		      C 	push  ebx
 0E46  52		      C 	push  dx
 0E47  56		      C 	push  si
			      C 
			      C 
 0E48  2E: 8B 36 0C3E R	      C 	mov   si, XmtCurrentDescriptor	 ; descriptor for this frame
 0E4D  66| 8B 44 04	      C 	mov   eax, [si].XMT_DESCRIPTOR.TDES1 ; field for its previous frame
 0E51  66| 25 01000000	      C 	and	eax, TDES1_M_DUMMY
			      C 
 0E57  66| 89 44 04	      C 	mov	[si].XMT_DESCRIPTOR.TDES1, eax		;; Set Dummy frame info.
 0E5B  66| C7 04 80000000     C 	mov   [si].XMT_DESCRIPTOR.TDES0, TDES0_M_OWN ; Set ownership to 90100
			      C 
 0E62  2E: 8B 16 245F R	      C 	mov   dx, p_CR1        ;; Transmit pooling
 0E67  66| B8 00000001	      C 	mov   eax,1
 0E6D  66| EF		      C 	out   dx, eax			 ; Send the frame
			      C 
 0E6F  8B 44 12		      C 	mov   ax, [si].XMT_DESCRIPTOR.p_XmtNext
 0E72  2E: A3 0C3E R	      C 	mov   XmtCurrentDescriptor, ax	 ; Update XmtCurrentDescriptor
			      C 
 0E76  51		      C 	push  cx
 0E77  B9 00FF		      C 	mov   cx, 0FFh		      ; a long loop, but not forever
 0E7A			      C xsdf_wait:			    ; if this fails, bind will fail on its own
 0E7A  66| F7 04 80000000     C 	test  [si].XMT_DESCRIPTOR.TDES0, TDES0_M_OWN ; setup processing done?
 0E81  74 B0		      C 	jz    xssf_loop_done
 0E83  E2 F5		      C 	loop  xsdf_wait 		; loop if not yet
 0E85  F9		      C 	stc				; set carry if if there's an error
			      C 
 0E86			      C xsdf_loop_done:
 0E86  59		      C 	pop   cx
			      C 
 0E87  5E		      C 	pop   si
 0E88  5A		      C 	pop   dx
 0E89  66| 5B		      C 	pop   ebx
 0E8B  66| 58		      C 	pop   eax
			      C 
 0E8D  C3		      C 	ret
 0E8E			      C XmtSendDummyFrame  ENDP
			      C 
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Page 8 - 1


			      C 	PAGE
			      C ;--------------------------------------------------------------------+
			      C ; Name : send_pkt
			      C ;
			      C ; Description:
			      C ; This function is called by the protocol stack in order to transmit frames.
			      C ;
			      C ; Enter :
			      C ;	     DS:SI -> Caller's Buffer.
			      C ;		CX -> Bytes length.
			      C ;
			      C ; Return :
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ;
			      C ;---------------------------------------------------------------------+
			      C 
			      C EXTRN	bytes_out : DWORD
			      C EXTRN	packets_out : DWORD
			      C EXTRN	errors_out : DWORD
			      C ;;EXTRN   TxHangCounter : DWORD
			      C 
			      C 	ALIGN  4
			      C 	PUBLIC send_pkt
 0E90			      C send_pkt   PROC NEAR
 0E90  FC		      C 	cld				; Clear direction flag
			      C 
 0E91  53		      C 	push	bx
 0E92  1E		      C 	push	ds
			      C 
 0E93			      C tc_begin:
 0E93  8C C8		      C 	mov	ax, cs			; DS = CS, Change DS to local segment.
 0E95  8E D8		      C 	mov	ds, ax
			      C 
			      C ;-- Check if transmit enabled?
			      C ;------------------------------------------------------------------------
 0E97  2E: 83 3E 0C2C R	      C 	cmp	XmtState, 1		; If (transmit not enabled)
       01
 0E9D  0F 85 00B0	      C 	jne	xmt_fail		;    return (CANT_SEND)
			      C 
 0EA1  2E: 8B 1E 0C3E R	      C 	mov	bx, XmtCurrentDescriptor; BX -> current tx descriptor
			      C 
			      C ;-- Check if any buffer available?
			      C ;------------------------------------------------------------------------
 0EA6			      C tc_owner_check:
 0EA6  66| 8B 07	      C 	mov	eax, [bx].XMT_DESCRIPTOR.TDES0
 0EA9  66| A9 80000000	      C 	test	eax, TDES0_M_OWN	; if (We don't own current descriptor)
 0EAF  0F 85 00A5	      C 	jnz	out_of_resource_exit	;    return (OUT_OF_RESOURCE)
			      C 
 0EB3			      C tc_buffer_available:
			      C ;-- Check if any error occurred during previous transmition?
			      C ;------------------------------------------------------------------------
 0EB3  66| A9 00008000	      C 	test	eax, TDES0_M_ES 	; Check the transmit Error Summary
 0EB9  74 06		      C 	jz	xmt_no_err
			      C 
 0EBB  66| 2E: FF 06 0000 E   C 	inc	errors_out		; For statistics
			      C 
 0EC1			      C xmt_no_err:
 0EC1  8B 7F 10		      C 	mov	di, [bx].XMT_DESCRIPTOR.p_XmtBuffer ; index into driver buffer
			      C 					; for rest of routine
			      C 
			      C COMMENT %
			      C 	cmp	cx, GIANT		; Is this packet too large
			      C 	ja	send_pkt_toobig
			      C %
 0EC4  83 F9 3C		      C 	cmp	cx, RUNT
 0EC7  73 03		      C 	jnb	tc_copy
 0EC9  B9 003C		      C 	mov	cx, RUNT
			      C 
 0ECC			      C tc_copy:
 0ECC  66| 2E: 01 0E 0000 E   C 	add	bytes_out, ecx		; For statistics
 0ED2  66| 2E: FF 06 0000 E   C 	inc	packets_out
			      C 
 0ED8  2E: 89 0E 0C2E R	      C 	mov	XmtFrameSize, cx
			      C 
			      C ;-- Copy data to transmit buffer
			      C ;------------------------------------------------------------------------
 0EDD  8C D8		      C 	mov	ax, ds
 0EDF  8E C0		      C 	mov	es, ax			; Get our segment into ES
 0EE1  1F		      C 	pop	ds			; Change DS to Procotol's segment
 0EE2  1E		      C 	push	ds
			      C 
 0EE3  8B C1		      C 	mov	ax, cx			;      Copy Data
 0EE5  83 E0 03		      C 	and	ax, 3
 0EE8  C1 E9 02		      C 	shr	cx, 2
 0EEB  F3/ 66| A5	      C 	rep	movsd
 0EEE  8B C8		      C 	mov	cx, ax
 0EF0  F3/ A4		      C 	rep	movsb
			      C 
 0EF2			      C tc_post_frame:
			      C ;-- Setup Tx Descriptor
			      C ;------------------------------------------------------------------------
 0EF2  8C C8		      C 	mov	ax, cs
 0EF4  8E D8		      C 	mov	ds, ax			; Cahnge DS to Local segment.
			      C 
 0EF6  2E: 8B 36 0C3E R	      C 	mov	si, XmtCurrentDescriptor	; descriptor for this frame
 0EFB  66| 8B 44 04	      C 	mov	eax, [si].XMT_DESCRIPTOR.TDES1	; field for its previous frame
			      C ;;-+, 980415, Hu-Tiong
			      C ;;	and	eax, TDES1_M_EOR		; keep only the TER bit
 0EFF  66| 25 01000000	      C 	and	eax, TDES1_M_CE 		; keep only the CE bit
			      C ;;-+
 0F05  66| 0D 60000000	      C 	or	eax, (TDES1_M_BD OR TDES1_M_ED) ; first and last descr. for frame
 0F0B  2E: A1 0C2E R	      C 	mov	ax, XmtFrameSize		; new frame's size in BUFFER_1_SIZE
 0F0F  66| 0D 80000000	      C 	or	eax, TDES1_M_CI 		; Interrupt on complete
 0F15  66| 89 44 04	      C 	mov	[si].XMT_DESCRIPTOR.TDES1, eax	; TDES1 for this frame
			      C 
			      C ;
			      C ; If the packet is long enough that the driver should generate the CRC, call
			      C ; CalcCRC to do so and disable DM9100 CRC generation.
			      C ;
 0F19  2E: 3B 06 0C30 R	      C 	cmp   ax, XmtCRCThreshold	; long enough for SW CRC generation?(1515)
 0F1E  72 15		      C 	jb    xmt_post			; branch if not
			      C 
 0F20  8B C8		      C 	mov   cx, ax			; CX = Length in bytes - CRC
 0F22  8B 74 10		      C 	mov   si, [si].XMT_DESCRIPTOR.p_XmtBuffer ; DS:SI points to frame
 0F25  E8 0778		      C 	call  CalcCRC
 0F28  2E: 8B 36 0C3E R	      C 	mov   si, XmtCurrentDescriptor	; restore pointer to descriptor
 0F2D  66| 81 44 04	      C 	add   [si].XMT_DESCRIPTOR.TDES1, (TDES1_M_CAD + 4)
       04000004
			      C 					; suppress hardware CRC generation,
			      C 					; add CRC's length to frame size
			      C ;-- Transmit the packet
			      C ;------------------------------------------------------------------------
 0F35			      C xmt_post:
 0F35  8B 44 12		      C 	mov	ax, [si].XMT_DESCRIPTOR.p_XmtNext
 0F38  2E: A3 0C3E R	      C 	mov	XmtCurrentDescriptor, ax  ; Update XmtCurrentDescriptor
			      C 
			      C ;-- decrement free transmit descriptor count
 0F3C  2E: FF 06 0C28 R	      C 	inc	TxPendingCnt
			      C 
			      C ;-- check if oney one patcket pending
 0F41  2E: 83 3E 0C28 R	      C 	cmp	TxPendingCnt, 1
       01
 0F47  75 03		      C 	jne	xmt_done
			      C 
 0F49  E8 0014		      C 	call	XmtMain
			      C 
 0F4C			      C xmt_done:
 0F4C  1F		      C 	pop	ds
 0F4D  5B		      C 	pop	bx
 0F4E  F8		      C 	clc
 0F4F  FB		      C 	sti
 0F50  C3		      C 	ret
			      C 
			      C 	PUBLIC xmt_fail
 0F51			      C xmt_fail:
 0F51  F9		      C 	stc
 0F52  B6 0C		      C 	mov	dh, CANT_SEND	   ;; Return status
 0F54  1F		      C 	pop	ds
 0F55  5B		      C 	pop	bx
 0F56  FB		      C 	sti
 0F57  C3		      C 	ret
			      C 
			      C 
 0F58			      C send_pkt_toobig:
 0F58			      C out_of_resource_exit:
 0F58  1F		      C 	pop	ds
 0F59  5B		      C 	pop	bx
 0F5A  B6 09		      C 	mov	dh, NO_SPACE
 0F5C  F9		      C 	stc
 0F5D  FB		      C 	sti
 0F5E  C3		      C 	ret
			      C 
 0F5F			      C send_pkt   ENDP
			      C 
			      C 
			      C ;--------------------------------------------------------------------+
			      C ; Name : XmtMain
			      C ;
			      C ; Description:
			      C ;		This function process transmit complete interrupt for one
			      C ;	packet transmit.
			      C ;		Currently, used by CUT6.
			      C ;
			      C ; Enter :
			      C ;
			      C ; Return :
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C 
			      C 	ALIGN	4
			      C 	PUBLIC	XmtMain
 0F60			      C XmtMain PROC	NEAR
 0F60  66| 50		      C 	push	eax
 0F62  52		      C 	push	dx
 0F63  56		      C 	push	si
 0F64  57		      C 	push	di
			      C 
			      C ;-- disable system interrupt
 0F65  FA		      C 	cli
			      C 
 0F66			      C check_tx_pending:
			      C ;;-- check if oney one patcket pending
			      C ;	 cmp	 TxPendingCnt, 1
			      C ;	 jne	 xm_exit
			      C 
			      C ;-- Clear CR5's TXDU bit
 0F66  2E: 8B 16 2467 R	      C 	mov	dx, p_CR5		; Prepare DX for clearing CR5 TU
 0F6B  66| B8 00000004	      C 	mov	eax, CR5_M_TXDU 	; Prepare EAX for clearing CR5 TU
 0F71  66| EF		      C 	out	dx, eax 		; Clear CR5 TU bit
			      C 
 0F73  2E: 8B 36 0C26 R	      C 	mov	si, NextTxPollPtr
			      C 
			      C 	;-- set ownership to 9102/9100
 0F78  66| C7 04 80000000     C 	mov	[si].XMT_DESCRIPTOR.TDES0, TDES0_M_OWN
			      C 
			      C 	;-- kick the transmit poll demand
 0F7F  2E: 8B 16 245F R	      C 	mov	dx, p_CR1
 0F84  66| B8 00000001	      C 	mov	eax,1
 0F8A  66| EF		      C 	out	dx, eax 		; Off it goes! Kick the tx poll demand
			      C 
			      C ;	 test	 [si].XMT_DESCRIPTOR.TDES0, TDES0_M_OWN ;check if already sent
			      C ;	 jnz	 txok			   ; Not sent
			      C ;
			      C ;	 mov   TxHangCounter, 0
			      C ;txok:
			      C 
			      C 
 0F8C			      C xm_exit:
 0F8C  FB		      C 	sti
 0F8D  5F		      C 	pop	di
 0F8E  5E		      C 	pop	si
 0F8F  5A		      C 	pop	dx
 0F90  66| 58		      C 	pop	eax
 0F92  C3		      C 	ret
			      C 
 0F93			      C XmtMain ENDP
			      C 
			      C ;--------------------------------------------------------------------+
			      C ; Name : AddMulticastAddress
			      C ;
			      C ; Description:
			      C ; This function attempts to add a multicast address to the Adapter CAM. The
			      C ; adapter automatically performs destination address filtering based on the
			      C ; contents of the CAM, so it is not necessary for the driver to do any such
			      C ; filtering. The driver does maintain a table of multicast addresses, in
			      C ; order to check for duplicate addresses, and to clean up the adapter CAM
			      C ; in the CloseAdapter function.
			      C ;
			      C ; Enter :
			      C ;	     ES:SI -> New address list.
			      C ;		BX = Number of address to added.
			      C ;
			      C ; Return :
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C 		    PUBLIC AddMulticastAddress
 0F93			      C AddMulticastAddress PROC  NEAR
 0F93  56		      C 	push si
 0F94  57		      C 	push di
 0F95  9C		      C 	pushf
			      C 
 0F96  BF 248C R	      C 	mov  di, OFFSET MulticastTable
 0F99  2E: A1 248E R	      C 	mov  ax, MulticastTable.table_current ; Convert current # of entries
 0F9D  C1 E0 04		      C 	shl  ax, 4			; in the table to an offset to the next
 0FA0  83 C0 04		      C 	add  ax, 4			; free slot.
 0FA3  03 F8		      C 	add  di, ax
			      C 
 0FA5  1E		      C 	push ds 			; Save our DS
			      C 
 0FA6  8B CB		      C 	mov	cx, bx
 0FA8			      C ama_vacancy:
 0FA8  57		      C 	push	di
 0FA9  E8 002E		      C 	call MulticastTableSearch	   ; Search for address pointed to by ES:SI
 0FAC  83 F8 FF		      C 	cmp  ax, -1			; If if ain't in there, continue
 0FAF  74 05		      C 	je     ama_not_found
 0FB1  83 C6 06		      C 	add	si, 6
 0FB4  E2 F2		      C 	loop	ama_vacancy
 0FB6			      C ama_not_found:
			      C ;
			      C ; At this point DS:SI points to the address to add, and ES:DI points to the
			      C ; free slot in the table.
			      C ;
 0FB6  1E		      C 	push	ds
 0FB7  8C D8		      C 	mov  ax, ds
			      C 	movseg	   ds, es
 0FB9  06		     1C 	push	es
 0FBA  1F		     1C 	pop	ds
 0FBB  8E C0		      C 	mov  es, ax			; ES = DS & DS = ES
 0FBD  FC		      C 	cld
			      C 
 0FBE  A5		      C 	movsw				; Stuff the address into the table
 0FBF  A5		      C 	movsw
 0FC0  A5		      C 	movsw
			      C 
 0FC1  1F		      C 	pop	ds
 0FC2  2E: FF 06 248E R	      C 	inc  MulticastTable.table_current ; Update current number of entries
 0FC7  5F		      C 	pop	di
 0FC8  83 C7 10		      C 	add	di, 16
 0FCB  4B		      C 	dec	bx
 0FCC  75 DA		      C 	jnz	 ama_vacancy
			      C 
 0FCE  1F		      C 	pop  ds 			; Restore our data segment
			      C ;
			      C ; If the adapter is open, give it the new info
			      C ;
 0FCF  E8 0FE6		      C 	call PortUpdateReceiveFilter	     ; clue the adapter in on all this
 0FD2  73 01		      C 	jnc  ama_success		     ; did it succeed?
 0FD4  F9		      C 	stc
			      C 
 0FD5			      C ama_success:
 0FD5  F8		      C 	clc
 0FD6			      C ama_exit:
 0FD6  9D		      C 	popf
 0FD7  5F		      C 	pop  di
 0FD8  5E		      C 	pop  si
 0FD9  C3		      C 	ret
 0FDA			      C AddMulticastAddress ENDP
			      C 
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Page 9 - 1


			      C 	PAGE
			      C ;--------------------------------------------------------------------+
			      C ; Name : MulticastTableSearch
			      C ;
			      C ; Description:
			      C ; This function searches the MCast Table for the given address. If
			      C ; the address is found, the entry number is is returned, else -1 is returned.
			      C ; Since the MCast Table is usually small (16 entries max), and address
			      C ; table operations are not time critical, a linear search is used. Bogus, I
			      C ; know, but hey, it's small on code size, and speed just don't matter
			      C ; at this point in the driver code.
			      C ;
			      C ; Enter :
			      C ;	     ES:SI -> New address list.
			      C ;
			      C ; Return :
			      C ;    Status in AX (Entry Number or -1=Failure)
			      C ;    The entry number that AX returns starts counting at Entry Number 0.
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ; Algorithm:
			      C ; BEGIN
			      C ;    CX = number of entries in NDIS MCast Table
			      C ;    if (CX == 0)
			      C ;	return(-1) Not Found
			      C ;    Point DI to the first entry in the NDIS MCast Table
			      C ;    do
			      C ;    {
			      C ;	if (WORD at ES:[SI].0 == DWORD at DS:[DI].0)
			      C ;	  if (WORD at ES:[SI].2 == DWORD at DS:[DI].2)
			      C ;	    if (WORD at ES:[SI].4 == WORD at DS:[DI].4)
			      C ;	       return(0); Found it
			      C ;	DI += 16
			      C ;    }
			      C ;    while (--CX != 0)
			      C ;    return(-1) NotFound
			      C ; END
			      C ;
			      C ;---------------------------------------------------------------------+
			      C 		   PUBLIC MulticastTableSearch
 0FDA			      C MulticastTableSearch  PROC  NEAR
 0FDA  57		      C 	push di
 0FDB  51		      C 	push cx
 0FDC  53		      C 	push bx
			      C 
 0FDD  2E: 8B 0E 248E R	      C 	mov  cx, MulticastTable.table_current
 0FE2  83 F9 00		      C 	cmp  cx, 0
 0FE5  74 29		      C 	je   SHORT snm_not_found_exit
 0FE7  BF 2490 R	      C 	mov  di, OFFSET MulticastTable + 4
 0FEA  B8 0000		      C 	mov  ax, 0
			      C ;
			      C ; ES:SI points to the address you're searching for
			      C ; DS:DI points to the entries in the MulticastTable
			      C ;
 0FED			      C snm_loop:
 0FED  26: 8B 1C	      C 	mov  bx, WORD PTR ES:0[SI]
 0FF0  3B 1D		      C 	cmp  bx, WORD PTR DS:0[DI]
 0FF2  75 14		      C 	jne  SHORT snm_check_next
 0FF4  26: 8B 5C 02	      C 	mov  bx, WORD PTR ES:2[SI]
 0FF8  3B 5D 02		      C 	cmp  bx, WORD PTR DS:2[DI]
 0FFB  75 0B		      C 	jne  SHORT snm_check_next
 0FFD  26: 8B 5C 04	      C 	mov  bx, WORD PTR ES:4[SI]
 1001  3B 5D 04		      C 	cmp  bx, WORD PTR DS:4[DI]
 1004  75 02		      C 	jne  SHORT snm_check_next
 1006  EB 0B		      C 	jmp  SHORT snm_exit
 1008			      C snm_check_next:
 1008  83 C7 10		      C 	add  di, 16
 100B  83 C0 01		      C 	add  ax, 1
 100E  E2 DD		      C 	loop snm_loop
 1010			      C snm_not_found_exit:
 1010  B8 FFFF		      C 	mov  ax, -1
 1013			      C snm_exit:
 1013  5B		      C 	pop bx
 1014  59		      C 	pop cx
 1015  5F		      C 	pop  di
 1016  C3		      C 	ret
 1017			      C MulticastTableSearch  ENDP
			      C  
			      C 
			      C include rcv.asm
			      C ;*****************************************************************************
			      C ;* Name : RCV.ASM
			      C ;*
			      C ;* All rights reserved by DAVICOM, 1996
			      C ;*
			      C ;* Description : Initialize, reset, enable & free descriptor for the
			      C ;*		receiption frame.
			      C ;*
			      C ;* Functions :
			      C ;*	. RcvInit
			      C ;*	. RcvReset
			      C ;*	. RcvDisable
			      C ;*	. RcvMain
			      C ;*	. RcvPostFreeDescriptor
			      C ;*	. RcvEnable
			      C ;*
			      C ;* Author : Spenser Tsai
			      C ;*
			      C ;* Date : 05/17/96
			      C ;*
			      C ;* Change Notes :
			      C ;* Date - Modifier
			      C ;*     Cause :
			      C ;*  Modified :
			      C ;*    Result :
			      C ;
			      C ; Maintainers:
			      C ;
			      C ; John H.T. Ho		htho
			      C ;
			      C ;
			      C ; Date	     Modfier.	Modification Descriptions
			      C ; ---------- ---------- ------------------------------------------
			      C ; 2000.2.16	htho	dynamicaly keep a image of CR6 in [PortConfigCR6]
			      C ;
			      C ;*
			      C ;*****************************************************************************
			      C .386
			      C include dm9100.inc
			      C 
 = 05EA			      C FRAME_MTU         EQU  1514
			      C 
			      C ;;include hw.inc
			      C include hardware.asd
			      C 
			      C ; This file contains the hardware constants for addressing the UM9100
			      C ; chip on PCI platforms.
			      C ;
			      C 
			      C ;; DEC
			      C ;;PCIID_DM9100_DEVICE_ID	 EQU 00009h
			      C ;;PCIID_VENDOR_ID		 EQU 01011h
			      C 
			      C ;; DAVICOM
			      C ;;PCIID_DM9100_DEVICE_ID	 EQU 09100h
			      C ;;PCIID_VENDOR_ID		 EQU 01060h
			      C 
 = 9102			      C PCIID_DM9102_DEVICE_ID		EQU	9102h
			      C 
 = 9100			      C PCIID_DM9100_DEVICE_ID	       EQU 09100h
 = 1282			      C PCIID_VENDOR_ID 	       EQU 01282h
			      C 
 = 9009			      C PCIID_DM9009_DEVICE_ID		EQU 09009H
			      C 
 = 0000			      C DM9100_CHIP			EQU 0
 = 0001			      C DM9009_CHIP			EQU 1
 = 0002			      C DM9102_CHIP			EQU 2
 = 000A			      C DC21X4_CHIP			EQU 10
			      C 
			      C 
			      C ; Hardware offsets for PCI based Adapter
			      C ;
 = 0000			      C HW_K_REG_CR0		   EQU 000h
 = 0008			      C HW_K_REG_CR1		   EQU 008h
 = 0010			      C HW_K_REG_CR2		   EQU 010h
 = 0018			      C HW_K_REG_CR3		   EQU 018h
 = 0020			      C HW_K_REG_CR4		   EQU 020h
 = 0028			      C HW_K_REG_CR5		   EQU 028h
 = 0030			      C HW_K_REG_CR6		   EQU 030h
 = 0038			      C HW_K_REG_CR7		   EQU 038h
 = 0040			      C HW_K_REG_CR8		   EQU 040h
 = 0048			      C HW_K_REG_CR9		   EQU 048h
 = 0050			      C HW_K_REG_CR10		   EQU 050h
 = 0058			      C HW_K_REG_CR11		   EQU 058h
 = 0060			      C HW_K_REG_CR12		   EQU 060h
 = 0068			      C HW_K_REG_CR13		   EQU 068h
 = 0070			      C HW_K_REG_CR14		   EQU 070h
 = 0078			      C HW_K_REG_CR15		   EQU 078h
			      C 
 = 0000			      C HW_K_REG_PCIID			EQU 00h
 = 0004			      C HW_K_REG_PCICS		     EQU 04h
 = 0008			      C HW_K_REG_PCIRV		     EQU 08h
 = 000C			      C HW_K_REG_PCILT		     EQU 0Ch
 = 0010			      C HW_K_REG_PCIIO		     EQU 10h
 = 003C			      C HW_K_REG_PCIINT 	      EQU 3Ch
 = 0040			      C HW_K_REG_PCIUSR 	      EQU 40h
			      C 
			      C ;
			      C ; Bit mask definitions for CSRs
			      C ;
 = FFF80000		      C CR0_M_RESERVED		       EQU 0FFF80000h
 = 00060000		      C CR0_M_TXAP			EQU 000060000h
 = 00010000		      C CR0_M_DAS		       EQU 000010000h
 = C000			      C CR0_M_CA		      EQU 00000C000h
 = 3F00			      C CR0_M_BL		      EQU 000003F00h
 = 0080			      C CR0_M_RESERVED07		      EQU 000000080h
 = 007C			      C CR0_M_DGW		       EQU 00000007Ch
 = 0002			      C CR0_M_BA		      EQU 000000002h
 = 0001			      C CR0_M_SR		      EQU 000000001h
 = 0013			      C CR0_V_RESERVED		       EQU 19
 = 0011			      C CR0_V_TXAP			EQU 17
 = 0010			      C CR0_V_DAS		       EQU 16
 = 000E			      C CR0_V_CA		      EQU 14
 = 0008			      C CR0_V_BL		      EQU 8
 = 0007			      C CR0_V_RESERVED07		      EQU 7
 = 0002			      C CR0_V_DGW		       EQU 2
 = 0001			      C CR0_V_BA		      EQU 1
 = 0000			      C CR0_V_SR		      EQU 0
			      C 
 = 0000			      C CR0_K_TXAP_NONE 		EQU 0
 = 0001			      C CR0_K_TXAP_200_USEC		EQU 1
 = 0002			      C CR0_K_TXAP_800_USEC		EQU 2
 = 0003			      C CR0_K_TXAP_1600_USEC		EQU 3
 = 0004			      C CR0_K_TXAP_128_USEC		EQU 4
			      C 
 = 0000			      C CR0_K_CA_0LW		      EQU 0
 = 0001			      C CR0_K_CA_8LW		      EQU 1
 = 0002			      C CR0_K_CA_16LW		      EQU 2
 = 0003			      C CR0_K_CA_32LW		      EQU 3
			      C 
 = 0000			      C CR0_K_BL_0LW		      EQU 0
 = 0001			      C CR0_K_BL_1LW		      EQU 1
 = 0002			      C CR0_K_BL_2LW		      EQU 2
 = 0004			      C CR0_K_BL_4LW		      EQU 4
 = 0008			      C CR0_K_BL_8LW		      EQU 8
 = 0010			      C CR0_K_BL_16LW		      EQU 16
 = 0020			      C CR0_K_BL_32LW		      EQU 32	  ; currently invalid
			      C 
 = 0000			      C CR0_K_DGW_0LW		       EQU 0
 = 0001			      C CR0_K_DGW_1LW		       EQU 1
 = 0002			      C CR0_K_DGW_2LW		       EQU 2
 = 0003			      C CR0_K_DGW_3LW		       EQU 3
 = 0004			      C CR0_K_DGW_4LW		       EQU 4
			      C 
 = FFFFFFFE		      C CR1_M_RESERVED		       EQU 0FFFFFFFEh
 = 0001			      C CR1_M_TPD		       EQU 000000001h
 = 0001			      C CR1_V_RESERVED		       EQU 1
 = 0000			      C CR1_V_TPD		       EQU 0
			      C 
 = FFFFFFFE		      C CR2_M_RESERVED		       EQU 0FFFFFFFEh
 = 0001			      C CR2_M_RPD		       EQU 000000001h
 = 0001			      C CR2_V_RESERVED		       EQU 1
 = 0000			      C CR2_V_RPD		       EQU 0
			      C 
 = FC000000		      C CR5_M_RESERVED			EQU 0FC000000h
 = 03800000		      C CR5_M_SBEB			EQU 003800000h
 = 00700000		      C CR5_M_TXS			EQU 000700000h
 = 000E0000		      C CR5_M_RXS			EQU 0000E0000h
 = 00010000		      C CR5_M_NIS			EQU 000010000h
 = 8000			      C CR5_M_AIS			EQU 000008000h
 = 4000			      C CR5_M_RESERVED_2		EQU 000004000h
 = 2000			      C CR5_M_SBE			EQU 000002000h
 = 0800			      C CR5_M_GPT			EQU 000000800h
 = 0400			      C CR5_M_ETI			EQU 000000400h
 = 0200			      C CR5_M_RXWT			EQU 000000200h
 = 0100			      C CR5_M_RXPS			EQU 000000100h
 = 0080			      C CR5_M_RXDU			EQU 000000080h
 = 0040			      C CR5_M_RXCI			EQU 000000040h
 = 0020			      C CR5_M_TXFU			EQU 000000020h
 = 0010			      C CR5_M_RESERVED_3		EQU 000000010h
 = 0008			      C CR5_M_TXJT			EQU 000000008h
 = 0004			      C CR5_M_TXDU			EQU 000000004h
 = 0002			      C CR5_M_TXPS			EQU 000000002h
 = 0001			      C CR5_M_TXCI			EQU 000000001h
 = 001A			      C CR5_V_RESERVED			EQU 26
 = 0017			      C CR5_V_SBEB			EQU 23
 = 0014			      C CR5_V_TXS			EQU 20
 = 0011			      C CR5_V_RXS			EQU 17
 = 0010			      C CR5_V_NIS			EQU 16
 = 000F			      C CR5_V_AIS			EQU 15
 = 000E			      C CR5_V_RESERVED_2		EQU 14
 = 000D			      C CR5_V_SBE			EQU 13
 = 000B			      C CR5_V_GPT			EQU 11
 = 000A			      C CR5_V_ETI			EQU 10
 = 0009			      C CR5_V_RXWT			EQU 9
 = 0008			      C CR5_V_RXPS			EQU 8
 = 0007			      C CR5_V_RXDU			EQU 7
 = 0006			      C CR5_V_RXCI			EQU 6
 = 0005			      C CR5_V_TXFU			EQU 5
 = 0004			      C CR5_V_RESERVED_3		EQU 4
 = 0003			      C CR5_V_TXJT			EQU 3
 = 0002			      C CR5_V_TXDU			EQU 2
 = 0001			      C CR5_V_TXPS			EQU 1
 = 0000			      C CR5_V_TXCI			EQU 0
			      C 
 = 0000			      C CR5_K_SBEB_PARITY_ERROR 	EQU 0
 = 0001			      C CR5_K_SBEB_MASTER_ABORT 	EQU 1
 = 0002			      C CR5_K_SBEB_TARGET_ABORT 	EQU 2
			      C 
 = 0000			      C CR5_K_TXS_STOPPED		EQU 0
 = 0001			      C CR5_K_TXS_RUN_DESC_ACCESS	EQU 1
 = 0002			      C CR5_K_TXS_RUN_SETUP_MOVE	EQU 2
 = 0003			      C CR5_K_TXS_RUN_MOVE_DATA 	EQU 3
 = 0004			      C CR5_K_TXS_RUN_WRITE_OWNER	EQU 4
 = 0005			      C CR5_K_TXS_RUN_WAIT		EQU 5
 = 0006			      C CR5_K_TXS_RUN_WRITE_STATUS	EQU 6
 = 0007			      C CR5_K_TXS_SUSPEND		EQU 7
			      C 
 = 0000			      C CR5_K_RXS_STOPPED		EQU 0
 = 0001			      C CR5_K_RXS_RUN_DESC_ACCESS	EQU 1
 = 0002			      C CR5_K_RXS_RUN_WAIT		EQU 2
 = 0003			      C CR5_K_RXS_RUN_MOVE_DATA 	EQU 3
 = 0004			      C CR5_K_RXS_RUN_WRITE_OWNER	EQU 4
 = 0005			      C CR5_K_RXS_RUN_WRITE_STATUS	EQU 5
 = 0006			      C CR5_K_RXS_SUSPEND		EQU 6
 = 0007			      C CR5_K_RXS_PURGE 		EQU 7
			      C 
 = 02000000		      C CR6_M_DM9009_ALWAYS		EQU 002000000h	;;DM9009 reserved bits
 = 80000000		      C CR6_M_RESERVED1_1		EQU 080000000h	;;Always 1
 = 40000000		      C CR6_M_RXA			EQU 040000000h	;;Reveive All(30)
 = 20000000		      C CR6_M_RESERVED2_1		EQU 020000000h
 = 38000000		      C CR6_M_RESERVED3_0		EQU 038000000h	;;Always 0
 = 04000000		      C CR6_M_RESERVED4_1		EQU 004000000h
 = 01000000		      C CR6_M_SCM			EQU 001000000h	;;Scrambler Mode(24)
 = 00800000		      C CR6_M_MSF			EQU 000800000h	;;MII Symbol Function(23)
 = 00400000		      C CR6_M_TXTM			EQU 000400000h	;;Transmit Threshold Mode(22)
 = 00200000		      C CR6_M_SFT			EQU 000200000h	;;Store and Forward Transmission(21)
 = 00100000		      C CR6_M_STT			EQU 000100000h	;;Shortest Transmit Threshold(20)
 = 00080000		      C CR6_M_HBD			EQU 000080000h	;;HartBit Disable(19)
 = 00040000		      C CR6_M_MSPS			EQU 000040000h	;;MII/SRL Port Select(18)
 = 00020000		      C CR6_M_RESERVED5_0		EQU 000020000h
 = 00010000		      C CR6_M_RESERVED6_0		EQU 000010000h
 = C000			      C CR6_M_TSB			EQU 00000C000h	;;Threshold Setup Bits(15:14)
 = 2000			      C CR6_M_TXSC			EQU 000002000h	;;Transmit Start/stop Command(13)
 = 1000			      C CR6_M_FCM			EQU 000001000h	;;Force Collision Mode(12)
 = 0C00			      C CR6_M_LBM			EQU 000000C00h	;;LookBack Mode(11:10)
 = 0200			      C CR6_M_FDM			EQU 000000200h	;;Full_Duplex Mode(9)
 = 0100			      C CR6_M_ISRW			EQU 000000100h	;;Inhibit Simultaneous Read/Write
 = 0080			      C CR6_M_PAM			EQU 000000080h	;;Pass All Multicast(7)
 = 0040			      C CR6_M_PM			EQU 000000040h	;;Promiscuous Mode(6)
 = 0020			      C CR6_M_RESERVED8_0		EQU 000000020h
 = 0010			      C CR6_M_IAFM			EQU 000000010h	;;Inverse Address Mode(4)
 = 0008			      C CR6_M_PBF			EQU 000000008h	;;Pass Bad Frame(3)
 = 0004			      C CR6_M_HOFM			EQU 000000004h	;;Hash-Only Filtering Mode(2)
 = 0002			      C CR6_M_RXSC			EQU 000000002h	;;Received Start/stop Command(1)
 = 0001			      C CR6_M_HPFM			EQU 000000001h	;;Hash/Perfect Filtering Mode(0)
 = 0018			      C CR6_V_SCM			EQU 24
 = 0017			      C CR6_V_MSF			EQU 23
 = 0016			      C CR6_V_TXTM			EQU 22
 = 0015			      C CR6_V_SFT			EQU 21
 = 0014			      C CR6_V_STT			EQU 20
 = 0013			      C CR6_V_HBD			EQU 19
 = 0012			      C CR6_V_MSPS			EQU 18
 = 000E			      C CR6_V_TSB			EQU 14
 = 000D			      C CR6_V_TXSC			EQU 13
 = 000C			      C CR6_V_FCM			EQU 12
 = 000A			      C CR6_V_LBM			EQU 10
 = 0009			      C CR6_V_FDM			EQU 9
 = 0007			      C CR6_V_PAM			EQU 7
 = 0006			      C CR6_V_PM			EQU 6
 = 0004			      C CR6_V_IAFM			EQU 4
 = 0003			      C CR6_V_PBF			EQU 3
 = 0002			      C CR6_V_HOFM			EQU 2
 = 0001			      C CR6_V_RXSC			EQU 1
 = 0000			      C CR6_V_HPFM			EQU 0
			      C 
 = 0000			      C CR6_K_10MB_TSB_72_BYTES 	EQU 0
 = 0001			      C CR6_K_10MB_TSB_96_BYTES 	EQU 1
 = 0002			      C CR6_K_10MB_TSB_128_BYTES	EQU 2
 = 0003			      C CR6_K_10MB_TSB_160_BYTES	EQU 3
			      C 
 = 0000			      C CR6_K_100MB_TSB_128_BYTES	EQU 0
 = 0001			      C CR6_K_100MB_TSB_256_BYTES	EQU 1
 = 0002			      C CR6_K_100MB_TSB_512_BYTES	EQU 2
 = 0003			      C CR6_K_100MB_TSB_1024_BYTES	EQU 3
			      C 
 = 00280000		      C CR6_K_100MB_INIT	       EQU (CR6_M_HBD) OR (CR6_M_SFT)
			      C 
			      C ; Define the transmit FIFO threshold that we will use, and the corresponding
			      C ; minimum packet size for which we may need software CRC calculation.
			      C ;
 = CR6_K_10MB_TSB_72_BYTES    C CR6_K_10MB_TSB_DEFAULT		EQU	CR6_K_10MB_TSB_72_BYTES ; use max threshold
			      C ;;--- DM9009's CR6 default value
			      C ;;CR6_DM9009_INIT		  EQU	  CR6_M_DM9009_ALWAYS OR CR6_M_RXA OR CR6_M_HBD OR CR6_M_PAM OR CR6_K_10MB_TSB_128_BYTES
 = 02080082		      C CR6_DM9009_INIT 		EQU	CR6_M_DM9009_ALWAYS OR CR6_M_HBD OR CR6_M_PAM OR CR6_K_10MB_TSB_128_BYTES
			      C 
 = 0090			      C SW_CRC_MIN			EQU 144 		; CRC packet size min
			      C 
 = FFFE0000		      C CR7_M_RESERVED1 		EQU 0FFFE0000h
 = 00010000		      C CR7_M_NISE			EQU 000010000h
 = 8000			      C CR7_M_AISE			EQU 000008000h
 = 4000			      C CR7_M_RESERVED2 		EQU 000004000h
 = 2000			      C CR7_M_SBEE			EQU 000002000h
 = 1000			      C CR7_M_RESERVED3 		EQU 000001000h
 = 0800			      C CR7_M_GPTE			EQU 000000800h
 = 0400			      C CR7_M_ETIE			EQU 000000400h
 = 0200			      C CR7_M_RXWTE			EQU 000000200h
 = 0100			      C CR7_M_RXPSE			EQU 000000100h
 = 0080			      C CR7_M_RXDUE			EQU 000000080h
 = 0040			      C CR7_M_RXCIE			EQU 000000040h
 = 0020			      C CR7_M_TXFUE			EQU 000000020h	;;Transmit FIFO Underflow Enable(5)
 = 0010			      C CR7_M_RESERVED4 		EQU 000000010h
 = 0008			      C CR7_M_TXJTE			EQU 000000008h
 = 0004			      C CR7_M_TXDUE			EQU 000000004h
 = 0002			      C CR7_M_TXPSE			EQU 000000002h
 = 0001			      C CR7_M_TXCIE			EQU 000000001h
 = 0011			      C CR7_V_RESERVED1 		EQU 17
 = 0010			      C CR7_V_NISE			EQU 16
 = 000F			      C CR7_V_AISE			EQU 15
 = 000E			      C CR7_V_RESERVED2 		EQU 14
 = 000D			      C CR7_V_SBEE			EQU 13
 = 000B			      C CR7_V_GPTE			EQU 11
 = 000A			      C CR7_V_ETIE			EQU 10
 = 0009			      C CR7_V_RXWTE			EQU 9
 = 0008			      C CR7_V_RXPSE			EQU 8
 = 0007			      C CR7_V_RXDUE			EQU 7
 = 0006			      C CR7_V_RXCIE			EQU 6
 = 0005			      C CR7_V_TXFUE			EQU 5
 = 0004			      C CR7_V_RESERVED4 		EQU 4
 = 0003			      C CR7_V_TXJTE			EQU 3
 = 0002			      C CR7_V_TXDUE			EQU 2
 = 0001			      C CR7_V_TXPSE			EQU 1
 = 0000			      C CR7_V_TXCIE			EQU 0
			      C 
 = 0000			      C CR7_K_DEFAULT_OFF	       EQU 0
 = 00018041		      C CR7_K_DEFAULT_ON	       EQU CR7_M_NISE OR CR7_M_AISE OR CR7_M_RXCIE OR CR7_M_TXCIE
			      C 
			      C 
 = FFFE0000		      C CR8_M_RESERVED		       EQU 0FFFE0000h
 = 00010000		      C CR8_M_MISSED_FRAME_OVERFLOW    EQU 000010000h
 = FFFF			      C CR8_M_MIDDED_FRAME_COUNT       EQU 00000FFFFh
 = 0011			      C CR8_V_RESERVED		       EQU 17
 = 0010			      C CR8_V_MISSED_FRAME_OVERFLOW    EQU 16
 = 0000			      C CR8_V_MIDDED_FRAME_COUNT       EQU 0
			      C 
			      C ;;CR9_M_DN			 EQU 080000000h
			      C ;;CR9_M_RESERVED		 EQU 07FFFFF00h
			      C ;;CR9_M_DT			 EQU 0000000FFh
			      C ;;CR9_V_DN			 EQU 31
			      C ;;CR9_V_RESERVED		 EQU 8
			      C ;;CR9_V_DT			 EQU 0
			      C 
 = FFFF0000		      C CR11_M_RESERVED 	       EQU 0FFFF0000h
 = FFFF			      C CR11_M_FDX_AUTO_CONFIG	       EQU 00000FFFFh
 = 0010			      C CR11_V_RESERVED 	       EQU 16
 = 0000			      C CR11_V_FDX_AUTO_CONFIG	       EQU 0
			      C 
			      C ; CR12 constants
 = FFFFFE00		      C CR12_M_RESERVED 	EQU 0FFFFFE00h
 = 0100			      C CR12_M_GPC		EQU 000000100h
 = 00FF			      C CR12_M_MD		EQU 0000000FFh
 = 0004			      C CR12_M_LNK		EQU 000000004h
 = 0002			      C CR12_M_NCR		EQU 000000002h
			      C 
 = 0009			      C CR12_V_RESERVED 	EQU 9
 = 0008			      C CR12_V_GPC		EQU 8
 = 0000			      C CR12_V_MD		EQU 0
			      C 
 = 013F			      C CR12_K_INIT_VAL 	EQU 00000013Fh
 = 0008			      C CR12_K_ONBOARD_LOOPBACK EQU 000000008h
 = 000A			      C CR12_K_INBOARD_LOOPBACK EQU 00000000Ah
 = 000B			      C CR12_K_NORMAL_MODE	EQU 00000000Bh
			      C 
 = FFFF0000		      C CR13_M_RESERVED 	       EQU 0FFFF0000h
 = 8000			      C CR13_M_OE57		       EQU 000008000h
 = 4000			      C CR13_M_OE24		       EQU 000004000h
 = 2000			      C CR13_M_OE13		       EQU 000002000h
 = 1000			      C CR13_M_IE		       EQU 000001000h
 = 0F00			      C CR13_M_SEL		       EQU 000000F00h
 = 0080			      C CR13_M_ASE		       EQU 000000080h
 = 0040			      C CR13_M_SIM		       EQU 000000040h
 = 0020			      C CR13_M_ENI		       EQU 000000020h
 = 0010			      C CR13_M_EDP		       EQU 000000010h
 = 0008			      C CR13_M_AUI		       EQU 000000008h
 = 0004			      C CR13_M_CAC		       EQU 000000004h
 = 0002			      C CR13_M_PS		       EQU 000000002h
 = 0001			      C CR13_M_SRL		       EQU 000000001h
 = 0010			      C CR13_V_RESERVED 	       EQU 16
 = 000F			      C CR13_V_OE57		       EQU 15
 = 000E			      C CR13_V_OE24		       EQU 14
 = 000D			      C CR13_V_OE13		       EQU 13
 = 000C			      C CR13_V_IE		       EQU 12
 = 0008			      C CR13_V_SEL		       EQU 8
 = 0007			      C CR13_V_ASE		       EQU 7
 = 0006			      C CR13_V_SIM		       EQU 6
 = 0005			      C CR13_V_ENI		       EQU 5
 = 0004			      C CR13_V_EDP		       EQU 4
 = 0003			      C CR13_V_AUI		       EQU 3
 = 0002			      C CR13_V_CAC		       EQU 2
 = 0001			      C CR13_V_PS		       EQU 1
 = 0000			      C CR13_V_SRL		       EQU 0
			      C 
			      C ; values associated with 93LC46B Serial ROM
			      C ;============================================
 = 0040			      C SROM_93LC46B_LEN	EQU	64  ; In words. That is 128 Bytes.
			      C 
			      C 
			      C ; SROM version and field codes
			      C ;-----------------------------
 = 0001			      C UM9100_SROM_V0_1	EQU	01h
 = 0003			      C UM9100_SROM_V0_3	EQU	03h
 = 0012			      C SROM_FORMAT_OFF 	EQU	12h
 = 0013			      C SROM_ADAPTER_COUNT_OFF	EQU	13h
 = 0014			      C SROM_IEEE_OFF		EQU	14h
 = 001A			      C SROM_ADAPTER0_OFF	EQU	1Ah
 = 007E			      C SROM_CHECKSUM_OFF	EQU	7Eh
 = 0003			      C FNET_MEDIA_BLK_SIZE	EQU	03h
 = 0071			      C FNET_COMM_MASK		EQU	71H
 = 0012			      C FNET_COMM_OFF		EQU	12H
			      C 
			      C ; 90100 SROM definitions (SROM_93LC46B)
			      C ;----------------------------------------
 = 0019			      C SROM_93LC46B_MAX_CYCLES 	EQU 25
 = 003F			      C SROM_93LC46B_LAST_ADDRESS	EQU 03Fh
 = 0006			      C SROM_93LC46B_LAST_ADDRESS_BIT	EQU 6	  ;Special assembler implementation
 = 0008			      C SROM_M_Output_Data		EQU 8
			      C 
 = 4000			      C SROM_CR9_READ  EQU 04000h
 = 2000			      C SROM_CR9_WRITE EQU 02000h
 = 0800			      C SROM_SEL_SROM	EQU 0800h
 = 0004			      C SROM_DATA_1	EQU 04h
 = 0000			      C SROM_DATA_0	EQU 0
 = 0002			      C SROM_CLK	EQU 02h
 = 0001			      C SROM_CS 	EQU 01h
			      C 
			      C ; Define a structure that contains the values to be written to the registers to
			      C ; configure the SIA for a particular mode.
			      C ;
 000C			      C SIA_CONFIG	STRUCT
 0000  00000000		      C 	CR13   DWORD   ?
 0004  00000000		      C 	CR14   DWORD   ?
 0008  00000000		      C 	CR15   DWORD   ?
			      C SIA_CONFIG	ENDS
			      C 
			      C SIA_CONFIG_PTR	TYPEDEF PTR SIA_CONFIG
			      C 
 = 0005			      C SIA_Config_Autodetect	equ	5h	    ; flag to do autodetect speed & Half-Duplex
 = 0004			      C SIA_Config_AutoFD	equ	4h	    ; flag to do autodetect speed & Full-Duplex
 = 0000			      C TPFD_SIAConfig		equ	0h
 = 0001			      C TP_SIAConfig		equ	1h
 = 0002			      C BNC_SIAConfig		equ	2h
 = 0003			      C AUI_SIAConfig		equ	3h
			      C 
 = FFFF0000		      C PCIID_M_DEVICE_ID		 EQU 0FFFF0000h
 = FFFF			      C PCIID_M_VENDOR_IO		 EQU 00000FFFFh
 = 0010			      C PCIID_V_DEVICE_ID		 EQU 16
 = 0000			      C PCIID_V_VENDOR_IO		 EQU 0
			      C 
 = 80000000		      C PCICS_M_PARITY_ERROR		 EQU 080000000h
 = 40000000		      C PCICS_M_SYSTEM_ERROR		 EQU 040000000h
 = 20000000		      C PCICS_M_MASTER_ABORT		 EQU 020000000h
 = 10000000		      C PCICS_M_TARGET_ABORT		 EQU 010000000h
 = 08000000		      C PCICS_M_RESERVED		 EQU 008000000h
 = 06000000		      C PCICS_M_DEVSEL			 EQU 006000000h
 = 01000000		      C PCICS_M_DATA_PARITY		 EQU 001000000h
 = 00800000		      C PCICS_M_BACK_TO_BACK		 EQU 000800000h
 = 007FFC00		      C PCICS_M_RESERVED_2		 EQU 0007FFC00h
 = 0200			      C PCICS_M_SERR_ENABLE		 EQU 000000200h
 = 0180			      C PCICS_M_RESERVED_3		 EQU 000000180h
 = 0040			      C PCICS_M_PARITY_ERROR_DETECTED	 EQU 000000040h
 = 0038			      C PCICS_M_RESERVED_4		 EQU 000000038h
 = 0004			      C PCICS_M_BUS_MASTER		 EQU 000000004h
 = 0002			      C PCICS_M_MEMORY_ACCESS		 EQU 000000002h
 = 0001			      C PCICS_M_IO_ACCESS		 EQU 000000001h
 = 001F			      C PCICS_V_PARITY_ERROR		 EQU 31
 = 001E			      C PCICS_V_SYSTEM_ERROR		 EQU 30
 = 001D			      C PCICS_V_MASTER_ABORT		 EQU 29
 = 001C			      C PCICS_V_TARGET_ABORT		 EQU 28
 = 001B			      C PCICS_V_RESERVED		 EQU 27
 = 0019			      C PCICS_V_DEVSEL			 EQU 25
 = 0018			      C PCICS_V_DATA_PARITY		 EQU 24
 = 0017			      C PCICS_V_BACK_TO_BACK		 EQU 23
 = 000A			      C PCICS_V_RESERVED_2		 EQU 10
 = 0009			      C PCICS_V_SERR_ENABLE		 EQU 9
 = 0007			      C PCICS_V_RESERVED_3		 EQU 7
 = 0006			      C PCICS_V_PARITY_ERROR_DETECTED	 EQU 6
 = 0003			      C PCICS_V_RESERVED_4		 EQU 3
 = 0002			      C PCICS_V_BUS_MASTER		 EQU 2
 = 0001			      C PCICS_V_MEMORY_ACCESS		 EQU 1
 = 0000			      C PCICS_V_IO_ACCESS		 EQU 0
			      C 
 = FF000000		      C PCIRV_M_BASE_CLASS		 EQU 0FF000000h
 = 00FF0000		      C PCIRV_M_SUB_CLASS		 EQU 000FF0000h
 = FF00			      C PCIRV_M_RESERVED		 EQU 00000FF00h
 = 00F0			      C PCIRV_M_Revision_Major_Number	 EQU 0000000F0h
 = 000F			      C PCIRV_M_Revision_Minor_Number	 EQU 00000000Fh
 = 0018			      C PCIRV_V_BASE_CLASS		 EQU 24
 = 0010			      C PCIRV_V_SUB_CLASS		 EQU 16
 = 0008			      C PCIRV_V_RESERVED		 EQU 8
 = 0004			      C PCIRV_V_Revision_Major_Number	 EQU 4
 = 0000			      C PCIRV_V_Revision_Minor_Number	 EQU 0
			      C 
 = FFFF0000		      C PCILT_M_RESERVED		 EQU 0FFFF0000h
 = FF00			      C PCILT_M_LATENCY_TIMER		 EQU 00000FF00h
 = 00FF			      C PCILT_M_RESERVED_2		 EQU 0000000FFh
 = 0010			      C PCILT_V_RESERVED		 EQU 16
 = 0008			      C PCILT_V_LATENCY_TIMER		 EQU 8
 = 0000			      C PCILT_V_RESERVED_2		 EQU 0
			      C 
 = FFFFFF80		      C PCIIO_M_PCI_IO_BASE_ADDRESS	 EQU 0FFFFFF80h
 = 007E			      C PCIIO_M_RESERVED		 EQU 00000007Eh
 = 0001			      C PCIIO_M_MEMORY_IO		 EQU 000000001h
 = 0007			      C PCIIO_V_PCI_IO_BASE_ADDRESS	 EQU 7
 = 0001			      C PCIIO_V_RESERVED		 EQU 1
 = 0000			      C PCIIO_V_MEMORY_IO		 EQU 0
			      C 
 = FFFFFF80		      C PCIMEM_M_PCI_MEM_BASE_ADDRESS	  EQU 0FFFFFF80h
 = 007E			      C PCIMEM_M_RESERVED		  EQU 00000007Eh
 = 0001			      C PCIMEM_M_MEMORY_SPACE		  EQU 000000001h
 = 0007			      C PCIMEM_V_PCI_MEM_BASE_ADDRESS	  EQU 7
 = 0001			      C PCIMEM_V_RESERVED		  EQU 1
 = 0000			      C PCIMEM_V_MEMORY_SPACE		  EQU 0
			      C 
 = FFFF0000		      C PCIINT_M_RESERVED		  EQU 0FFFF0000h
 = FF00			      C PCIINT_M_INTERRUPT_PIN		  EQU 00000FF00h
 = 00FF			      C PCIINT_M_INTERRUPT_LINE 	  EQU 0000000FFh
 = 0010			      C PCIINT_V_RESERVED		  EQU 16
 = 0008			      C PCIINT_V_INTERRUPT_PIN		  EQU 8
 = 0000			      C PCIINT_V_INTERRUPT_LINE 	  EQU 0
			      C 
 = FFFF0000		      C PCIUSR_M_RESERVED		  EQU 0FFFF0000h
 = FF00			      C PCIUSR_M_USER_SPECIAL_USE	  EQU 00000FF00h
 = 00FF			      C PCIUSR_M_RESERVED_2		  EQU 0000000FFh
 = 0010			      C PCIUSR_V_RESERVED		  EQU 16
 = 0008			      C PCIUSR_V_USER_SPECIAL_USE	  EQU 8
 = 0000			      C PCIUSR_V_RESERVED_2		  EQU 0
			      C 
 = 00C0			      C HW_K_SETUP_FRAME_SIZE		EQU 192
			      C 
			      C ;
			      C ;  Descriptor definitions
			      C ;
			      C ;     Transmit Descriptor
			      C ;     -------------------
			      C ;
			      C ; The DM9100 Transmit Descriptor is described in the DM9100 specification.
			      C ; The names of the fields, TDES0-3 are taken straight from the spec.
			      C ; This structure, and the associated constants, define the format of the
			      C ; transmit descriptor used by the DM9100. A transmit descriptor must
			      C ; be allocated a physically contiguous, longword aligned region of memory. The
			      C ; transmit buffers to which the descriptors point may be of arbitrary alignment
			      C ; and size.
			      C ;
			      C ; The p_XmtBuffer and p_XmtNext fields of the descriptor are unique to this
			      C ; driver implementation. They are virtual NEAR pointers to the transmit buffer
			      C ; and the next descriptor respectively. The descriptor skip length in CR0 is
			      C ; set to 1 longword in order to skip this extra longword at the end of each
			      C ; descriptor.
			      C ;
			      C 
 0020			      C XMT_DESCRIPTOR	STRUC
 0000  00000000		      C    TDES0       DD 0
 0004  00000000		      C    TDES1       DD 0
 0008  00000000		      C    TDES2       DD 0
 000C  00000000		      C    TDES3       DD 0
 0010  0000		      C    p_XmtBuffer DW 0
 0012  0000		      C    p_XmtNext   DW 0
 0014  00000000		      C    p_Dummy1    DD 0
 0018  00000000		      C    p_Dummy2    DD 0
 001C  00000000		      C    p_Dummy3    DD 0
			      C XMT_DESCRIPTOR	ENDS
			      C 
 = 80000000		      C TDES0_M_OWN		EQU 080000000h	; OWN Bit 1=MAC 0=Host
 = 8000			      C TDES0_M_ES		EQU 000008000h	; Error Summary (UF|EC|LC|NC|LO|TO|LF)
 = 4000			      C TDES0_M_TXJT		EQU 000004000h	; Transmit Jabber Expired
 = 0800			      C TDES0_M_LOC		EQU 000000800h	; Loss of Carrier
 = 0400			      C TDES0_M_NC		EQU 000000400h	; No Carrier
 = 0200			      C TDES0_M_LC		EQU 000000200h	; Late Collision
 = 0100			      C TDES0_M_EC		EQU 000000100h	; Excessive Collisions
 = 0080			      C TDES0_M_HF		EQU 000000080h	; Heartbeat Fail
 = 0078			      C TDES0_M_CC		EQU 000000078h	; Collision Count
 = 0004			      C TDES0_M_LF		EQU 000000004h	; Link Fail
 = 0002			      C TDES0_M_FUE		EQU 000000002h	; FIFO Underflow Error
 = 0001			      C TDES0_M_DE		EQU 000000001h	; Deferred
			      C 
 = 001F			      C TDES0_V_OWN		EQU 31
 = 000F			      C TDES0_V_ES		EQU 15
 = 000E			      C TDES0_V_TXJT		EQU 14
 = 000B			      C TDES0_V_LOC		EQU 11
 = 000A			      C TDES0_V_NC		EQU 10
 = 0009			      C TDES0_V_LC		EQU 9
 = 0008			      C TDES0_V_EC		EQU 8
 = 0007			      C TDES0_V_HF		EQU 7
 = 0003			      C TDES0_V_CC		EQU 3
 = 0002			      C TDES0_V_LF		EQU 2
 = 0001			      C TDES0_V_FUE		EQU 1
 = 0000			      C TDES0_V_DE		EQU 0
			      C 
 = 80000000		      C TDES1_M_CI		EQU 080000000h	; Completion Interrupt
 = 40000000		      C TDES1_M_ED		EQU 040000000h	; End Segment
 = 20000000		      C TDES1_M_BD		EQU 020000000h	; Begin Segment
 = 10000000		      C TDES1_M_FMB1		EQU 010000000h	; Filtering Mode Bit 1
 = 08000000		      C TDES1_M_SETF		EQU 008000000h	; Setup Frame
 = 04000000		      C TDES1_M_CAD		EQU 004000000h	; CRC Append Disable
 = 02000000		      C TDES1_M_EOR		EQU 002000000h	; End of Ring
 = 01000000		      C TDES1_M_CE		EQU 001000000h	; Chain Enable
 = 00800000		      C TDES1_M_PD		EQU 000800000h	; Padding Disable
 = 00400000		      C TDES1_M_FMB0		EQU 000400000h	; Filtering Mode Bit 0
 = 003FF800		      C TDES1_M_BL2		EQU 0003FF800h	; Size in bytes of Buffer 2
 = 07FF			      C TDES1_M_BL1		EQU 0000007FFh	; Size in bytes of Buffer 1
			      C 
			      C ;;-+, 980415, Hu-Tiong
			      C ;;TDES1_M_DUMMY 	  EQU TDES1_M_EOR AND (not (TDES1_M_BL2 OR TDES1_M_BL1 OR TDES1_M_ED OR TDES1_M_BD))
 = 01000000		      C TDES1_M_DUMMY		EQU TDES1_M_CE AND (not (TDES1_M_BL2 OR TDES1_M_BL1 OR TDES1_M_ED OR TDES1_M_BD))
			      C ;;-+
			      C 
 = 001F			      C TDES1_V_CI		EQU 31
 = 001E			      C TDES1_V_ED		EQU 30
 = 001D			      C TDES1_V_BD		EQU 29
 = 001C			      C TDES1_V_FMB1		EQU 28
 = 001B			      C TDES1_V_SETF		EQU 27
 = 001A			      C TDES1_V_CAD		EQU 26
 = 0019			      C TDES1_V_EOR		EQU 25
 = 0018			      C TDES1_V_CE		EQU 24
 = 0017			      C TDES1_V_PD		EQU 23
 = 0016			      C TDES1_V_FMB0		EQU 22
 = 000B			      C TDES1_V_BL2		EQU 11
 = 0000			      C TDES1_V_BL1		EQU 0
			      C 
 = 05F0			      C XMT_BUFFER_SIZE 	EQU 1520
			      C 
			      C ;
			      C ;     Receive Descriptor
			      C ;     ------------------
			      C ;
			      C ;
			      C ; The DM9100 Receive Descriptor is described in the DM9100 specification.
			      C ; The names of the fields, RDES0-3 are takes straight from the spec.
			      C ; This structure, and the associated constants, define the format of the
			      C ; receive descriptor used by the DM9100. A receive descriptor must be
			      C ; allocated a physically contiguous, longword aligned region of memory. The
			      C ; receive buffers to which the descriptors point must also be physically
			      C ; contiguous and longword alignedand a MOD 4 length.
			      C ;
			      C ; The p_RcvBuffer and p_RcvNext fields of the descriptor are unique to this driver
			      C ; implementation. They are virtual NEAR pointers to the receive buffer and
			      C ; the next descriptor respectively. The descriptor skip length in CR0 is
			      C ; set to 1 longword in order to skip this extra longword at the end of each
			      C ; descriptor.
			      C ;
			      C 
 0020			      C RCV_DESCRIPTOR	STRUC
 0000  00000000		      C    RDES0	 DD 0
 0004  00000000		      C    RDES1	 DD 0
 0008  00000000		      C    RDES2	 DD 0
 000C  00000000		      C    RDES3	 DD 0
 0010  0000		      C    p_RcvBuffer	 DW 0
 0012  0000		      C    p_RcvNext	 DW 0
 0014  00000000		      C    p_Dummy1	 DD 0
 0018  00000000		      C    p_Dummy2	 DD 0
 001C  00000000		      C    p_Dummy3	 DD 0
			      C RCV_DESCRIPTOR	ENDS
			      C 
 = 80000000		      C RDES0_M_OWN		EQU 080000000h	; OWN bit 0=HOST 1=MAC
 = 7FFF0000		      C RDES0_M_LENGTH		EQU 07FFF0000h	; Length of frame in bytes including CRC
 = 8000			      C RDES0_M_ES		EQU 000008000h	; Error Summary (OF|CE|CS|TL|LE|RF)
 = 4000			      C RDES0_M_DUE		EQU 000004000h	;;Descriptor Unavailable Error
			      C 					; Length Error (rcv buffer too small)
 = 3000			      C RDES0_M_LBOM		EQU 000003000h	; Data Type
 = 0800			      C RDES0_M_RF		EQU 000000800h	; Runt Frame
 = 0400			      C RDES0_M_MF		EQU 000000400h	; MCast frame
 = 0200			      C RDES0_M_BD		EQU 000000200h	; Begin Descriptor
 = 0100			      C RDES0_M_ED		EQU 000000100h	; End Descriptor
 = 0080			      C RDES0_M_EFL		EQU 000000080h	; Excessive Frame Length (>1518 bytes)
 = 0040			      C RDES0_M_LCS		EQU 000000040h	; Late Collision Seen
 = 0020			      C RDES0_M_FT		EQU 000000020h	; Frame Type 1=DIX 0=802.3
 = 0010			      C RDES0_M_RXWT		EQU 000000010h	; Receive Watchdog Expired (frame >2K)
 = 0008			      C RDES0_M_PLE		EQU 000000008h	; Physical Layer Error
 = 0004			      C RDES0_M_AE		EQU 000000004h	; Alignment Error
 = 0002			      C RDES0_M_CE		EQU 000000002h	; CRC Error
 = 0001			      C RDES0_M_FOE		EQU 000000001h	; FIFO Overflow Error
			      C 
 = 001F			      C RDES0_V_OWN		EQU 31
 = 0010			      C RDES0_V_LENGTH		EQU 16
 = 000F			      C RDES0_V_ES		EQU 15
 = 000E			      C RDES0_V_DUE		EQU 14
 = 000C			      C RDES0_V_LBOM		EQU 12
 = 000B			      C RDES0_V_RF		EQU 11
 = 000A			      C RDES0_V_MF		EQU 10
 = 0009			      C RDES0_V_BD		EQU 9
 = 0008			      C RDES0_V_ED		EQU 8
 = 0007			      C RDES0_V_EFL		EQU 7
 = 0006			      C RDES0_V_LCS		EQU 6
 = 0005			      C RDES0_V_FT		EQU 5
 = 0004			      C RDES0_V_RXWT		EQU 4
 = 0002			      C RDES0_V_AE		EQU 2
 = 0001			      C RDES0_V_CE		EQU 1
 = 0000			      C RDES0_V_FOE		EQU 0
			      C 
 = 0001			      C RDES0_K_FT_DIX		EQU 1
 = 0000			      C RDES0_K_FT_802		EQU 0
			      C 
 = 0000			      C RDES0_K_LBOM_NORMAL	EQU 0
 = 0001			      C RDES0_K_LBOM_INTERNAL	EQU 1
 = 0002			      C RDES0_K_LBOM_EXTERNAL	EQU 2
 = 0003			      C RDES0_K_LBOM_RESERVED	EQU 3
			      C 
 = 02000000		      C RDES1_M_EOR		EQU 002000000h	; End Of Ring
 = 01000000		      C RDES1_M_CE		EQU 001000000h	; Chain Enable
 = 003FF800		      C RDES1_M_BL2		EQU 0003FF800h	; Size in bytes of buffer 2 (MOD 4)
 = 07FF			      C RDES1_M_BL1		EQU 0000007FFh	; Size in bytes of buffer 1 (MOD 4)
			      C 
 = 0019			      C RDES1_V_EOR		EQU 25
 = 0018			      C RDES1_V_CE		EQU 24
 = 000B			      C RDES1_V_BL2		EQU 11
 = 0000			      C RDES1_V_BL1		EQU 0
			      C 
 = 0620			      C RCV_BUFFER_SIZE 	EQU 620h   ; Smallest MOD 4 length that can accommodate MTU
			      C ;;RCV_BUFFER_SIZE	  EQU 1520   ; Smallest MOD 4 length that can accommodate MTU
			      C 
			      C ;; SROM contents structure
 0082			      C SROM_NS_Contents	STRUC
 0000  0000		      C   NS_SS_Vendor_ID    DW      0		     ; Sub-System Vendor ID
 0002  0000		      C   NS_SS_ID	     DW      0		     ; Sub-System ID
 0004  0000		      C   NS_Cardbus_Low     DW      0		     ; Cardbus CIS Pointer Low
 0006  0000		      C   NS_Cardbus_High    DW      0		     ; Cardbus CIS Pointer High
 0008  0008 [		      C   NS_ID_Reserved1    DB      8 DUP (0)	     ; Reserved
        00
       ]
 0010  00		      C   NS_ID_Bk_Crc	     DB      0		     ; ID Block CRC
 0011  00		      C   NS_ID_Reserved2    DB      0		     ; Reserved
 0012  03		      C   NS_SROM_version    DB      03h	     ; SROM Format Version
 0013  01		      C   NS_Controller_cnt  DB      01h	     ; Controller Count
 0014  0006 [		      C   NS_Ether_Addr      DB      6 DUP (0)	     ; IEEE Network Address
        00
       ]
 001A  00		      C   NS_Dev_Number      DB      0		     ; Controller Device Number
 001B  001E		      C   NS_IL_Offset	     DW      1Eh	     ; Controller Info Leaf Offset
 001D  00		      C   NS_Inf_Reserved3   DB      0		     ; Reserved
			      C ;; -- Info Leaf
 001E  0000		      C   NS_Sel_Conn_type   DW      0		     ; Selected Connection Type
 0020  80		      C   NS_Gen_Pur_Ctrl    DB      80h	     ; General Purpose Control
 0021  06		      C   NS_Blk_cnt	     DB      6		     ; Block Count
			      C ;; -- Info Leaf Block
 0022  8E		      C   NS_F1_Length_0     DB      8Eh	     ; Format 1 length bytes
 0023  01		      C   NS_Type1	     DB      1		     ; Extended format type 1
 0024  01		      C   NS_PHY_Number      DB      1		     ; PHY Address
 0025  00		      C   NS_GPR_Seq_Len     DB      0		     ; GPR sequence Length
 0026  02		      C   NS_RST_Seq_Len     DB      2		     ; Reset Sequence Length
 0027  80		      C   NS_RST_Seq_0	     DB      80h	     ; Reset Sequence 0
 0028  00		      C   NS_RST_Seq_1	     DB      00h	     ; Reset Sequence 1
 0029  7800		      C   NS_Media_Cap	     DW      7800h	     ; Media Capabilities
 002B  01E0		      C   NS_Nway_Adv	     DW      01E0h	     ; Nway Advertisemnet
 002D  5000		      C   NS_FDX_Map	     DW      5000h	     ; Full Duplex Bits
 002F  1800		      C   NS_TTM_Map	     DW      1800h	     ; Tx Theshold Mode Bits
			      C ;; --
 0031  85		      C   NS_F1_Length_1     DB      85h	     ; Format 1 length
 0032  80		      C   NS_Type2	     DB      80h	     ; New Delay Type
 0033  2000		      C   NS_Delay_Seq_0     DW      2000h	     ;
 0035  4000		      C   NS_Delay_seq_1     DW      4000h	     ;
			      C ;; --
 0037  85		      C   NS_F1_Length_2     DB      85h
 0038  00		      C   NS_Type3	     DB      00h
 0039  00		      C   NS_10BaseT_Code    DB      00h
 003A  00		      C   NS_GprData10	     DB      00h
 003B  001D		      C   NS_Comm10	     DW      001Dh
			      C ;; --
 003D  85		      C   NS_F1_Length_3     DB      85h
 003E  00		      C   NS_Type4	     DB      00h
 003F  01		      C   NS_100BaseT_Code   DB      01h
 0040  00		      C   NS_GprData100      DB      00h
 0041  008D		      C   NS_Comm100	     DW      008Dh
			      C ;; --
 0043  85		      C   NS_F1_Length_4     DB      85h
 0044  00		      C   NS_Type5	     DB      00h
 0045  04		      C   NS_10BaseFD_Code   DB      04h
 0046  00		      C   NS_GprData10FD     DB      00h
 0047  001D		      C   NS_Comm10FD	    DW	    001Dh
			      C ;; --
 0049  85		      C   NS_F1_Length_5     DB      85h
 004A  00		      C   NS_Type6	     DB      00h
 004B  05		      C   NS_100BaseFD	     DB      05h
 004C  00		      C   NS_GprData100FD    DB      00h
 004D  008D		      C   NS_Comm100FD	     DW      008Dh
 004F  0031 [		      C   NS_Reserved4	     DB      49 DUP (0)
        00
       ]
 0080  0002 [		      C   NS_SROM_CRC	     DB      2 DUP (0)
        00
       ]
			      C SROM_NS_Contents	ENDS
			      C 
 006D			      C SROM_MotolorA_Contents	      STRUC
 0000  0000		      C   MA_SS_Vendor_ID    DW      0		     ; Sub-System Vendor ID
 0002  0000		      C   MA_SS_ID	     DW      0		     ; Sub-System ID
 0004  0000		      C   MA_Cardbus_Low     DW      0		     ; Cardbus CIS Pointer Low
 0006  0000		      C   MA_Cardbus_High    DW      0		     ; Cardbus CIS Pointer High
 0008  0008 [		      C   MA_ID_Reserved1    DB      8 DUP (0)	     ; Reserved
        00
       ]
 0010  00		      C   MA_ID_Bk_Crc	     DB      0		     ; ID Block CRC
 0011  00		      C   MA_ID_Reserved2    DB      0		     ; Reserved
 0012  03		      C   MA_SROM_version    DB      03h	     ; SROM Format Version
 0013  01		      C   MA_Controller_cnt  DB      01h	     ; Controller Count
 0014  0006 [		      C   MA_Ether_Addr      DB      6 DUP (0)	     ; IEEE Network Address
        00
       ]
 001A  00		      C   MA_Dev_Number      DB      0		     ; Controller Device Number
 001B  001E		      C   MA_IL_Offset	     DW      1Eh	     ; Controller Info Leaf Offset
 001D  00		      C   MA_Inf_Reserved3   DB      0		     ; Reserved
			      C ;; -- Info Leaf
 001E  0000		      C   MA_Sel_Conn_type   DW      0		     ; Selected Connection Type
 0020  80		      C   MA_Gen_Pur_Ctrl    DB      80h	     ; General Purpose Control
 0021  06		      C   MA_Blk_cnt	     DB      6		     ; Block Count
			      C ;; -- Info Leaf Block
 0022  85		      C   MA_F1_Length_2     DB      85h
 0023  00		      C   MA_Type3	     DB      00h
 0024  00		      C   MA_10BaseT_Code    DB      00h
 0025  00		      C   MA_GprData10	     DB      00h
 0026  001D		      C   MA_Comm10	     DW      001Dh
			      C ;; --
 0028  85		      C   MA_F1_Length_3     DB      85h
 0029  00		      C   MA_Type4	     DB      00h
 002A  01		      C   MA_100BaseT_Code   DB      01h
 002B  00		      C   MA_GprData100      DB      00h
 002C  008D		      C   MA_Comm100	     DW      008Dh
			      C ;; --
 002E  85		      C   MA_F1_Length_4     DB      85h
 002F  00		      C   MA_Type5	     DB      00h
 0030  04		      C   MA_10BaseFD_Code   DB      04h
 0031  00		      C   MA_GprData10FD     DB      00h
 0032  001D		      C   MA_Comm10FD	    DW	    001Dh
			      C ;; --
 0034  85		      C   MA_F1_Length_5     DB      85h
 0035  00		      C   MA_Type6	     DB      00h
 0036  05		      C   MA_100BaseFD	     DB      05h
 0037  00		      C   MA_GprData100FD    DB      00h
 0038  008D		      C   MA_Comm100FD	     DW      008Dh
 003A  0031 [		      C   MA_Reserved4	     DB      49 DUP (0)
        00
       ]
 006B  0002 [		      C   MA_SROM_CRC	     DB      2 DUP (0)
        00
       ]
			      C SROM_MotolorA_Contents	      ENDS
			      C  
			      C 
			      C 
			      C EXTRN	errors_in : DWORD
			      C 
			      C 	PUBLIC	RcvNumBuffers
			      C ;;RcvNumBuffers   DW	  12	  ; Number of Receive's buffer
 1017 0008		      C RcvNumBuffers	DW	8      ; Number of Receive's buffer
			      C 
			      C 	PUBLIC p_RcvBlockVirt, p_RcvBlockPhys, p_RcvRingVirt, p_RcvRingPhys
 1019 0000		      C p_RcvBlockVirt	DW 0			; NEAR Pointer to base of Receive Block
 101B 00000000		      C p_RcvBlockPhys	DD 0			; Physical address of Receive Block
 101F 0000		      C p_RcvRingVirt	DW 0			; NEAR Pointer to base of Receive Ring
 1021 00000000		      C p_RcvRingPhys	DD 0			; Physical address of Receive Ring
			      C 
			      C 	       PUBLIC RcvState
 1025 0000		      C RcvState       DW 0
			      C 
			      C 	PUBLIC RcvSemaphore
 1027 00		      C RcvSemaphore  DB  0			; Controls re-entry of RcvMain
			      C 
			      C 
			      C 	PUBLIC RcvCurrentDescriptor
 1028 0000		      C RcvCurrentDescriptor	 DW 0
			      C 
			      C ;--------------------------------------------------------------------+
			      C ; Name : RcvInit
			      C ;
			      C ; Description:
			      C ; This routine initializes the receive module. It must be called before
			      C ; any other calls are made to the receive module.
			      C ;
			      C ; Stack Frame relative to BP (Remember, gang, this is a NEAR call, so the
			      C ;			      first argument appears at BP+4. It's NOT a typo)
			      C ;
			      C ; Enter :
			      C ;	BP+6  DWORD  PhysAddr	 ; Physical Address of Memory Block
			      C ;	BP+4  WORD   VirtAddr	 ; NEAR pointer to Memory Block. DS:VirtAddr
			      C ;
			      C ; Return :  Bytes used in AX.
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C 	PUBLIC RcvInit
 102A			      C RcvInit PROC NEAR
 102A  55		      C 	push bp
 102B  8B EC		      C 	mov  bp,sp
 102D  66| 52		      C 	push edx
			      C ;;++, 980415, Hu-Tiong
 102F  66| 53		      C 	push	ebx
			      C ;;++
 1031  51		      C 	push cx
 1032  57		      C 	push di
 1033  56		      C 	push si
			      C 
 1034  2E: C7 06 1025 R	      C 	mov  RcvState, 0
       0000
			      C 
 103B  8B 46 04		      C 	mov  ax, WORD PTR [BP+4]	; Get Virtual address of Memory Block
 103E  2E: A3 1019 R	      C 	mov  p_RcvBlockVirt, ax
 1042  2E: A3 101F R	      C 	mov  p_RcvRingVirt, ax
 1046  66| 8B 56 06	      C 	mov  edx, DWORD PTR [BP+6]	; Get Physical address of Memory Block
 104A  66| 83 FA 00	      C 	cmp  edx, 0			; If address is zero, just return
 104E  0F 84 00A4	      C 	je   rinit_return_bytes_used	; bytes used, don't init.
 1052  66| 2E: 89 16 101B R   C 	mov  p_RcvBlockPhys, edx
 1058  66| 2E: 89 16 1021 R   C 	mov  p_RcvRingPhys, edx
 105E  2E: A1 1017 R	      C 	mov  ax, RcvNumBuffers		; Get number of Rcv Buffers
 1062  BA 0620		      C 	mov  dx, RCV_BUFFER_SIZE
 1065  F7 E2		      C 	mul  dx
 1067  66| 0F B7 D0	      C 	movzx edx, ax			; EDX = #buffers * size of buffer
			      C 	;; Pointer to 1st Descriptor address
 106B  2E: 01 16 101F R	      C 	add  p_RcvRingVirt, dx		; Add total size of receive buffer...
 1070  66| 2E: 01 16 1021 R   C 	add  p_RcvRingPhys, edx 	; ...space to get offset of desc ring
			      C ;
			      C ; At this point the p_RcvBlock and p_RcvRing pointers are initialized.
			      C ; Now, initialize the descriptors. Registers are used as follows:
			      C ;
			      C ; SI points to descriptor being initialized.
			      C ; DI points to the descriptor's associated receive buffer
			      C ; EDX is the physical address of the associated receive buffer
			      C ;
 1076  2E: 8B 36 101F R	      C 	mov  si, p_RcvRingVirt
 107B  2E: 8B 3E 1019 R	      C 	mov  di, p_RcvBlockVirt
 1080  66| 2E: 8B 16 101B R   C 	mov  edx, p_RcvBlockPhys
			      C ;;++, 980415, Hu-Tiong
 1086  66| 2E: 8B 1E 1021 R   C 	mov	ebx, p_RcvRingPhys
			      C ;;++
 108C  2E: 8B 0E 1017 R	      C 	mov  cx, RcvNumBuffers		; Get RcvNumBuffers
 1091  49		      C 	dec  cx 			; Initialize NumRcvBuffs-1 descriptors
			      C 
 1092			      C rinit_loop:
 1092  66| C7 04 80000000     C 	mov  [si].RCV_DESCRIPTOR.RDES0, RDES0_M_OWN ; Set ownership to 90100
			      C 						    ;;(80000000h)
			      C ;;	  mov  [si].RCV_DESCRIPTOR.RDES1, 0000005F0h  ; Set buffer 1&2 to length 1520
			      C ;;;-+, 980414, Hu-Tiong
			      C ;;	mov  [si].RCV_DESCRIPTOR.RDES1, RCV_BUFFER_SIZE  ; Set buffer 1&2 to length 1520
			      C ;;;;;;	mov  [si].RCV_DESCRIPTOR.RDES1, 600h		 ; Set buffer 1&2 to length 1520
 1099  66| C7 44 04	      C 	mov  [si].RCV_DESCRIPTOR.RDES1, RDES1_M_CE OR 600h	; Set buffer 1&2 to length 1520
       01000600
			      C ;;;-+
 10A1  66| 89 54 08	      C 	mov  [si].RCV_DESCRIPTOR.RDES2, edx	    ; Point buffer 1 to edx
			      C ;;;-+, 980415, Hu-Tiong
			      C ;;	mov  [si].RCV_DESCRIPTOR.RDES3, 0	    ; Point buffer 2 to edx
 10A5  66| 83 C3 20	      C 	add  ebx, SIZE RCV_DESCRIPTOR	; Next Descriptor's physical address
 10A9  66| 89 5C 0C	      C 	mov  [si].RCV_DESCRIPTOR.RDES3, ebx	    ; Point next descriptor
			      C ;;;-+
 10AD  89 7C 10		      C 	mov  [si].RCV_DESCRIPTOR.p_RcvBuffer, di	  ; Init buf virtual address
 10B0  8B C6		      C 	mov  ax, si
 10B2  83 C0 20		      C 	add  ax, SIZE RCV_DESCRIPTOR	; AX points to next descriptor
 10B5  89 44 12		      C 	mov  [si].RCV_DESCRIPTOR.p_RcvNext, ax ; Init virtual address of next desc
 10B8  8B F0		      C 	mov  si, ax			; SI points to next descriptor
 10BA  66| 81 C2 00000620     C 	add  edx, RCV_BUFFER_SIZE	; EDX holds physical address of next buf
 10C1  81 C7 0620	      C 	add  di, RCV_BUFFER_SIZE	; DI points to next buf
 10C5  E2 CB		      C 	loop rinit_loop 		; Loop while CX != 0
			      C ;
			      C ; Now initialize the last descriptor
			      C ;
 10C7  66| C7 04 80000000     C 	mov  [si].RCV_DESCRIPTOR.RDES0, RDES0_M_OWN ; Set ownership to 90100
			      C ;;;-+, 980414, Hu-Tiong
			      C ;;	mov  [si].RCV_DESCRIPTOR.RDES1, RCV_BUFFER_SIZE OR RDES1_M_EOR ; end of ring
			      C ;;;;;;	mov  [si].RCV_DESCRIPTOR.RDES1, 600h OR RDES1_M_EOR ; end of ring
 10CE  66| C7 44 04	      C 	mov  [si].RCV_DESCRIPTOR.RDES1, RDES1_M_CE OR 600h  ; end of ring
       01000600
			      C ;;;-+
 10D6  66| 89 54 08	      C 	mov  [si].RCV_DESCRIPTOR.RDES2, edx	    ; Point buffer 1 to edx
			      C ;;-+, 980415, Hu-Tiong
			      C ;;;;;;	mov  [si].RCV_DESCRIPTOR.RDES3, 0	    ; Point buffer 2 to edx
 10DA  66| 2E: 8B 1E 1021 R   C 	mov  ebx, p_RcvRingPhys
 10E0  66| 89 5C 0C	      C 	mov  [si].RCV_DESCRIPTOR.RDES3, ebx	    ; Point buffer 2 to edx
			      C ;;-+
 10E4  89 7C 10		      C 	mov  [si].RCV_DESCRIPTOR.p_RcvBuffer, di	  ; Init buf virtual address
 10E7  2E: A1 101F R	      C 	mov  ax, p_RcvRingVirt
 10EB  89 44 12		      C 	mov  [si].RCV_DESCRIPTOR.p_RcvNext, ax	       ; point to start of ring
			      C ;
			      C ; At this point, the receive ring of descriptors is initialized, and
			      C ; all ownership bits are set to the DM9100. All is set for receive DMA
			      C ; traffic to be delivered to the buffers once the adapter is enabled.
			      C ;
 10EE  2E: A1 101F R	      C 	mov  ax, p_RcvRingVirt
 10F2  2E: A3 1028 R	      C 	mov  RcvCurrentDescriptor, ax	; Initialize current descriptor
			      C 
 10F6			      C rinit_return_bytes_used:
 10F6  2E: A1 1017 R	      C 	mov  ax, RcvNumBuffers		; Get number of Rcv Buffers
 10FA  BA 0620		      C 	mov  dx, RCV_BUFFER_SIZE	;; 1520
 10FD  83 C2 20		      C 	add  dx, SIZE RCV_DESCRIPTOR
 1100  F7 E2		      C 	mul  dx 			; DX:AX = (BUFFER_SIZE + DESCR_SIZE) *
			      C 					;	       NUMBER_OF_BUFFERS
			      C 
			      C 
 1102  5E		      C 	pop  si
 1103  5F		      C 	pop  di
 1104  59		      C 	pop  cx
			      C ;;++, 980415, Hu-Tiong
 1105  66| 5B		      C 	pop	ebx
			      C ;;++
 1107  66| 5A		      C 	pop  edx
 1109  5D		      C 	pop  bp
 110A  C3		      C 	ret
 110B			      C RcvInit ENDP
			      C 
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Page 10 - 1


			      C 	PAGE
			      C ;--------------------------------------------------------------------+
			      C ; Name : RcvReset
			      C ;
			      C ; Description:
			      C ; This routine re-initializes the receive module. It has the following
			      C ; effect:
			      C ;
			      C ; 1) RcvDisable is called with the following actions:
			      C ;    - RcvState is reset to 0
			      C ;    - Receiver is stopped
			      C ;    - RIM interrupt is masked
			      C ; 2) The receive descriptor ring is reinitialized with all own bits
			      C ;    set to DM9100
			      C ; 3) The RcvCurrentDescriptor is reinitialized to point to the base of the
			      C ;    ring
			      C ;
			      C ; Enter :
			      C ; Return :
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C 	 PUBLIC RcvReset
 110B			      C RcvReset PROC NEAR
 110B  51		      C 	push cx
 110C  56		      C 	push si
			      C 
 110D  E8 0023		      C 	call RcvDisable 		; Disable receiver
			      C 
 1110  2E: 8B 36 101F R	      C 	mov  si, p_RcvRingVirt		; Get pointer to base of receive ring
 1115  2E: 8B 0E 1017 R	      C 	mov  cx, RcvNumBuffers		; Get RcvNumBuffers
			      C 
 111A			      C rreset_loop:
 111A  66| C7 04 80000000     C 	mov  [si].RCV_DESCRIPTOR.RDES0, RDES0_M_OWN ; Set ownership to 90100
 1121  8B 74 12		      C 	mov  si, [si].RCV_DESCRIPTOR.p_RcvNext	   ; SI points to next descriptor
 1124  E2 F4		      C 	loop rreset_loop		; Loop while CX != 0
			      C 
 1126  2E: 8B 0E 101F R	      C 	mov  cx, p_RcvRingVirt
 112B  2E: 89 0E 1028 R	      C 	mov  RcvCurrentDescriptor, cx	; Initialize current descriptor
			      C 
			      C 
 1130  5E		      C 	pop  si
 1131  59		      C 	pop  cx
 1132  C3		      C 	ret
 1133			      C RcvReset ENDP
			      C 
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Page 11 - 1


			      C 	PAGE
			      C ;--------------------------------------------------------------------+
			      C ; Name : RcvDisable
			      C ;
			      C ; Description:
			      C ;	  This function disables the receipt of frames from the adapter.
			      C ;
			      C ; Enter :
			      C ; Return :
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C 	PUBLIC RcvDisable
 1133			      C RcvDisable  PROC  NEAR
 1133  66| 50		      C 	push eax
 1135  52		      C 	push dx
			      C 
 1136  2E: C7 06 1025 R	      C 	mov  RcvState, 0
       0000
			      C 
			      C ;;-+, 2000.2.16, hu-tiong
			      C ;	mov  dx, p_CR6		       ;    Write CR6 to stop receiver
			      C ;	in   eax, dx
			      C ;	and  eax, NOT CR6_M_RXSC
 113D  66| 2E: A1 1878 R      C 	mov	eax, PortConfigCR6
 1142  66| 83 E0 FD	      C 	and	eax, NOT CR6_M_RXSC
 1146  66| 2E: A3 1878 R      C 	mov	PortConfigCR6, eax
			      C ;;-+
 114B  E8 0FCE		      C 	call PortCR6Write
 114E  2E: 8B 16 246B R	      C 	mov  dx, p_CR7		       ;    Write CR7 to mask RXCIE interrupt
 1153  66| ED		      C 	in   eax, dx
 1155  66| 83 E0 BF	      C 	and  eax, NOT CR7_M_RXCIE
 1159  66| EF		      C 	out  dx, eax
 115B  5A		      C 	pop  dx
 115C  66| 58		      C 	pop  eax
 115E  C3		      C 	ret
 115F			      C RcvDisable  ENDP
			      C 
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Page 12 - 1


			      C 	PAGE
			      C ;--------------------------------------------------------------------+
			      C ; Name : RcvMain
			      C ;
			      C ; Description:
			      C ; This routine is responsible for processing frames received from the adapter.
			      C ; This involves verifying the receive status, and rejecting the frame if there
			      C ; are errors. Additionally, this function determines the type of frame that
			      C ; has been received, and translates the frame appropriately.
			      C ;
			      C ; Enter :
			      C ; Return :
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C ;;EXTRN   RxHangCounter : DWORD
			      C ;;++, 980306, Hu-Tiong
			      C ps	macro	ch
			      C 	push	ax
			      C 	mov	al, ch
			      C 	int	0bbh
			      C 	pop	ax
			      C 	endm
			      C ;;++
			      C 
			      C 	 PUBLIC  RcvMain
 115F			      C RcvMain  PROC  NEAR
 115F  06		      C 	push	es
			      C 
 1160  FA		      C 	cli
 1161  B0 01		      C 	mov  al, 1
 1163  2E: 86 06 1027 R	      C 	xchg RcvSemaphore, al
 1168  3C 00		      C 	cmp  al, 0
 116A  0F 85 00C5	      C 	jne  rm_reentered
			      C 
 116E  66| 2B F6	      C 	sub  esi, esi
 1171  66| 2B FF	      C 	sub  edi, edi
			      C 
 1174			      C rm_loop:			      ;    while (
 1174  2E: 8B 36 1028 R	      C 	mov  si, RcvCurrentDescriptor ;      current descriptor owned by host)
 1179  66| 8B 04	      C 	mov  eax, [si].RCV_DESCRIPTOR.RDES0
 117C  66| A9 80000000	      C 	test eax, RDES0_M_OWN
 1182  0F 85 00A8	      C 	jne  rm_exit		;; Jump, if OWN = DM9100
			      C    ;; Ownership = Host
			      C ;;++, 980414, Hu-Tiong
 1186  66| 8B D8	      C mov	ebx, eax
 1189  66| 81 E3 00000300     C and	ebx, (RDES0_M_BD OR RDES0_M_ED)
 1190  66| 81 FB 00000300     C cmp	ebx, (RDES0_M_BD OR RDES0_M_ED) ; if packet spread over one descriptor
 1197  74 05		      C je	good_pkt_1			; jump if not (it's a leagle packet)
			      C 
 1199  E8 0099		      C call	RcvPostFreeDescriptor
 119C  EB D6		      C jmp	rm_loop
			      C 
 119E			      C good_pkt_1:
			      C ;;++
 119E  66| 8B D8	      C     mov  ebx, eax		  ; Check if rdes0.frame_length=0x7FFF
 11A1  66| 81 E3 7FFF0000     C     and  ebx, RDES0_M_LENGTH
 11A8  66| 81 FB 7FFF0000     C     cmp  ebx, RDES0_M_LENGTH
 11AF  75 05		      C     jne   rm_chk_err		  ; Didn't find RX hang - go to check frame's
			      C 				  ; status
			      C 
 11B1  E8 0E04		      C     call PortUpdateReceiveFilter  ; Reset chip to handle RX hang
 11B4  EB 78		      C     jmp  rm_exit
			      C 
 11B6			      C rm_chk_err:
 11B6  2E: C7 06 02B0 R	      C 	mov  RxHangCounter, 1
       0001
			      C 
 11BD  66| A9 00008000	      C 	test eax, RDES0_M_ES	      ;       if (error summary set) {
 11C3  74 13		      C 	jz   SHORT rm_fmc_stat_ok
			      C 
 11C5  66| 2E: FF 06 0000 E   C 	inc	errors_in		;; For statistics
 11CB  66| A9 00000002	      C 	test eax, RDES0_M_CE	      ; 	 if (CRC_ERR)
 11D1  74 00		      C 	jz   SHORT rm_not_crc_err
			      C 
 11D3			      C rm_not_crc_err:
 11D3  E8 005F		      C 	call RcvPostFreeDescriptor    ; 	 RcvPostFreeDescriptor
 11D6  EB 9C		      C 	jmp  rm_loop
			      C 
 11D8			      C rm_fmc_stat_ok: 		      ;       } else {
 11D8  8B 7C 10		      C 	mov  di, [si].RCV_DESCRIPTOR.p_RcvBuffer   ; DS:DI points to buffer
			      C 
 11DB			      C rm_not_mcast:
 11DB  66| 8B 0C	      C 	mov  ecx, [si].RCV_DESCRIPTOR.RDES0
 11DE  66| 81 E1 7FFF0000     C 	and  ecx, RDES0_M_LENGTH      ; 	 Mask off, and shift rcv
 11E5  66| C1 E9 10	      C 	shr  ecx, RDES0_V_LENGTH      ; 	 length to EAX<14:0>
 11E9  83 E9 04		      C 	sub  cx, 4		      ; 	 Sub 4 CRC bytes
			      C ;;--, 980611, Hu-Tiong, for DM9102 cut4
			      C COMMENT %
			      C ;;++, 980303, Hu-Tiong
			      C ;
			      C ; Data error occasually occurrs wile the MAC move the data of received frame
			      C ; from FIFO to host memory.
			      C ;
			      C 	cmp	ChipType, DM9102_CHIP
			      C 	jne	NoDataError
			      C 
			      C 	push	di			; resevee packet buffer pointer
			      C 	push	si			; reserve current descriptor pointer
			      C 	push	cx			; reserve packet length
			      C 
			      C 	mov	bx, di
			      C 	add	bx, cx
			      C 	mov	edx, [bx]		; EDX = original CRC value
			      C 	push	edx			; reserve original CRC
			      C 
			      C 	mov	si, di			; DS:SI -> data buffer
			      C 	call	CalcCRC 		; result CRC will replace original one
			      C 
			      C 	pop	edx			; restore original CRC
			      C 
			      C 	pop	cx			; restore packet length
			      C 	pop	si			; restore current descriptor pointer
			      C 	pop	di
			      C 
			      C 	cmp	eax, edx		; if new CRC = original CRC
			      C 	jne	rm_not_crc_err		; jump if not (data error occurrs)
			      C NoDataError:
			      C ;;++
			      C %
			      C ;;--------------------------------------------------------------------------
 11EC  8C C8		      C 	mov ax, cs			; Set ds = code
 11EE  8E D8		      C 	mov ds, ax
 11F0  8E C0		      C 	mov es,ax
			      C 
 11F2  83 C7 0C		      C 	add	di, 12			;; Point to Frame type field
 11F5  B2 01		      C 	mov	dl, BLUEBOOK		;assume bluebook Ethernet.
 11F7  66| 8B 04	      C 	mov	eax, [si].RCV_DESCRIPTOR.RDES0
 11FA  66| A9 00000020	      C 	test	eax, RDES0_M_FT
 1200  75 04		      C 	jnz	BlueBookPacket		;; Frame length > 1500
 1202  47		      C 	inc	di			;set di to 802.2 header
 1203  47		      C 	inc	di
 1204  B2 0B		      C 	mov	dl, IEEE8023
			      C 
 1206			      C BlueBookPacket:
 1206  56		      C 	push	si
 1207  51		      C 	push	cx
 1208  E8 0000 E	      C 	call	recv_find
 120B  59		      C 	pop	cx
 120C  5E		      C 	pop	si
			      C 
 120D  72 16		      C 	jc	rcv_no_copy
			      C 
 120F  FC		      C 	cld			; Copies below are forward, please
 1210  8C C0		      C 	mov ax, es		; Did recv_find give us a null pointer?
 1212  0B C7		      C 	or ax,	di		; ..
 1214  74 0F		      C 	je	rcv_no_copy	; If null, don't copy the data
			      C 
 1216  51		      C 	push	cx		; We will want the count and pointer
 1217  06		      C 	push	es		;  to hand to client after copying,
 1218  57		      C 	push	di		;  so save them at this point
 1219  8B 44 10		      C 	mov  ax, [si].RCV_DESCRIPTOR.p_RcvBuffer   ; AX points to DES's buffer
			      C 
 121C  E8 EE05		      C 	call	block_input
			      C 
 121F			      C rcv_copy_ok:
 121F  5E		      C 	pop	si		; Recover pointer to destination
 1220  1F		      C 	pop	ds		; Tell client it's his source
 1221  59		      C 	pop	cx		; And it's this long
			      C 	assume	ds:nothing
 1222  E8 0000 E	      C 	call	recv_copy	; Give it to him
			      C 
 1225			      C rcv_no_copy:
			      C 	movseg	ds,cs
 1225  0E		     1C 	push	cs
 1226  1F		     1C 	pop	ds
			      C 	assume	ds:code
			      C 
 1227			      C rcv_copy_deferred:
			      C 
 1227  FA		      C 	cli
			      C 
 1228  E8 000A		      C 	call RcvPostFreeDescriptor    ; 	 call RcvPostFreeDescriptor
 122B  E9 FF46		      C 	jmp	rm_loop
			      C 
 122E			      C rm_exit:
 122E  C6 06 1027 R 00	      C 	mov RcvSemaphore, 0
 1233			      C rm_reentered:
 1233  07		      C 	pop	es
 1234  C3		      C 	ret
			      C 
 1235			      C RcvMain  ENDP
			      C 
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Page 13 - 1


			      C 	PAGE
			      C ;--------------------------------------------------------------------+
			      C ; Name : RcvPostFreeDescriptor
			      C ;
			      C ; Description:
			      C ; This function simply flips the ownership bit of the RcvCurrentDescriptor
			      C ; to the DM9100, and updates the RcvCurrentDescriptor pointer.
			      C ;
			      C ; Enter :
			      C ; Return :
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C 	 PUBLIC RcvPostFreeDescriptor
 1235			      C RcvPostFreeDescriptor  PROC  NEAR
 1235  9C		      C 	pushf
 1236  FA		      C 	cli
 1237  8B 36 1028 R	      C 	mov  si, RcvCurrentDescriptor	; Get pointer current descriptor
 123B  66| C7 04 80000000     C 	mov  [si].RCV_DESCRIPTOR.RDES0, RDES0_M_OWN ; Set ownership to 90100
 1242  8B 44 12		      C 	mov  ax, [si].RCV_DESCRIPTOR.p_RcvNext
 1245  A3 1028 R	      C 	mov  RcvCurrentDescriptor, ax	; Updatte RcvCurrentDescriptor
			      C 
 1248  9D		      C 	popf
			      C 
 1249  C3		      C 	ret
 124A			      C RcvPostFreeDescriptor  ENDP
			      C 
			      C EXTRN	rcv_mode_num : WORD
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Page 14 - 1


			      C 	PAGE
			      C ;--------------------------------------------------------------------+
			      C ; Name : RcvEnable
			      C ;
			      C ; Description: This function enables the receipt of frames from the adapter.
			      C ;
			      C ; Enter :
			      C ;
			      C ; Return : Nothing
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C 	PUBLIC RcvEnable
 124A			      C RcvEnable  PROC  NEAR
 124A  66| 50		      C 	push eax
 124C  66| 53		      C 	push ebx
 124E  52		      C 	push dx
			      C 
 124F  C7 06 1025 R 0001      C 	mov  RcvState, 1
			      C 
 1255  66| A1 1021 R	      C 	mov  eax, p_RcvRingPhys 	;    Write CR3 with p_RcvRingPhys
 1259  8B 16 2463 R	      C 	mov  dx, p_CR3
 125D  66| EF		      C 	out  dx, eax
 125F  8B 16 246B R	      C 	mov  dx, p_CR7		       ;    Clear NISE and RXCIE in CR7
 1263  66| ED		      C 	in   eax, dx
			      C ;;;	   or	eax, 0FFFFFFFFh
 1265  66| 0D 00010041	      C 	or   eax, (CR7_M_NISE OR CR7_M_RXCIE OR CR7_M_TXCIE)
 126B  66| EF		      C 	out  dx, eax
 126D  8B 16 246D R	      C 	mov  dx, p_CR8		       ;    Read to clear CR8
 1271  66| ED		      C 	in   eax, dx
			      C ;;-+, 2000.2.16, hu-tiong
			      C ;	mov  dx, p_CR6		       ;    Write CR6 to...
			      C ;	in   eax, dx
 1273  66| A1 1878 R	      C 	mov	eax, PortConfigCR6
			      C ;;-+
 1277  66| 83 C8 02	      C 	or   eax, CR6_M_RXSC		 ;    start the receiver...
 127B  66| 25 FFFFFF7F	      C 	and  eax, NOT CR6_M_PAM 	;    Clear PASS_ALL_MULTICAST
 1281  83 3E 0000 E 06	      C 	cmp	rcv_mode_num, 6 	;; Promiscuous mode ?
 1286  75 06		      C 	jne	re_nopr
 1288  66| 83 C8 40	      C 	or	eax, CR6_M_PM
 128C  EB 04		      C 	jmp	pr_write_CR6
			      C 
 128E			      C re_nopr:
 128E  66| 83 E0 BF	      C 	and  eax, NOT CR6_M_PM	       ;    Clear promiscuous
			      C 
 1292			      C pr_write_CR6:
			      C ;;++, 2000.2.16, hu-tiong
 1292  66| A3 1878 R	      C 	mov	PortConfigCR6, eax
			      C ;;++
 1296  E8 0E83		      C 	call PortCR6Write
 1299  5A		      C 	pop  dx
 129A  66| 5B		      C 	pop  ebx
 129C  66| 58		      C 	pop  eax
 129E  C3		      C 	ret
 129F			      C RcvEnable  ENDP
			      C  
			      C 
			      C include srom.asm
			      C PAGE	,132
			      C NAME	SROM
			      C TITLE	SROM  --  UMC Internal Use Only
			      C 
			      C ;***************************************************************************
			      C ;*
			      C ;***************************************************************************
			      C ;
			      C ; This file contains all of the routines which manage the 9346 SROM.
			      C ;
			      C ; Originator: Spenser Tsai
			      C ;
			      C ; Functions:
			      C ;	. SROMDelay
			      C ;	. MakeSureSROMIdle
			      C ;	. ReadSROMWord
			      C ;	. ReadSROM
			      C ;
			      C ; Maintainers:
			      C ;
			      C ; Revision History:
			      C ;
			      C .xlist			; Disable listing the include files
			      C .list			; Enable listing
			      C 
			      C ;;SET_CPU_TYPE
			      C .386p
			      C 
			      C 
 16C4 0000		      C SROM_Word_Address	DW 0	; Word address for word read from SROM
 16C6 00000000		      C SROM_Data_Read		DD 0	; Holds in low part a word read from SROM
			      C 
			      C ;CR9 Register Bit Definition:
			      C ;----------------------------
 = 0001			      C CR9_CRCS	EQU	0001h		;Chip_Select to EEPROM
 = 0002			      C CR9_CRCLK	EQU	0002h		;Clock to EEPROM
 = 0004			      C CR9_CRDIN	EQU	0004h		;Data_In to EEPROM
 = 0008			      C CR9_CRDOUT	EQU	0008h		;Data_Out to EEPROM
 = 0800			      C CR9_ERS 	EQU	 800h		;EEPROM Selected
 = 1000			      C CR9_BRS 	EQU	1000h		;Boot ROM Selected
 = 2000			      C CR9_MWC 	EQU	2000h		;Memory Write Control
 = 4000			      C CR9_MRC 	EQU	4000h		;Memory Read Control
 = 00010000		      C CR9_MDCLKH	EQU    10000h		;MII Management Clock
 = 00020000		      C CR9_MDOUTH	EQU    20000h		;MII Management Data_Out
 = 00040000		      C CR9_MREAD	EQU    40000h		;MII Management Read/Write Mode Selection
 = 00080000		      C CR9_MDIN	EQU    80000h		;MII Management Data_In
			      C 
 = 0000			      C CR9_MDCLKL	EQU    00000h		;MII Management Clock Low
 = 0000			      C CR9_MDOUTL	EQU    00000h		;MII Management Data_Out Low
 = 0000			      C CR9_MWRITE	EQU    00000h		;MII Management Read/Write Mode Selection
			      C 
 = 0019			      C SROM_MAX_DELAY		EQU	25
 = 0006			      C SROM_ADDRESS_BIT_NUM	EQU	6
			      C 
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Page 15 - 1


			      C 	PAGE
			      C ;*************
			      C ;* SROMDelay *
			      C ;*************
			      C ;
			      C ;	SROM_93LC46B spec calls for ~840 nSEC of delay between various
			      C ;	activities.
			      C ;	PortReadTickCounter gives 419 nsec per count. We therefore have to
			      C ;	delay ~ 2 - 3 count ticks. For extra caution we wait 4 ticks.
			      C ;
			      C 	PUBLIC	SROMDelay
 16CA			      C SROMDelay  proc    near
 16CA  FA		      C 	cli
 16CB  50		      C 	push	ax
 16CC  53		      C 	push	bx
 16CD  E8 08DB		      C 	call	PortReadTickCounter	;Get initial value, Return counter value = AX
 16D0  8B D8		      C 	mov	bx, ax			;Save start value
			      C 
 16D2			      C Srom_loop:				 ; Loop till 4 ticks have gone by
 16D2  E8 08D6		      C 	call	PortReadTickCounter
 16D5  F7 D8		      C 	neg	ax
 16D7  03 C3		      C 	add	ax, bx			;Get difference
 16D9  83 F8 04		      C 	cmp	ax, 4
 16DC  72 F4		      C 	jb	SHORT Srom_loop
 16DE  5B		      C 	pop	bx
 16DF  58		      C 	pop	ax
 16E0  FB		      C 	sti
 16E1  C3		      C 	ret
 16E2			      C SROMDelay  endp
			      C 
			      C 
			      C ;+****************************************************************************+
			      C ; ReadSROMWord
			      C ;
			      C ;  Read the SROM WORD content from MII Management Interface.
			      C ;
			      C ;  Entrys:	SI = Offset Address of the SROM content
			      C ;
			      C ;  Returns:	DI = Read SROM Data (Word)
			      C ;
			      C ;  Preserved :	None
			      C ;
			      C ;  Called by:	ReadSROM
			      C ;
			      C ;-****************************************************************************-
 16E2			      C ReadSROMWord	  proc	  near
 16E2  56		      C 	push	si
 16E3  57		      C 	push	di
 16E4  53		      C 	push	bx
 16E5  51		      C 	push	cx
 16E6  52		      C 	push	dx
 16E7  8B F0		      C 	mov	si, ax
			      C 
			      C 	;SromRWInit - SROM Read Write Init
			      C 	;---------------------------------
 16E9  8B 16 246F R	      C 	mov	dx, p_CR9
 16ED  66| B8 00002800	      C 	mov	eax, CR9_MWC or CR9_ERS 	;Select SRom access
 16F3  66| EF		      C 	out	dx, eax
			      C 
			      C 	;SromIdle - SROM Make Sure Idle
			      C 	;------------------------------
 16F5  0C 01		      C 	or	al, CR9_CRCS			;Select SRom
 16F7  66| B9 00000019	      C 	mov	ecx, SROM_MAX_DELAY
 16FD			      C GenerateRWSequenceSignals:
 16FD  0C 02		      C 	or	al, CR9_CRCLK			;Clock UP
 16FF  66| EF		      C 	out	dx, eax
 1701  E8 00FB		      C 	call	Delay10us
			      C 
 1704  24 FD		      C 	and	al, not CR9_CRCLK		;Clock DOWN
 1706  66| EF		      C 	out	dx, eax
 1708  E8 00F4		      C 	call	Delay10us
 170B  E2 F0		      C 	loop	GenerateRWSequenceSignals
			      C 
 170D  24 FE		      C 	and	al, not CR9_CRCS		;DeSelect SRom
 170F  66| EF		      C 	out	dx, eax
 1711  E8 00EB		      C 	call	Delay10us
			      C 
			      C 	;SromRdOp - SROM Read Operation (Out CR9, 1-1-0 Sequence)
			      C 	;Initiate Read data sequence and signals
			      C 	;---------------------------------------------------------
 1714  0C 01		      C 	or	al, CR9_CRCS			;Select SRom
			      C 
			      C 	;1. Write 1
			      C 	;Output READ command to the SROM (sequence of 110)
			      C 	;-------------------------------------------------
 1716  83 C8 04		      C 	or	ax, CR9_CRDIN			;Write 1
 1719  66| EF		      C 	out	dx, eax
			      C 
 171B  83 C8 02		      C 	or	ax, CR9_CRCLK			;clock UP
 171E  66| EF		      C 	out	dx, eax
 1720  E8 00DC		      C 	call	Delay10us
			      C 
 1723  83 E0 FD		      C 	and	ax, NOT CR9_CRCLK		;Clock DOWN
 1726  66| EF		      C 	out	dx, eax
 1728  E8 00D4		      C 	call	Delay10us
			      C 
			      C 	;2. Write 1
			      C 	;----------
 172B  66| EF		      C 	out	dx, eax 			;Write 1
			      C 
 172D  83 C8 02		      C 	or	ax, CR9_CRCLK			;Clock UP
 1730  66| EF		      C 	out	dx, eax
 1732  E8 00CA		      C 	call	Delay10us
			      C 						;Clock DOWN
 1735  83 E0 FD		      C 	and	ax, NOT CR9_CRCLK
 1738  66| EF		      C 	out	dx, eax
 173A  E8 00C2		      C 	call	Delay10us
			      C 
			      C 	;3. Write 0
			      C 	;----------
 173D  83 E0 FB		      C 	and	ax, NOT CR9_CRDIN
 1740  66| EF		      C 	out	dx, eax 			;Write 0
			      C 
 1742  83 C8 02		      C 	or	ax, CR9_CRCLK			;Clock UP
 1745  66| EF		      C 	out	dx, eax
 1747  E8 00B5		      C 	call	Delay10us
			      C 						;Clock DOWN
 174A  83 E0 FD		      C 	and	ax, NOT CR9_CRCLK
 174D  66| EF		      C 	out	dx, eax
 174F  E8 00AD		      C 	call	Delay10us
			      C 
			      C 	;SromAddressSetup - SROM Address Setup
			      C 	;Output the WORD Address of the SROM (Bit by Bit from MSB to LSB)
			      C 	;----------------------------------------------------------------
 1752  66| B9 00000006	      C 	mov	ecx, SROM_ADDRESS_BIT_NUM	;Here we assume size<=8Bit
			      C 						;Cx holds the number of address bits
 1758  56		      C 	push	si				;SROM index
			      C 
 1759			      C RSW_WriteAddressBitx:
 1759  5E		      C 	pop	si
 175A  56		      C 	push	si				;for correct shifting
 175B  FE C9		      C 	dec	cl
 175D  D3 EE		      C 	shr	si, cl				;shift the appropriate address bit
 175F  FE C1		      C 	inc	cl				;restore cl
 1761  83 E6 01		      C 	and	si, 1				;mask all irrelevant address bits
 1764  C1 E6 02		      C 	shl	si, 2				;Align to Data bit loacation (in CR9)
 1767  83 E0 FB		      C 	and	ax, not CR9_CRDIN		;Clear prev. address bit
 176A  0B C6		      C 	or	ax, si				;Move the address bit to ax
 176C  66| EF		      C 	out	dx, eax 			;Write it to CR9
			      C 
 176E  83 C8 02		      C 	or	ax, CR9_CRCLK
 1771  66| EF		      C 	out	dx, eax 			;Clock UP
 1773  E8 0089		      C 	call	Delay10us
			      C 
 1776  83 E0 FD		      C 	and	ax, not CR9_CRCLK
 1779  66| EF		      C 	out	dx, eax 			;Clock DOWN
 177B  E8 0081		      C 	call	Delay10us
			      C 
 177E  E2 D9		      C 	loop	RSW_WriteAddressBitx
			      C 
 1780  5E		      C 	pop	si				;Restor SI
			      C 
			      C 	;Verify that the SROM output data became now 0.
			      C 	;----------------------------------------------
 1781  66| ED		      C 	in	eax, dx
 1783  66| A9 00000008	      C 	test	eax, CR9_CRDOUT
 1789  75 41		      C 	jnz	SHORT RSW_ReadFailedx
			      C 
			      C 	;SromDataIn - SROM Data In
			      C 	;Input the WORD of data from the SROM
			      C 	;------------------------------------
 178B  33 FF		      C 	xor	di, di
 178D  66| B9 00000010	      C 	mov	ecx, 16
			      C 
 1793			      C RSW_ReadBitx:
			      C 	;Clock UP (with appropriate signals)
			      C 	;-----------------------------------
 1793  66| B8 00002803	      C 	mov	eax, CR9_MWC or CR9_ERS or CR9_CRCS or CR9_CRCLK
 1799  66| EF		      C 	out	dx, eax
 179B  E8 0061		      C 	call	Delay10us
			      C 
			      C 	;Read the "CX" bit in the word
			      C 	;-----------------------------
 179E  66| ED		      C 	in	eax, dx
 17A0  C1 E8 03		      C 	shr	ax, 3			;Mov the databit to Bit0
 17A3  83 E0 01		      C 	and	ax, 1			;Clear all othe bits
 17A6  49		      C 	dec	cx
 17A7  D3 E0		      C 	shl	ax, cl			;Mov the data bit to its relative
 17A9  41		      C 	inc	cx			;location in WORD
			      C 
			      C 	;Store the bit in the temporary data storage
			      C 	;-------------------------------------------
 17AA  0B F8		      C 	or	di, ax
			      C 
			      C 	;SromLeave - SROM Leave
			      C 	;Clock DOWN (with appropriate signals)
			      C 	;-------------------------------------
 17AC  66| B8 00002801	      C 	mov	eax, CR9_MWC or CR9_ERS or CR9_CRCS
 17B2  66| EF		      C 	out	dx, eax
 17B4  E8 0048		      C 	call	Delay10us
			      C 
 17B7  E2 DA		      C 	loop	RSW_ReadBitx
			      C 
 17B9  8B FF		      C 	mov	di,di
 17BB  8B FF		      C 	mov	di,di
 17BD  8B FF		      C 	mov	di,di
 17BF  8B FF		      C 	mov	di,di
			      C 
			      C 	;Negate the CS (chip select) to end the SROM command
			      C 	;---------------------------------------------------
 17C1  66| B8 00002800	      C 	mov	eax, CR9_MWC or CR9_ERS
 17C7  66| EF		      C 	out	dx, eax
 17C9  E8 0033		      C 	call	Delay10us
			      C 
 17CC			      C RSW_ReadFailedx:
 17CC  8B C7		      C 	mov	ax, di
			      C 
 17CE  5A		      C 	pop	dx
 17CF  59		      C 	pop	cx
 17D0  5B		      C 	pop	bx
 17D1  5F		      C 	pop	di
 17D2  5E		      C 	pop	si
			      C 
 17D3  C3		      C 	ret
 17D4			      C ReadSROMWord	  endp
			      C 
			      C ;+****************************************************************************+
			      C ; Delay419ns
			      C ;
			      C ;  Delay 419 nsec. (1 tick)
			      C ;
			      C ;  Entrys:	DelayTickCount
			      C ;		Interrupts disabled
			      C ;
			      C ;  Returns:	None
			      C ;		Interrupts disabled
			      C ;
			      C ;  Preserved :	None
			      C ;
			      C ;  Called by:	Delay10us
			      C ;
			      C ;-****************************************************************************-
			      C 
 17D4 0000		      C DelayTickCount	dw	0
			      C 
 17D6			      C Delay419ns	proc	near
			      C 
 17D6  66| 50		      C 	push	eax
 17D8  66| 53		      C 	push	ebx
 17DA  66| 51		      C 	push	ecx
			      C 
			      C 	;Read the Timer Tick Counter
			      C 	;(The Timer Tick Counter decreases from 65536 to 0 by 2)
			      C 	;-------------------------------------------------------
 17DC  E8 07CC		      C 	call	PortReadTickCounter
 17DF  8B D8		      C 	mov	bx, ax				;BX = Start Tick Count (decrease)
 17E1			      C WaitDelay419nsLoop:
 17E1  E8 07C7		      C 	call	PortReadTickCounter
 17E4  8B CB		      C 	mov	cx, bx
 17E6  2B C8		      C 	sub	cx, ax				;AX = Last Tick Count (decrease)
			      C 
 17E8  3B 0E 17D4 R	      C 	cmp	cx, DelayTickCount
 17EC  72 F3		      C 	jb	WaitDelay419nsLoop
			      C 
 17EE  66| 59		      C 	pop	ecx
 17F0  66| 5B		      C 	pop	ebx
 17F2  66| 58		      C 	pop	eax
 17F4  C3		      C 	ret
			      C 
 17F5			      C Delay419ns	endp
			      C 
			      C 
			      C ;+****************************************************************************+
			      C ; Delay1us
			      C ;
			      C ;  Delay 1 usec. (about 2 ticks)
			      C ;
			      C ;  Entrys:	Time delay in Counts (1 Count=419nsec) passed on stack.
			      C ;		Interrupts disabled
			      C ;
			      C ;  Returns:	None
			      C ;		Interrupts disabled
			      C ;
			      C ;  Preserved :	None
			      C ;
			      C ;  Called by:	ResetMIIPHY, Delay500us
			      C ;
			      C ;-****************************************************************************-
			      C 
 17F5			      C Delay1us  proc	  near
			      C 
 17F5  C7 06 17D4 R 0002      C 	mov	DelayTickCount, 2		;2 ticks = 1 usec
 17FB  E8 FFD8		      C 	call	Delay419ns
 17FE  C3		      C 	ret
			      C 
 17FF			      C Delay1us  endp
			      C 
			      C ;+****************************************************************************+
			      C ; Delay10us
			      C ;
			      C ;  Delay 10 usec for waiting DM9100 NIC Reset stability.
			      C ;
			      C ;  Entrys:	None
			      C ;		Interrupts disabled
			      C ;
			      C ;  Returns:	None
			      C ;
			      C ;  Preserved :	None
			      C ;
			      C ;  Called by:	ResetDM910X, ResetMIIPHY
			      C ;
			      C ;-****************************************************************************-
			      C 
 17FF			      C Delay10us	proc	near
			      C 
 17FF  66| 51		      C 	push	ecx
			      C 
 1801  66| B9 0000000A	      C 	mov	ecx, 10 		;Delay 10 usec
 1807			      C WaitDelay10usLoop:
 1807  E8 FFEB		      C 	call	Delay1us
 180A  E2 FB		      C 	loop	WaitDelay10usLoop
			      C 
 180C  66| 59		      C 	pop	ecx
 180E  C3		      C 	ret
			      C 
 180F			      C Delay10us	endp
			      C 
			      C ;=================================================================
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Page 16 - 1


			      C     PAGE
			      C 
			      C ;************
			      C ;* ReadSROM *
			      C ;************
			      C ; Reads the entire SROM into an internal driver buffer (which is later reused
			      C ; for receive buffer.
			      C ; It's legacy if CRC check error.
			      C ;
			      C ; CX - Holds num of words to read.
			      C ; SI - (Near) pointer into where to read.
			      C ;
			      C ; Return: Carry set if read failed
			      C ;
			      C 	ALIGN 4
			      C 	PUBLIC ReadSROM
 1810			      C ReadSROM	PROC	NEAR
 1810  50		      C 	push	ax
 1811  53		      C 	push	bx
 1812  56		      C 	push	si
			      C 
 1813  BB 0000		      C 	mov	bx, 0  ; Offset in SROM
 1816  8B C3		      C 	mov	ax, bx	;; AX=BX=0
			      C 
 1818			      C read_loop:
 1818  E8 FEC7		      C 	call	ReadSROMWord	;; Return Word = AX
			      C ;;;;	jc	rs_exit
			      C 
 181B  88 04		      C 	mov	[si], al
 181D  46		      C 	inc	si
 181E  88 24		      C 	mov	[si], ah
 1820  46		      C 	inc	si
 1821  43		      C 	inc	bx		;; Num of word counter
 1822  8B C3		      C 	mov	ax, bx		;; SROM address
 1824  E2 F2		      C 	loop	read_loop
			      C 
			      C ; Check validity of CRC
			      C ;-----------------------
 1826  83 EE 02		      C 	sub	si, 2
 1829  8B 1C		      C 	mov	bx, WORD PTR [si]   ; BX stores two low bytes of CRC
 182B  B9 007E		      C 	mov	cx, 126
 182E  2B F1		      C 	sub	si, cx
			      C 
 1830  66| 50		      C 	push	eax		    ; save registers as CRC calc destoyes
 1832  66| 53		      C 	push	ebx
 1834  57		      C 	push	di
 1835  56		      C 	push	si
 1836  9C		      C 	pushf
			      C 
 1837  E8 FE66		      C 	call	CalcCRC
			      C 
 183A  9D		      C 	popf
 183B  5E		      C 	pop	si
 183C  5F		      C 	pop	di
 183D  66| 5B		      C 	pop	ebx
 183F  66| 58		      C 	pop	eax
			      C 
 1841  83 C6 7E		      C 	add	si, 126 	   ; Compare calculated CRC
 1844  8B 0C		      C 	mov	cx, WORD PTR [si]
 1846  3B CB		      C 	cmp	cx, bx
 1848  74 01		      C 	je	rs_exit
			      C 
 184A  F9		      C 	stc			  ; Error: Incorrect CRC
			      C 
 184B			      C 	rs_exit:
 184B  5E		      C 	pop	si
 184C  5B		      C 	pop	bx
 184D  58		      C 	pop	ax
 184E  C3		      C 	ret
 184F			      C ReadSROM ENDP
			      C 
			      C 
			      C  
			      C 
			      C include port.asm
			      C ;*****************************************************************************
			      C ;* Name : PORT.ASM
			      C ;*
			      C ;* All rights reserved by DAVICOM, 1996
			      C ;*
			      C ;* Description :
			      C ;*
			      C ;* Functions :
			      C ;*      . PortInit
			      C ;*      . PortReadTickCounter
			      C ;*      . PortUpdateReceiveFilter
			      C ;*      . PortReset
			      C ;*      . PortResetDelay
			      C ;*      . PortPrintMessage
			      C ;*      . PortCR6Write
			      C ;*      . DM9009_Media
			      C ;*      . DM9009_Link_Check
			      C ;*
			      C ;
			      C ; Maintainers:
			      C ;
			      C ; John H.T. Ho          htho
			      C ;
			      C ;
			      C ; Revision History:
			      C ;
			      C ; Date       Modfier.   Modification Descriptions
			      C ; ---------- ---------- ------------------------------------------
			      C ; 2000.1.31     htho    support 1M HomePNA
			      C ;
			      C ; 2000.2.16     htho    dynamicaly keep a image of CR6 in [PortConfigCR6]
			      C ;
			      C ; 2000.2.21     htho    while PortReset(), set [PortConfigCR6] to CR6_DEFAULT
			      C ;                       first then set [PortConfigCR6] and CR6 according to
			      C ;                       system configuration
			      C ;
			      C ; 2000.3.9      htho    reset Ignore Remote Commands bit of DM9801 Reg 16
			      C ;                       and set the noise level for long line
			      C ;
			      C ; 2000.3.27     htho    check if PNAPHY is there before accessing it
			      C ;                       select PNAPHY before setting noise level
			      C ;                       change CR6_DEFAULT from 002C0000h to 02040000h
			      C ;                       reset noise level while dynamic auto detect select dm9801
			      C ;
			      C ; 2000.4.6      htho    rewrite check auto complete flow
			      C ;                       won't do dynamic auto detect if force media to HomePNA
			      C ;
			      C ; 2000.5.2      htho    support LONGRUN HomePNA:
			      C ;                       set Reg 16, 25 in PortReset() and DynamicAutoDetect()
			      C ;
			      C ; 2000.6.21     htho    set speed/power for HOMEPNA
			      C ;
			      C ; 2000.6.27     htho    set ignore/send remote command for HOMEPNA
			      C ;                       rewrite PNA PHY setting
			      C ;                       switching adapter support
			      C ;
			      C ; 2000.8.24     htho    support DM9009(DM9102 without 100M PHY capability)
			      C ;                       support VLAN & Tx/Rx flow control
			      C ;
			      C ; 2000.9.19     htho    support DM9801 E4
			      C ;
			      C ; 2000.10.4     htho    simulate line plug out/in by power off/on phy for DM9102A E3
			      C ;
			      C ; 2001.3.30     htho    support HPNA speed setting
			      C ;
			      C ; 2001.5.25     htho    different 9801 R24/R25 operation between E3 and E4/5...
			      C ;
			      C ; 2001.6.12     htho    default lspeed=1000 instead of 700
			      C ;
			      C ; 2001.6.12     htho    error CR31 value while lseedp=500 for homerun
			      C ;
			      C ; 2000.6.12     htho    renew nway algorithm. If partner nway incapable,
			      C ;                       disable nway and force it to the mode that user set
			      C ;
			      C ; 2001.6.12     htho    we need to write at last 2 times to dm9102a E3 to
			      C ;                       force it to correct mode after power on/off it
			      C ;
			      C ; 2001.6.21     htho    dual speed hub link fail while forced 10/100 full duplex
			      C ;
			      C ; 2001.8.13     htho    Reset PNA PHY to avoid accumulation of Noise Floor in
			      C ;                       Reg. 25 of DM9801 E3 while user warm restart the PC
			      C ;                       or unload/load driver again.
			      C ;                       This reset must take the PNA PHY a few seconds to
			      C ;                       reach a stable state, so we must pospond the pna phy
			      C ;                       setting some time later (after startup auto).
			      C ;*
			      C ;*****************************************************************************
			      C .386
			      C 
			      C include dm9100.mac
			      C 
			      C ;********************
			      C ;* DSSI_TO_PHYSICAL *
			      C ;********************
			      C ;
			      C ; This macro expands to the operating system specific method of converting
			      C ; a virtual address in DS:SI to a physical address in EAX.
			      C ;
			      C 
			      C DSSI_TO_PHYSICAL macro
			      C 
			      C         push ebx
			      C         xor eax,eax
			      C         xor ebx,ebx
			      C         mov ax,ds
			      C         mov bx,si
			      C         shl eax,4
			      C         add eax,ebx
			      C         pop ebx
			      C 
			      C         endm
			      C 
			      C ;
			      C ; The following two macros are used to enable/disable interrupts at the
			      C ; adapter interrupt mask register.
			      C ;
			      C ENABLE_ADAPTER_INTERRUPT MACRO
			      C         push   eax
			      C         push   dx
			      C         mov    dx, p_CR7
			      C         mov    eax, CR7_K_DEFAULT_ON
			      C         out    dx, eax
			      C         pop    dx
			      C         pop    eax
			      C         ENDM
			      C 
			      C DISABLE_ADAPTER_INTERRUPT MACRO
			      C         push   eax
			      C         push   dx
			      C 
			      C         mov    dx, p_CR7
			      C         mov    eax, CR7_K_DEFAULT_OFF
			      C         out    dx, eax
			      C 
			      C         pop    dx
			      C         pop    eax
			      C 
			      C         ENDM
			      C 
			      C ;**********
			      C ;
			      C ; ENTER_ISR
			      C ;
			      C ; This macro expands into the operating system specific preamble for the
			      C ; device ISR. For MS-DOS, a local stack is created.
			      C ; This macro is used in conjunction with the EXIT_ISR macro.
			      C ;
			      C ;**********
			      C 
			      C ENTER_ISR macro
			      C 
			      C ;
			      C ; If this is MSDOS, save all general registers, and the segment registers
			      C ;
			      C         pushad                          ; Save general regs on calling stack
			      C         push    ds                      ; Save the DS on the CALLING stack
			      C         push    es                      ; Save the ES on the CALLING stack
			      C 
			      C         mov     ax, cs                  ; DS = CS
			      C         mov     ds, ax
			      C 
			      C         endm
			      C 
			      C ;**********
			      C ;
			      C ; EXIT_ISR
			      C ;
			      C ; This macro expands into the operating system specific exit code for the
			      C ; device ISR. For MS-DOS, the stack is restored, and a return from
			      C ; interrupt is issued. 
			      C ;
			      C ;**********
			      C 
			      C EXIT_ISR macro
			      C 
			      C ;
			      C ; For MS-DOS, restore the stack, and issue an IRET
			      C ;
			      C 
			      C         pop  es                 ; Restore ES from the CALLING Stack
			      C         pop  ds                 ; Restore DS from the CALLING Stack
			      C 
			      C         popad                   ; Restore general registers
			      C         iret
			      C 
			      C         endm
			      C 
			      C ;**********
			      C ;
			      C ; POP_REGISTERS
			      C ;
			      C ; This macro expands into code to restore the stack.  It is used for DOS
			      C ; interrupt sharing.  Note that the stack in use should be the one used by
			      C ; the caller.
			      C ;
			      C ;**********
			      C 
			      C POP_REGISTERS macro
			      C 
			      C         pop  es                 ; Restore ES from the CALLING Stack
			      C         pop  ds                 ; Restore DS from the CALLING Stack
			      C 
			      C         popad                   ; Restore general registers
			      C 
			      C         endm
			      C 
			      C SAVE_DOS_STACK  macro
			      C 
			      C         mov     cs:[save_int_ss], ss            ;; save the stack
			      C         mov     cs:[save_int_sp], sp            ;; save the stack offset
			      C         mov     ax, cs                          ; SS = CS
			      C         mov     ss, ax
			      C         mov     sp, OFFSET our_stack              ;; set the local stack
			      C         endm
			      C 
			      C RESTORE_DOS_STACK  macro
			      C 
			      C         mov  ss, cs:[save_int_ss]               ;; Restore calling stack
			      C         mov  sp, cs:[save_int_sp]
			      C 
			      C         endm
			      C 
			      C ;**********
			      C ;
			      C ; ACK_PIC_INTERRUPT
			      C ;
			      C ; This macro expands into the operating system specific code to acknowledge
			      C ; the PIC hardware interrupt. 
			      C ;
			      C ;**********
			      C 
			      C ACK_PIC_INTERRUPT macro
			      C         LOCAL   ack_master
			      C 
			      C         mov     al, 20h                 ; issue EOI to PIC(s), Non-specific EOI
			      C         test    CS:PICAckSlave,0FFh
			      C         jz      ack_master
			      C         out     0A0h, al                ; issue EOI to the slave PIC
			      C ack_master:
			      C         out     020h, al                ; issue EOI to the master PIC
			      C 
			      C         endm
			      C 
			      C ;;include hw.inc
			      C include hardware.asd
			      C 
			      C ; This file contains the hardware constants for addressing the UM9100
			      C ; chip on PCI platforms.
			      C ;
			      C 
			      C ;; DEC
			      C ;;PCIID_DM9100_DEVICE_ID	 EQU 00009h
			      C ;;PCIID_VENDOR_ID		 EQU 01011h
			      C 
			      C ;; DAVICOM
			      C ;;PCIID_DM9100_DEVICE_ID	 EQU 09100h
			      C ;;PCIID_VENDOR_ID		 EQU 01060h
			      C 
 = 9102			      C PCIID_DM9102_DEVICE_ID		EQU	9102h
			      C 
 = 9100			      C PCIID_DM9100_DEVICE_ID	       EQU 09100h
 = 1282			      C PCIID_VENDOR_ID 	       EQU 01282h
			      C 
 = 9009			      C PCIID_DM9009_DEVICE_ID		EQU 09009H
			      C 
 = 0000			      C DM9100_CHIP			EQU 0
 = 0001			      C DM9009_CHIP			EQU 1
 = 0002			      C DM9102_CHIP			EQU 2
 = 000A			      C DC21X4_CHIP			EQU 10
			      C 
			      C 
			      C ; Hardware offsets for PCI based Adapter
			      C ;
 = 0000			      C HW_K_REG_CR0		   EQU 000h
 = 0008			      C HW_K_REG_CR1		   EQU 008h
 = 0010			      C HW_K_REG_CR2		   EQU 010h
 = 0018			      C HW_K_REG_CR3		   EQU 018h
 = 0020			      C HW_K_REG_CR4		   EQU 020h
 = 0028			      C HW_K_REG_CR5		   EQU 028h
 = 0030			      C HW_K_REG_CR6		   EQU 030h
 = 0038			      C HW_K_REG_CR7		   EQU 038h
 = 0040			      C HW_K_REG_CR8		   EQU 040h
 = 0048			      C HW_K_REG_CR9		   EQU 048h
 = 0050			      C HW_K_REG_CR10		   EQU 050h
 = 0058			      C HW_K_REG_CR11		   EQU 058h
 = 0060			      C HW_K_REG_CR12		   EQU 060h
 = 0068			      C HW_K_REG_CR13		   EQU 068h
 = 0070			      C HW_K_REG_CR14		   EQU 070h
 = 0078			      C HW_K_REG_CR15		   EQU 078h
			      C 
 = 0000			      C HW_K_REG_PCIID			EQU 00h
 = 0004			      C HW_K_REG_PCICS		     EQU 04h
 = 0008			      C HW_K_REG_PCIRV		     EQU 08h
 = 000C			      C HW_K_REG_PCILT		     EQU 0Ch
 = 0010			      C HW_K_REG_PCIIO		     EQU 10h
 = 003C			      C HW_K_REG_PCIINT 	      EQU 3Ch
 = 0040			      C HW_K_REG_PCIUSR 	      EQU 40h
			      C 
			      C ;
			      C ; Bit mask definitions for CSRs
			      C ;
 = FFF80000		      C CR0_M_RESERVED		       EQU 0FFF80000h
 = 00060000		      C CR0_M_TXAP			EQU 000060000h
 = 00010000		      C CR0_M_DAS		       EQU 000010000h
 = C000			      C CR0_M_CA		      EQU 00000C000h
 = 3F00			      C CR0_M_BL		      EQU 000003F00h
 = 0080			      C CR0_M_RESERVED07		      EQU 000000080h
 = 007C			      C CR0_M_DGW		       EQU 00000007Ch
 = 0002			      C CR0_M_BA		      EQU 000000002h
 = 0001			      C CR0_M_SR		      EQU 000000001h
 = 0013			      C CR0_V_RESERVED		       EQU 19
 = 0011			      C CR0_V_TXAP			EQU 17
 = 0010			      C CR0_V_DAS		       EQU 16
 = 000E			      C CR0_V_CA		      EQU 14
 = 0008			      C CR0_V_BL		      EQU 8
 = 0007			      C CR0_V_RESERVED07		      EQU 7
 = 0002			      C CR0_V_DGW		       EQU 2
 = 0001			      C CR0_V_BA		      EQU 1
 = 0000			      C CR0_V_SR		      EQU 0
			      C 
 = 0000			      C CR0_K_TXAP_NONE 		EQU 0
 = 0001			      C CR0_K_TXAP_200_USEC		EQU 1
 = 0002			      C CR0_K_TXAP_800_USEC		EQU 2
 = 0003			      C CR0_K_TXAP_1600_USEC		EQU 3
 = 0004			      C CR0_K_TXAP_128_USEC		EQU 4
			      C 
 = 0000			      C CR0_K_CA_0LW		      EQU 0
 = 0001			      C CR0_K_CA_8LW		      EQU 1
 = 0002			      C CR0_K_CA_16LW		      EQU 2
 = 0003			      C CR0_K_CA_32LW		      EQU 3
			      C 
 = 0000			      C CR0_K_BL_0LW		      EQU 0
 = 0001			      C CR0_K_BL_1LW		      EQU 1
 = 0002			      C CR0_K_BL_2LW		      EQU 2
 = 0004			      C CR0_K_BL_4LW		      EQU 4
 = 0008			      C CR0_K_BL_8LW		      EQU 8
 = 0010			      C CR0_K_BL_16LW		      EQU 16
 = 0020			      C CR0_K_BL_32LW		      EQU 32	  ; currently invalid
			      C 
 = 0000			      C CR0_K_DGW_0LW		       EQU 0
 = 0001			      C CR0_K_DGW_1LW		       EQU 1
 = 0002			      C CR0_K_DGW_2LW		       EQU 2
 = 0003			      C CR0_K_DGW_3LW		       EQU 3
 = 0004			      C CR0_K_DGW_4LW		       EQU 4
			      C 
 = FFFFFFFE		      C CR1_M_RESERVED		       EQU 0FFFFFFFEh
 = 0001			      C CR1_M_TPD		       EQU 000000001h
 = 0001			      C CR1_V_RESERVED		       EQU 1
 = 0000			      C CR1_V_TPD		       EQU 0
			      C 
 = FFFFFFFE		      C CR2_M_RESERVED		       EQU 0FFFFFFFEh
 = 0001			      C CR2_M_RPD		       EQU 000000001h
 = 0001			      C CR2_V_RESERVED		       EQU 1
 = 0000			      C CR2_V_RPD		       EQU 0
			      C 
 = FC000000		      C CR5_M_RESERVED			EQU 0FC000000h
 = 03800000		      C CR5_M_SBEB			EQU 003800000h
 = 00700000		      C CR5_M_TXS			EQU 000700000h
 = 000E0000		      C CR5_M_RXS			EQU 0000E0000h
 = 00010000		      C CR5_M_NIS			EQU 000010000h
 = 8000			      C CR5_M_AIS			EQU 000008000h
 = 4000			      C CR5_M_RESERVED_2		EQU 000004000h
 = 2000			      C CR5_M_SBE			EQU 000002000h
 = 0800			      C CR5_M_GPT			EQU 000000800h
 = 0400			      C CR5_M_ETI			EQU 000000400h
 = 0200			      C CR5_M_RXWT			EQU 000000200h
 = 0100			      C CR5_M_RXPS			EQU 000000100h
 = 0080			      C CR5_M_RXDU			EQU 000000080h
 = 0040			      C CR5_M_RXCI			EQU 000000040h
 = 0020			      C CR5_M_TXFU			EQU 000000020h
 = 0010			      C CR5_M_RESERVED_3		EQU 000000010h
 = 0008			      C CR5_M_TXJT			EQU 000000008h
 = 0004			      C CR5_M_TXDU			EQU 000000004h
 = 0002			      C CR5_M_TXPS			EQU 000000002h
 = 0001			      C CR5_M_TXCI			EQU 000000001h
 = 001A			      C CR5_V_RESERVED			EQU 26
 = 0017			      C CR5_V_SBEB			EQU 23
 = 0014			      C CR5_V_TXS			EQU 20
 = 0011			      C CR5_V_RXS			EQU 17
 = 0010			      C CR5_V_NIS			EQU 16
 = 000F			      C CR5_V_AIS			EQU 15
 = 000E			      C CR5_V_RESERVED_2		EQU 14
 = 000D			      C CR5_V_SBE			EQU 13
 = 000B			      C CR5_V_GPT			EQU 11
 = 000A			      C CR5_V_ETI			EQU 10
 = 0009			      C CR5_V_RXWT			EQU 9
 = 0008			      C CR5_V_RXPS			EQU 8
 = 0007			      C CR5_V_RXDU			EQU 7
 = 0006			      C CR5_V_RXCI			EQU 6
 = 0005			      C CR5_V_TXFU			EQU 5
 = 0004			      C CR5_V_RESERVED_3		EQU 4
 = 0003			      C CR5_V_TXJT			EQU 3
 = 0002			      C CR5_V_TXDU			EQU 2
 = 0001			      C CR5_V_TXPS			EQU 1
 = 0000			      C CR5_V_TXCI			EQU 0
			      C 
 = 0000			      C CR5_K_SBEB_PARITY_ERROR 	EQU 0
 = 0001			      C CR5_K_SBEB_MASTER_ABORT 	EQU 1
 = 0002			      C CR5_K_SBEB_TARGET_ABORT 	EQU 2
			      C 
 = 0000			      C CR5_K_TXS_STOPPED		EQU 0
 = 0001			      C CR5_K_TXS_RUN_DESC_ACCESS	EQU 1
 = 0002			      C CR5_K_TXS_RUN_SETUP_MOVE	EQU 2
 = 0003			      C CR5_K_TXS_RUN_MOVE_DATA 	EQU 3
 = 0004			      C CR5_K_TXS_RUN_WRITE_OWNER	EQU 4
 = 0005			      C CR5_K_TXS_RUN_WAIT		EQU 5
 = 0006			      C CR5_K_TXS_RUN_WRITE_STATUS	EQU 6
 = 0007			      C CR5_K_TXS_SUSPEND		EQU 7
			      C 
 = 0000			      C CR5_K_RXS_STOPPED		EQU 0
 = 0001			      C CR5_K_RXS_RUN_DESC_ACCESS	EQU 1
 = 0002			      C CR5_K_RXS_RUN_WAIT		EQU 2
 = 0003			      C CR5_K_RXS_RUN_MOVE_DATA 	EQU 3
 = 0004			      C CR5_K_RXS_RUN_WRITE_OWNER	EQU 4
 = 0005			      C CR5_K_RXS_RUN_WRITE_STATUS	EQU 5
 = 0006			      C CR5_K_RXS_SUSPEND		EQU 6
 = 0007			      C CR5_K_RXS_PURGE 		EQU 7
			      C 
 = 02000000		      C CR6_M_DM9009_ALWAYS		EQU 002000000h	;;DM9009 reserved bits
 = 80000000		      C CR6_M_RESERVED1_1		EQU 080000000h	;;Always 1
 = 40000000		      C CR6_M_RXA			EQU 040000000h	;;Reveive All(30)
 = 20000000		      C CR6_M_RESERVED2_1		EQU 020000000h
 = 38000000		      C CR6_M_RESERVED3_0		EQU 038000000h	;;Always 0
 = 04000000		      C CR6_M_RESERVED4_1		EQU 004000000h
 = 01000000		      C CR6_M_SCM			EQU 001000000h	;;Scrambler Mode(24)
 = 00800000		      C CR6_M_MSF			EQU 000800000h	;;MII Symbol Function(23)
 = 00400000		      C CR6_M_TXTM			EQU 000400000h	;;Transmit Threshold Mode(22)
 = 00200000		      C CR6_M_SFT			EQU 000200000h	;;Store and Forward Transmission(21)
 = 00100000		      C CR6_M_STT			EQU 000100000h	;;Shortest Transmit Threshold(20)
 = 00080000		      C CR6_M_HBD			EQU 000080000h	;;HartBit Disable(19)
 = 00040000		      C CR6_M_MSPS			EQU 000040000h	;;MII/SRL Port Select(18)
 = 00020000		      C CR6_M_RESERVED5_0		EQU 000020000h
 = 00010000		      C CR6_M_RESERVED6_0		EQU 000010000h
 = C000			      C CR6_M_TSB			EQU 00000C000h	;;Threshold Setup Bits(15:14)
 = 2000			      C CR6_M_TXSC			EQU 000002000h	;;Transmit Start/stop Command(13)
 = 1000			      C CR6_M_FCM			EQU 000001000h	;;Force Collision Mode(12)
 = 0C00			      C CR6_M_LBM			EQU 000000C00h	;;LookBack Mode(11:10)
 = 0200			      C CR6_M_FDM			EQU 000000200h	;;Full_Duplex Mode(9)
 = 0100			      C CR6_M_ISRW			EQU 000000100h	;;Inhibit Simultaneous Read/Write
 = 0080			      C CR6_M_PAM			EQU 000000080h	;;Pass All Multicast(7)
 = 0040			      C CR6_M_PM			EQU 000000040h	;;Promiscuous Mode(6)
 = 0020			      C CR6_M_RESERVED8_0		EQU 000000020h
 = 0010			      C CR6_M_IAFM			EQU 000000010h	;;Inverse Address Mode(4)
 = 0008			      C CR6_M_PBF			EQU 000000008h	;;Pass Bad Frame(3)
 = 0004			      C CR6_M_HOFM			EQU 000000004h	;;Hash-Only Filtering Mode(2)
 = 0002			      C CR6_M_RXSC			EQU 000000002h	;;Received Start/stop Command(1)
 = 0001			      C CR6_M_HPFM			EQU 000000001h	;;Hash/Perfect Filtering Mode(0)
 = 0018			      C CR6_V_SCM			EQU 24
 = 0017			      C CR6_V_MSF			EQU 23
 = 0016			      C CR6_V_TXTM			EQU 22
 = 0015			      C CR6_V_SFT			EQU 21
 = 0014			      C CR6_V_STT			EQU 20
 = 0013			      C CR6_V_HBD			EQU 19
 = 0012			      C CR6_V_MSPS			EQU 18
 = 000E			      C CR6_V_TSB			EQU 14
 = 000D			      C CR6_V_TXSC			EQU 13
 = 000C			      C CR6_V_FCM			EQU 12
 = 000A			      C CR6_V_LBM			EQU 10
 = 0009			      C CR6_V_FDM			EQU 9
 = 0007			      C CR6_V_PAM			EQU 7
 = 0006			      C CR6_V_PM			EQU 6
 = 0004			      C CR6_V_IAFM			EQU 4
 = 0003			      C CR6_V_PBF			EQU 3
 = 0002			      C CR6_V_HOFM			EQU 2
 = 0001			      C CR6_V_RXSC			EQU 1
 = 0000			      C CR6_V_HPFM			EQU 0
			      C 
 = 0000			      C CR6_K_10MB_TSB_72_BYTES 	EQU 0
 = 0001			      C CR6_K_10MB_TSB_96_BYTES 	EQU 1
 = 0002			      C CR6_K_10MB_TSB_128_BYTES	EQU 2
 = 0003			      C CR6_K_10MB_TSB_160_BYTES	EQU 3
			      C 
 = 0000			      C CR6_K_100MB_TSB_128_BYTES	EQU 0
 = 0001			      C CR6_K_100MB_TSB_256_BYTES	EQU 1
 = 0002			      C CR6_K_100MB_TSB_512_BYTES	EQU 2
 = 0003			      C CR6_K_100MB_TSB_1024_BYTES	EQU 3
			      C 
 = 00280000		      C CR6_K_100MB_INIT	       EQU (CR6_M_HBD) OR (CR6_M_SFT)
			      C 
			      C ; Define the transmit FIFO threshold that we will use, and the corresponding
			      C ; minimum packet size for which we may need software CRC calculation.
			      C ;
 = CR6_K_10MB_TSB_72_BYTES    C CR6_K_10MB_TSB_DEFAULT		EQU	CR6_K_10MB_TSB_72_BYTES ; use max threshold
			      C ;;--- DM9009's CR6 default value
			      C ;;CR6_DM9009_INIT		  EQU	  CR6_M_DM9009_ALWAYS OR CR6_M_RXA OR CR6_M_HBD OR CR6_M_PAM
			      C  OR CR6_K_10MB_TSB_128_BYTES
 = 02080082		      C CR6_DM9009_INIT 		EQU	CR6_M_DM9009_ALWAYS OR CR6_M_HBD OR CR6_M_PAM OR CR6_K_10MB_
			      C TSB_128_BYTES
			      C 
 = 0090			      C SW_CRC_MIN			EQU 144 		; CRC packet size min
			      C 
 = FFFE0000		      C CR7_M_RESERVED1 		EQU 0FFFE0000h
 = 00010000		      C CR7_M_NISE			EQU 000010000h
 = 8000			      C CR7_M_AISE			EQU 000008000h
 = 4000			      C CR7_M_RESERVED2 		EQU 000004000h
 = 2000			      C CR7_M_SBEE			EQU 000002000h
 = 1000			      C CR7_M_RESERVED3 		EQU 000001000h
 = 0800			      C CR7_M_GPTE			EQU 000000800h
 = 0400			      C CR7_M_ETIE			EQU 000000400h
 = 0200			      C CR7_M_RXWTE			EQU 000000200h
 = 0100			      C CR7_M_RXPSE			EQU 000000100h
 = 0080			      C CR7_M_RXDUE			EQU 000000080h
 = 0040			      C CR7_M_RXCIE			EQU 000000040h
 = 0020			      C CR7_M_TXFUE			EQU 000000020h	;;Transmit FIFO Underflow Enable(5)
 = 0010			      C CR7_M_RESERVED4 		EQU 000000010h
 = 0008			      C CR7_M_TXJTE			EQU 000000008h
 = 0004			      C CR7_M_TXDUE			EQU 000000004h
 = 0002			      C CR7_M_TXPSE			EQU 000000002h
 = 0001			      C CR7_M_TXCIE			EQU 000000001h
 = 0011			      C CR7_V_RESERVED1 		EQU 17
 = 0010			      C CR7_V_NISE			EQU 16
 = 000F			      C CR7_V_AISE			EQU 15
 = 000E			      C CR7_V_RESERVED2 		EQU 14
 = 000D			      C CR7_V_SBEE			EQU 13
 = 000B			      C CR7_V_GPTE			EQU 11
 = 000A			      C CR7_V_ETIE			EQU 10
 = 0009			      C CR7_V_RXWTE			EQU 9
 = 0008			      C CR7_V_RXPSE			EQU 8
 = 0007			      C CR7_V_RXDUE			EQU 7
 = 0006			      C CR7_V_RXCIE			EQU 6
 = 0005			      C CR7_V_TXFUE			EQU 5
 = 0004			      C CR7_V_RESERVED4 		EQU 4
 = 0003			      C CR7_V_TXJTE			EQU 3
 = 0002			      C CR7_V_TXDUE			EQU 2
 = 0001			      C CR7_V_TXPSE			EQU 1
 = 0000			      C CR7_V_TXCIE			EQU 0
			      C 
 = 0000			      C CR7_K_DEFAULT_OFF	       EQU 0
 = 00018041		      C CR7_K_DEFAULT_ON	       EQU CR7_M_NISE OR CR7_M_AISE OR CR7_M_RXCIE OR CR7_M_TXCIE
			      C 
			      C 
 = FFFE0000		      C CR8_M_RESERVED		       EQU 0FFFE0000h
 = 00010000		      C CR8_M_MISSED_FRAME_OVERFLOW    EQU 000010000h
 = FFFF			      C CR8_M_MIDDED_FRAME_COUNT       EQU 00000FFFFh
 = 0011			      C CR8_V_RESERVED		       EQU 17
 = 0010			      C CR8_V_MISSED_FRAME_OVERFLOW    EQU 16
 = 0000			      C CR8_V_MIDDED_FRAME_COUNT       EQU 0
			      C 
			      C ;;CR9_M_DN			 EQU 080000000h
			      C ;;CR9_M_RESERVED		 EQU 07FFFFF00h
			      C ;;CR9_M_DT			 EQU 0000000FFh
			      C ;;CR9_V_DN			 EQU 31
			      C ;;CR9_V_RESERVED		 EQU 8
			      C ;;CR9_V_DT			 EQU 0
			      C 
 = FFFF0000		      C CR11_M_RESERVED 	       EQU 0FFFF0000h
 = FFFF			      C CR11_M_FDX_AUTO_CONFIG	       EQU 00000FFFFh
 = 0010			      C CR11_V_RESERVED 	       EQU 16
 = 0000			      C CR11_V_FDX_AUTO_CONFIG	       EQU 0
			      C 
			      C ; CR12 constants
 = FFFFFE00		      C CR12_M_RESERVED 	EQU 0FFFFFE00h
 = 0100			      C CR12_M_GPC		EQU 000000100h
 = 00FF			      C CR12_M_MD		EQU 0000000FFh
 = 0004			      C CR12_M_LNK		EQU 000000004h
 = 0002			      C CR12_M_NCR		EQU 000000002h
			      C 
 = 0009			      C CR12_V_RESERVED 	EQU 9
 = 0008			      C CR12_V_GPC		EQU 8
 = 0000			      C CR12_V_MD		EQU 0
			      C 
 = 013F			      C CR12_K_INIT_VAL 	EQU 00000013Fh
 = 0008			      C CR12_K_ONBOARD_LOOPBACK EQU 000000008h
 = 000A			      C CR12_K_INBOARD_LOOPBACK EQU 00000000Ah
 = 000B			      C CR12_K_NORMAL_MODE	EQU 00000000Bh
			      C 
 = FFFF0000		      C CR13_M_RESERVED 	       EQU 0FFFF0000h
 = 8000			      C CR13_M_OE57		       EQU 000008000h
 = 4000			      C CR13_M_OE24		       EQU 000004000h
 = 2000			      C CR13_M_OE13		       EQU 000002000h
 = 1000			      C CR13_M_IE		       EQU 000001000h
 = 0F00			      C CR13_M_SEL		       EQU 000000F00h
 = 0080			      C CR13_M_ASE		       EQU 000000080h
 = 0040			      C CR13_M_SIM		       EQU 000000040h
 = 0020			      C CR13_M_ENI		       EQU 000000020h
 = 0010			      C CR13_M_EDP		       EQU 000000010h
 = 0008			      C CR13_M_AUI		       EQU 000000008h
 = 0004			      C CR13_M_CAC		       EQU 000000004h
 = 0002			      C CR13_M_PS		       EQU 000000002h
 = 0001			      C CR13_M_SRL		       EQU 000000001h
 = 0010			      C CR13_V_RESERVED 	       EQU 16
 = 000F			      C CR13_V_OE57		       EQU 15
 = 000E			      C CR13_V_OE24		       EQU 14
 = 000D			      C CR13_V_OE13		       EQU 13
 = 000C			      C CR13_V_IE		       EQU 12
 = 0008			      C CR13_V_SEL		       EQU 8
 = 0007			      C CR13_V_ASE		       EQU 7
 = 0006			      C CR13_V_SIM		       EQU 6
 = 0005			      C CR13_V_ENI		       EQU 5
 = 0004			      C CR13_V_EDP		       EQU 4
 = 0003			      C CR13_V_AUI		       EQU 3
 = 0002			      C CR13_V_CAC		       EQU 2
 = 0001			      C CR13_V_PS		       EQU 1
 = 0000			      C CR13_V_SRL		       EQU 0
			      C 
			      C ; values associated with 93LC46B Serial ROM
			      C ;============================================
 = 0040			      C SROM_93LC46B_LEN	EQU	64  ; In words. That is 128 Bytes.
			      C 
			      C 
			      C ; SROM version and field codes
			      C ;-----------------------------
 = 0001			      C UM9100_SROM_V0_1	EQU	01h
 = 0003			      C UM9100_SROM_V0_3	EQU	03h
 = 0012			      C SROM_FORMAT_OFF 	EQU	12h
 = 0013			      C SROM_ADAPTER_COUNT_OFF	EQU	13h
 = 0014			      C SROM_IEEE_OFF		EQU	14h
 = 001A			      C SROM_ADAPTER0_OFF	EQU	1Ah
 = 007E			      C SROM_CHECKSUM_OFF	EQU	7Eh
 = 0003			      C FNET_MEDIA_BLK_SIZE	EQU	03h
 = 0071			      C FNET_COMM_MASK		EQU	71H
 = 0012			      C FNET_COMM_OFF		EQU	12H
			      C 
			      C ; 90100 SROM definitions (SROM_93LC46B)
			      C ;----------------------------------------
 = 0019			      C SROM_93LC46B_MAX_CYCLES 	EQU 25
 = 003F			      C SROM_93LC46B_LAST_ADDRESS	EQU 03Fh
 = 0006			      C SROM_93LC46B_LAST_ADDRESS_BIT	EQU 6	  ;Special assembler implementation
 = 0008			      C SROM_M_Output_Data		EQU 8
			      C 
 = 4000			      C SROM_CR9_READ  EQU 04000h
 = 2000			      C SROM_CR9_WRITE EQU 02000h
 = 0800			      C SROM_SEL_SROM	EQU 0800h
 = 0004			      C SROM_DATA_1	EQU 04h
 = 0000			      C SROM_DATA_0	EQU 0
 = 0002			      C SROM_CLK	EQU 02h
 = 0001			      C SROM_CS 	EQU 01h
			      C 
			      C ; Define a structure that contains the values to be written to the registers to
			      C ; configure the SIA for a particular mode.
			      C ;
			      C SIA_CONFIG	STRUCT
			      C 	CR13   DWORD   ?
			      C 	CR14   DWORD   ?
			      C 	CR15   DWORD   ?
			      C SIA_CONFIG	ENDS
			      C 
			      C SIA_CONFIG_PTR	TYPEDEF PTR SIA_CONFIG
			      C 
 = 0005			      C SIA_Config_Autodetect	equ	5h	    ; flag to do autodetect speed & Half-Duplex
 = 0004			      C SIA_Config_AutoFD	equ	4h	    ; flag to do autodetect speed & Full-Duplex
 = 0000			      C TPFD_SIAConfig		equ	0h
 = 0001			      C TP_SIAConfig		equ	1h
 = 0002			      C BNC_SIAConfig		equ	2h
 = 0003			      C AUI_SIAConfig		equ	3h
			      C 
 = FFFF0000		      C PCIID_M_DEVICE_ID		 EQU 0FFFF0000h
 = FFFF			      C PCIID_M_VENDOR_IO		 EQU 00000FFFFh
 = 0010			      C PCIID_V_DEVICE_ID		 EQU 16
 = 0000			      C PCIID_V_VENDOR_IO		 EQU 0
			      C 
 = 80000000		      C PCICS_M_PARITY_ERROR		 EQU 080000000h
 = 40000000		      C PCICS_M_SYSTEM_ERROR		 EQU 040000000h
 = 20000000		      C PCICS_M_MASTER_ABORT		 EQU 020000000h
 = 10000000		      C PCICS_M_TARGET_ABORT		 EQU 010000000h
 = 08000000		      C PCICS_M_RESERVED		 EQU 008000000h
 = 06000000		      C PCICS_M_DEVSEL			 EQU 006000000h
 = 01000000		      C PCICS_M_DATA_PARITY		 EQU 001000000h
 = 00800000		      C PCICS_M_BACK_TO_BACK		 EQU 000800000h
 = 007FFC00		      C PCICS_M_RESERVED_2		 EQU 0007FFC00h
 = 0200			      C PCICS_M_SERR_ENABLE		 EQU 000000200h
 = 0180			      C PCICS_M_RESERVED_3		 EQU 000000180h
 = 0040			      C PCICS_M_PARITY_ERROR_DETECTED	 EQU 000000040h
 = 0038			      C PCICS_M_RESERVED_4		 EQU 000000038h
 = 0004			      C PCICS_M_BUS_MASTER		 EQU 000000004h
 = 0002			      C PCICS_M_MEMORY_ACCESS		 EQU 000000002h
 = 0001			      C PCICS_M_IO_ACCESS		 EQU 000000001h
 = 001F			      C PCICS_V_PARITY_ERROR		 EQU 31
 = 001E			      C PCICS_V_SYSTEM_ERROR		 EQU 30
 = 001D			      C PCICS_V_MASTER_ABORT		 EQU 29
 = 001C			      C PCICS_V_TARGET_ABORT		 EQU 28
 = 001B			      C PCICS_V_RESERVED		 EQU 27
 = 0019			      C PCICS_V_DEVSEL			 EQU 25
 = 0018			      C PCICS_V_DATA_PARITY		 EQU 24
 = 0017			      C PCICS_V_BACK_TO_BACK		 EQU 23
 = 000A			      C PCICS_V_RESERVED_2		 EQU 10
 = 0009			      C PCICS_V_SERR_ENABLE		 EQU 9
 = 0007			      C PCICS_V_RESERVED_3		 EQU 7
 = 0006			      C PCICS_V_PARITY_ERROR_DETECTED	 EQU 6
 = 0003			      C PCICS_V_RESERVED_4		 EQU 3
 = 0002			      C PCICS_V_BUS_MASTER		 EQU 2
 = 0001			      C PCICS_V_MEMORY_ACCESS		 EQU 1
 = 0000			      C PCICS_V_IO_ACCESS		 EQU 0
			      C 
 = FF000000		      C PCIRV_M_BASE_CLASS		 EQU 0FF000000h
 = 00FF0000		      C PCIRV_M_SUB_CLASS		 EQU 000FF0000h
 = FF00			      C PCIRV_M_RESERVED		 EQU 00000FF00h
 = 00F0			      C PCIRV_M_Revision_Major_Number	 EQU 0000000F0h
 = 000F			      C PCIRV_M_Revision_Minor_Number	 EQU 00000000Fh
 = 0018			      C PCIRV_V_BASE_CLASS		 EQU 24
 = 0010			      C PCIRV_V_SUB_CLASS		 EQU 16
 = 0008			      C PCIRV_V_RESERVED		 EQU 8
 = 0004			      C PCIRV_V_Revision_Major_Number	 EQU 4
 = 0000			      C PCIRV_V_Revision_Minor_Number	 EQU 0
			      C 
 = FFFF0000		      C PCILT_M_RESERVED		 EQU 0FFFF0000h
 = FF00			      C PCILT_M_LATENCY_TIMER		 EQU 00000FF00h
 = 00FF			      C PCILT_M_RESERVED_2		 EQU 0000000FFh
 = 0010			      C PCILT_V_RESERVED		 EQU 16
 = 0008			      C PCILT_V_LATENCY_TIMER		 EQU 8
 = 0000			      C PCILT_V_RESERVED_2		 EQU 0
			      C 
 = FFFFFF80		      C PCIIO_M_PCI_IO_BASE_ADDRESS	 EQU 0FFFFFF80h
 = 007E			      C PCIIO_M_RESERVED		 EQU 00000007Eh
 = 0001			      C PCIIO_M_MEMORY_IO		 EQU 000000001h
 = 0007			      C PCIIO_V_PCI_IO_BASE_ADDRESS	 EQU 7
 = 0001			      C PCIIO_V_RESERVED		 EQU 1
 = 0000			      C PCIIO_V_MEMORY_IO		 EQU 0
			      C 
 = FFFFFF80		      C PCIMEM_M_PCI_MEM_BASE_ADDRESS	  EQU 0FFFFFF80h
 = 007E			      C PCIMEM_M_RESERVED		  EQU 00000007Eh
 = 0001			      C PCIMEM_M_MEMORY_SPACE		  EQU 000000001h
 = 0007			      C PCIMEM_V_PCI_MEM_BASE_ADDRESS	  EQU 7
 = 0001			      C PCIMEM_V_RESERVED		  EQU 1
 = 0000			      C PCIMEM_V_MEMORY_SPACE		  EQU 0
			      C 
 = FFFF0000		      C PCIINT_M_RESERVED		  EQU 0FFFF0000h
 = FF00			      C PCIINT_M_INTERRUPT_PIN		  EQU 00000FF00h
 = 00FF			      C PCIINT_M_INTERRUPT_LINE 	  EQU 0000000FFh
 = 0010			      C PCIINT_V_RESERVED		  EQU 16
 = 0008			      C PCIINT_V_INTERRUPT_PIN		  EQU 8
 = 0000			      C PCIINT_V_INTERRUPT_LINE 	  EQU 0
			      C 
 = FFFF0000		      C PCIUSR_M_RESERVED		  EQU 0FFFF0000h
 = FF00			      C PCIUSR_M_USER_SPECIAL_USE	  EQU 00000FF00h
 = 00FF			      C PCIUSR_M_RESERVED_2		  EQU 0000000FFh
 = 0010			      C PCIUSR_V_RESERVED		  EQU 16
 = 0008			      C PCIUSR_V_USER_SPECIAL_USE	  EQU 8
 = 0000			      C PCIUSR_V_RESERVED_2		  EQU 0
			      C 
 = 00C0			      C HW_K_SETUP_FRAME_SIZE		EQU 192
			      C 
			      C ;
			      C ;  Descriptor definitions
			      C ;
			      C ;     Transmit Descriptor
			      C ;     -------------------
			      C ;
			      C ; The DM9100 Transmit Descriptor is described in the DM9100 specification.
			      C ; The names of the fields, TDES0-3 are taken straight from the spec.
			      C ; This structure, and the associated constants, define the format of the
			      C ; transmit descriptor used by the DM9100. A transmit descriptor must
			      C ; be allocated a physically contiguous, longword aligned region of memory. The
			      C ; transmit buffers to which the descriptors point may be of arbitrary alignment
			      C ; and size.
			      C ;
			      C ; The p_XmtBuffer and p_XmtNext fields of the descriptor are unique to this
			      C ; driver implementation. They are virtual NEAR pointers to the transmit buffer
			      C ; and the next descriptor respectively. The descriptor skip length in CR0 is
			      C ; set to 1 longword in order to skip this extra longword at the end of each
			      C ; descriptor.
			      C ;
			      C 
			      C XMT_DESCRIPTOR	STRUC
			      C    TDES0       DD 0
			      C    TDES1       DD 0
			      C    TDES2       DD 0
			      C    TDES3       DD 0
			      C    p_XmtBuffer DW 0
			      C    p_XmtNext   DW 0
			      C    p_Dummy1    DD 0
			      C    p_Dummy2    DD 0
			      C    p_Dummy3    DD 0
			      C XMT_DESCRIPTOR	ENDS
			      C 
 = 80000000		      C TDES0_M_OWN		EQU 080000000h	; OWN Bit 1=MAC 0=Host
 = 8000			      C TDES0_M_ES		EQU 000008000h	; Error Summary (UF|EC|LC|NC|LO|TO|LF)
 = 4000			      C TDES0_M_TXJT		EQU 000004000h	; Transmit Jabber Expired
 = 0800			      C TDES0_M_LOC		EQU 000000800h	; Loss of Carrier
 = 0400			      C TDES0_M_NC		EQU 000000400h	; No Carrier
 = 0200			      C TDES0_M_LC		EQU 000000200h	; Late Collision
 = 0100			      C TDES0_M_EC		EQU 000000100h	; Excessive Collisions
 = 0080			      C TDES0_M_HF		EQU 000000080h	; Heartbeat Fail
 = 0078			      C TDES0_M_CC		EQU 000000078h	; Collision Count
 = 0004			      C TDES0_M_LF		EQU 000000004h	; Link Fail
 = 0002			      C TDES0_M_FUE		EQU 000000002h	; FIFO Underflow Error
 = 0001			      C TDES0_M_DE		EQU 000000001h	; Deferred
			      C 
 = 001F			      C TDES0_V_OWN		EQU 31
 = 000F			      C TDES0_V_ES		EQU 15
 = 000E			      C TDES0_V_TXJT		EQU 14
 = 000B			      C TDES0_V_LOC		EQU 11
 = 000A			      C TDES0_V_NC		EQU 10
 = 0009			      C TDES0_V_LC		EQU 9
 = 0008			      C TDES0_V_EC		EQU 8
 = 0007			      C TDES0_V_HF		EQU 7
 = 0003			      C TDES0_V_CC		EQU 3
 = 0002			      C TDES0_V_LF		EQU 2
 = 0001			      C TDES0_V_FUE		EQU 1
 = 0000			      C TDES0_V_DE		EQU 0
			      C 
 = 80000000		      C TDES1_M_CI		EQU 080000000h	; Completion Interrupt
 = 40000000		      C TDES1_M_ED		EQU 040000000h	; End Segment
 = 20000000		      C TDES1_M_BD		EQU 020000000h	; Begin Segment
 = 10000000		      C TDES1_M_FMB1		EQU 010000000h	; Filtering Mode Bit 1
 = 08000000		      C TDES1_M_SETF		EQU 008000000h	; Setup Frame
 = 04000000		      C TDES1_M_CAD		EQU 004000000h	; CRC Append Disable
 = 02000000		      C TDES1_M_EOR		EQU 002000000h	; End of Ring
 = 01000000		      C TDES1_M_CE		EQU 001000000h	; Chain Enable
 = 00800000		      C TDES1_M_PD		EQU 000800000h	; Padding Disable
 = 00400000		      C TDES1_M_FMB0		EQU 000400000h	; Filtering Mode Bit 0
 = 003FF800		      C TDES1_M_BL2		EQU 0003FF800h	; Size in bytes of Buffer 2
 = 07FF			      C TDES1_M_BL1		EQU 0000007FFh	; Size in bytes of Buffer 1
			      C 
			      C ;;-+, 980415, Hu-Tiong
			      C ;;TDES1_M_DUMMY 	  EQU TDES1_M_EOR AND (not (TDES1_M_BL2 OR TDES1_M_BL1 OR TDES1_M_ED OR TDES
			      C 1_M_BD))
 = 01000000		      C TDES1_M_DUMMY		EQU TDES1_M_CE AND (not (TDES1_M_BL2 OR TDES1_M_BL1 OR TDES1_M_ED OR TDES1_M
			      C _BD))
			      C ;;-+
			      C 
 = 001F			      C TDES1_V_CI		EQU 31
 = 001E			      C TDES1_V_ED		EQU 30
 = 001D			      C TDES1_V_BD		EQU 29
 = 001C			      C TDES1_V_FMB1		EQU 28
 = 001B			      C TDES1_V_SETF		EQU 27
 = 001A			      C TDES1_V_CAD		EQU 26
 = 0019			      C TDES1_V_EOR		EQU 25
 = 0018			      C TDES1_V_CE		EQU 24
 = 0017			      C TDES1_V_PD		EQU 23
 = 0016			      C TDES1_V_FMB0		EQU 22
 = 000B			      C TDES1_V_BL2		EQU 11
 = 0000			      C TDES1_V_BL1		EQU 0
			      C 
 = 05F0			      C XMT_BUFFER_SIZE 	EQU 1520
			      C 
			      C ;
			      C ;     Receive Descriptor
			      C ;     ------------------
			      C ;
			      C ;
			      C ; The DM9100 Receive Descriptor is described in the DM9100 specification.
			      C ; The names of the fields, RDES0-3 are takes straight from the spec.
			      C ; This structure, and the associated constants, define the format of the
			      C ; receive descriptor used by the DM9100. A receive descriptor must be
			      C ; allocated a physically contiguous, longword aligned region of memory. The
			      C ; receive buffers to which the descriptors point must also be physically
			      C ; contiguous and longword alignedand a MOD 4 length.
			      C ;
			      C ; The p_RcvBuffer and p_RcvNext fields of the descriptor are unique to this driver
			      C ; implementation. They are virtual NEAR pointers to the receive buffer and
			      C ; the next descriptor respectively. The descriptor skip length in CR0 is
			      C ; set to 1 longword in order to skip this extra longword at the end of each
			      C ; descriptor.
			      C ;
			      C 
			      C RCV_DESCRIPTOR	STRUC
			      C    RDES0	 DD 0
			      C    RDES1	 DD 0
			      C    RDES2	 DD 0
			      C    RDES3	 DD 0
			      C    p_RcvBuffer	 DW 0
			      C    p_RcvNext	 DW 0
			      C    p_Dummy1	 DD 0
			      C    p_Dummy2	 DD 0
			      C    p_Dummy3	 DD 0
			      C RCV_DESCRIPTOR	ENDS
			      C 
 = 80000000		      C RDES0_M_OWN		EQU 080000000h	; OWN bit 0=HOST 1=MAC
 = 7FFF0000		      C RDES0_M_LENGTH		EQU 07FFF0000h	; Length of frame in bytes including CRC
 = 8000			      C RDES0_M_ES		EQU 000008000h	; Error Summary (OF|CE|CS|TL|LE|RF)
 = 4000			      C RDES0_M_DUE		EQU 000004000h	;;Descriptor Unavailable Error
			      C 					; Length Error (rcv buffer too small)
 = 3000			      C RDES0_M_LBOM		EQU 000003000h	; Data Type
 = 0800			      C RDES0_M_RF		EQU 000000800h	; Runt Frame
 = 0400			      C RDES0_M_MF		EQU 000000400h	; MCast frame
 = 0200			      C RDES0_M_BD		EQU 000000200h	; Begin Descriptor
 = 0100			      C RDES0_M_ED		EQU 000000100h	; End Descriptor
 = 0080			      C RDES0_M_EFL		EQU 000000080h	; Excessive Frame Length (>1518 bytes)
 = 0040			      C RDES0_M_LCS		EQU 000000040h	; Late Collision Seen
 = 0020			      C RDES0_M_FT		EQU 000000020h	; Frame Type 1=DIX 0=802.3
 = 0010			      C RDES0_M_RXWT		EQU 000000010h	; Receive Watchdog Expired (frame >2K)
 = 0008			      C RDES0_M_PLE		EQU 000000008h	; Physical Layer Error
 = 0004			      C RDES0_M_AE		EQU 000000004h	; Alignment Error
 = 0002			      C RDES0_M_CE		EQU 000000002h	; CRC Error
 = 0001			      C RDES0_M_FOE		EQU 000000001h	; FIFO Overflow Error
			      C 
 = 001F			      C RDES0_V_OWN		EQU 31
 = 0010			      C RDES0_V_LENGTH		EQU 16
 = 000F			      C RDES0_V_ES		EQU 15
 = 000E			      C RDES0_V_DUE		EQU 14
 = 000C			      C RDES0_V_LBOM		EQU 12
 = 000B			      C RDES0_V_RF		EQU 11
 = 000A			      C RDES0_V_MF		EQU 10
 = 0009			      C RDES0_V_BD		EQU 9
 = 0008			      C RDES0_V_ED		EQU 8
 = 0007			      C RDES0_V_EFL		EQU 7
 = 0006			      C RDES0_V_LCS		EQU 6
 = 0005			      C RDES0_V_FT		EQU 5
 = 0004			      C RDES0_V_RXWT		EQU 4
 = 0002			      C RDES0_V_AE		EQU 2
 = 0001			      C RDES0_V_CE		EQU 1
 = 0000			      C RDES0_V_FOE		EQU 0
			      C 
 = 0001			      C RDES0_K_FT_DIX		EQU 1
 = 0000			      C RDES0_K_FT_802		EQU 0
			      C 
 = 0000			      C RDES0_K_LBOM_NORMAL	EQU 0
 = 0001			      C RDES0_K_LBOM_INTERNAL	EQU 1
 = 0002			      C RDES0_K_LBOM_EXTERNAL	EQU 2
 = 0003			      C RDES0_K_LBOM_RESERVED	EQU 3
			      C 
 = 02000000		      C RDES1_M_EOR		EQU 002000000h	; End Of Ring
 = 01000000		      C RDES1_M_CE		EQU 001000000h	; Chain Enable
 = 003FF800		      C RDES1_M_BL2		EQU 0003FF800h	; Size in bytes of buffer 2 (MOD 4)
 = 07FF			      C RDES1_M_BL1		EQU 0000007FFh	; Size in bytes of buffer 1 (MOD 4)
			      C 
 = 0019			      C RDES1_V_EOR		EQU 25
 = 0018			      C RDES1_V_CE		EQU 24
 = 000B			      C RDES1_V_BL2		EQU 11
 = 0000			      C RDES1_V_BL1		EQU 0
			      C 
 = 0620			      C RCV_BUFFER_SIZE 	EQU 620h   ; Smallest MOD 4 length that can accommodate MTU
			      C ;;RCV_BUFFER_SIZE	  EQU 1520   ; Smallest MOD 4 length that can accommodate MTU
			      C 
			      C ;; SROM contents structure
			      C SROM_NS_Contents	STRUC
			      C   NS_SS_Vendor_ID    DW      0		     ; Sub-System Vendor ID
			      C   NS_SS_ID	     DW      0		     ; Sub-System ID
			      C   NS_Cardbus_Low     DW      0		     ; Cardbus CIS Pointer Low
			      C   NS_Cardbus_High    DW      0		     ; Cardbus CIS Pointer High
			      C   NS_ID_Reserved1    DB      8 DUP (0)	     ; Reserved
			      C   NS_ID_Bk_Crc	     DB      0		     ; ID Block CRC
			      C   NS_ID_Reserved2    DB      0		     ; Reserved
			      C   NS_SROM_version    DB      03h	     ; SROM Format Version
			      C   NS_Controller_cnt  DB      01h	     ; Controller Count
			      C   NS_Ether_Addr      DB      6 DUP (0)	     ; IEEE Network Address
			      C   NS_Dev_Number      DB      0		     ; Controller Device Number
			      C   NS_IL_Offset	     DW      1Eh	     ; Controller Info Leaf Offset
			      C   NS_Inf_Reserved3   DB      0		     ; Reserved
			      C ;; -- Info Leaf
			      C   NS_Sel_Conn_type   DW      0		     ; Selected Connection Type
			      C   NS_Gen_Pur_Ctrl    DB      80h	     ; General Purpose Control
			      C   NS_Blk_cnt	     DB      6		     ; Block Count
			      C ;; -- Info Leaf Block
			      C   NS_F1_Length_0     DB      8Eh	     ; Format 1 length bytes
			      C   NS_Type1	     DB      1		     ; Extended format type 1
			      C   NS_PHY_Number      DB      1		     ; PHY Address
			      C   NS_GPR_Seq_Len     DB      0		     ; GPR sequence Length
			      C   NS_RST_Seq_Len     DB      2		     ; Reset Sequence Length
			      C   NS_RST_Seq_0	     DB      80h	     ; Reset Sequence 0
			      C   NS_RST_Seq_1	     DB      00h	     ; Reset Sequence 1
			      C   NS_Media_Cap	     DW      7800h	     ; Media Capabilities
			      C   NS_Nway_Adv	     DW      01E0h	     ; Nway Advertisemnet
			      C   NS_FDX_Map	     DW      5000h	     ; Full Duplex Bits
			      C   NS_TTM_Map	     DW      1800h	     ; Tx Theshold Mode Bits
			      C ;; --
			      C   NS_F1_Length_1     DB      85h	     ; Format 1 length
			      C   NS_Type2	     DB      80h	     ; New Delay Type
			      C   NS_Delay_Seq_0     DW      2000h	     ;
			      C   NS_Delay_seq_1     DW      4000h	     ;
			      C ;; --
			      C   NS_F1_Length_2     DB      85h
			      C   NS_Type3	     DB      00h
			      C   NS_10BaseT_Code    DB      00h
			      C   NS_GprData10	     DB      00h
			      C   NS_Comm10	     DW      001Dh
			      C ;; --
			      C   NS_F1_Length_3     DB      85h
			      C   NS_Type4	     DB      00h
			      C   NS_100BaseT_Code   DB      01h
			      C   NS_GprData100      DB      00h
			      C   NS_Comm100	     DW      008Dh
			      C ;; --
			      C   NS_F1_Length_4     DB      85h
			      C   NS_Type5	     DB      00h
			      C   NS_10BaseFD_Code   DB      04h
			      C   NS_GprData10FD     DB      00h
			      C   NS_Comm10FD	    DW	    001Dh
			      C ;; --
			      C   NS_F1_Length_5     DB      85h
			      C   NS_Type6	     DB      00h
			      C   NS_100BaseFD	     DB      05h
			      C   NS_GprData100FD    DB      00h
			      C   NS_Comm100FD	     DW      008Dh
			      C   NS_Reserved4	     DB      49 DUP (0)
			      C   NS_SROM_CRC	     DB      2 DUP (0)
			      C SROM_NS_Contents	ENDS
			      C 
			      C SROM_MotolorA_Contents	      STRUC
			      C   MA_SS_Vendor_ID    DW      0		     ; Sub-System Vendor ID
			      C   MA_SS_ID	     DW      0		     ; Sub-System ID
			      C   MA_Cardbus_Low     DW      0		     ; Cardbus CIS Pointer Low
			      C   MA_Cardbus_High    DW      0		     ; Cardbus CIS Pointer High
			      C   MA_ID_Reserved1    DB      8 DUP (0)	     ; Reserved
			      C   MA_ID_Bk_Crc	     DB      0		     ; ID Block CRC
			      C   MA_ID_Reserved2    DB      0		     ; Reserved
			      C   MA_SROM_version    DB      03h	     ; SROM Format Version
			      C   MA_Controller_cnt  DB      01h	     ; Controller Count
			      C   MA_Ether_Addr      DB      6 DUP (0)	     ; IEEE Network Address
			      C   MA_Dev_Number      DB      0		     ; Controller Device Number
			      C   MA_IL_Offset	     DW      1Eh	     ; Controller Info Leaf Offset
			      C   MA_Inf_Reserved3   DB      0		     ; Reserved
			      C ;; -- Info Leaf
			      C   MA_Sel_Conn_type   DW      0		     ; Selected Connection Type
			      C   MA_Gen_Pur_Ctrl    DB      80h	     ; General Purpose Control
			      C   MA_Blk_cnt	     DB      6		     ; Block Count
			      C ;; -- Info Leaf Block
			      C   MA_F1_Length_2     DB      85h
			      C   MA_Type3	     DB      00h
			      C   MA_10BaseT_Code    DB      00h
			      C   MA_GprData10	     DB      00h
			      C   MA_Comm10	     DW      001Dh
			      C ;; --
			      C   MA_F1_Length_3     DB      85h
			      C   MA_Type4	     DB      00h
			      C   MA_100BaseT_Code   DB      01h
			      C   MA_GprData100      DB      00h
			      C   MA_Comm100	     DW      008Dh
			      C ;; --
			      C   MA_F1_Length_4     DB      85h
			      C   MA_Type5	     DB      00h
			      C   MA_10BaseFD_Code   DB      04h
			      C   MA_GprData10FD     DB      00h
			      C   MA_Comm10FD	    DW	    001Dh
			      C ;; --
			      C   MA_F1_Length_5     DB      85h
			      C   MA_Type6	     DB      00h
			      C   MA_100BaseFD	     DB      05h
			      C   MA_GprData100FD    DB      00h
			      C   MA_Comm100FD	     DW      008Dh
			      C   MA_Reserved4	     DB      49 DUP (0)
			      C   MA_SROM_CRC	     DB      2 DUP (0)
			      C SROM_MotolorA_Contents	      ENDS
			      C  
			      C 
			      C include phy.inc
			      C ;; -- PHY Registers
 = 0000			      C PHY_BMCR		EQU	00h
 = 0001			      C PHY_BMSR		EQU	01h
 = 0002			      C PHY_PHYIDR1		EQU	02h
 = 0003			      C PHY_PHYIDR2		EQU	03h
 = 0004			      C PHY_ANAR		EQU	04h
 = 0005			      C PHY_ANLPAR		EQU	05h
 = 0006			      C PHY_ANER		EQU	06h
 = 0012			      C PHY_DCR 		EQU	12h
 = 0013			      C PHY_FCSCR		EQU	13h
 = 0015			      C PHY_DECR		EQU	15h
 = 0016			      C PHY_SRR 		EQU	16h
 = 0017			      C PHY_PCR 		EQU	17h
 = 0018			      C PHY_LBREMR		EQU	18h
 = 0011			      C PHY_DSCSR		EQU	17
 = 0012			      C PHY_10BTCSR		EQU	18
 = 0019			      C PHY_PAR 		EQU	19h
 = 001B			      C PHY_10BTSR		EQU	1Bh
 = 001C			      C PHY_10BTCR		EQU	1Ch
			      C 
			      C ;; -- Pattern thtough CR9 to program PHY
 = 0000			      C PHY_clkL_Write_0	EQU	00000h
 = 00010000		      C PHY_clkH_Write_0	EQU	10000h
 = 00020000		      C PHY_clkL_Write_1	EQU	20000h
 = 00030000		      C PHY_clkH_Write_1	EQU	30000h
			      C 
 = 00040000		      C PHY_clkL_Read		EQU	40000h
 = 00050000		      C PHY_clkH_Read		EQU	50000h
			      C 
 = 00080000		      C CR9_M_MDI	       EQU     80000h
 = 0013			      C CR9_S_MDI	       EQU     19
			      C 
 = 0100			      C BMCR_M_DM		EQU	0100h	       ; Duplex Mode mask.
			      C 
 = 0020			      C BMSR_M_AN		EQU	0020h	       ; Auto-Negotiation complete mask
 = 0004			      C BMSR_M_LS		EQU	0004h	       ; Link Status mask.
			      C 
 = 0001			      C ANER_M_LAA		EQU	0001h	       ; Link Partner Auto-Negotiation Able mask
			      C 
			      C ;;PAR_M_SI10		  EQU	  0040h 	 ; Speed Indication mask
			      C 
			      C ;;--- PHY Chip
 = 0000			      C DSIPHY			EQU	0
 = 0001			      C NSPHY			EQU	1
			      C ;;++, 2000.3.27
 = 0002			      C PNAPHY			EQU	2
			      C ;;++
			      C 
 = 2000			      C NS_OUI_MSB		EQU	0010000000000000B
 = 5C00			      C NS_OUI_LSB		EQU	0101110000000000B
			      C 
			      C  
			      C 
			      C 
			      C EXTRN   rom_address : BYTE
			      C EXTRN   my_address : BYTE
			      C EXTRN   flagword : WORD
			      C 
			      C EXTRN   Syn_PHY : NEAR
			      C EXTRN   Read_Register_PHY : NEAR
			      C EXTRN   Write_Register_PHY : NEAR
			      C 
 184F 52 4F 4D 20 65 68	      C Debug_eaddr_msg db      "ROM ehternet address : ",'$'
       74 65 72 6E 65 74
       20 61 64 64 72 65
       73 73 20 3A 20 24
			      C 
			      C ;;++, 2000.6.21, htho, set speed/power for HOMEPNA
			      C ifdef HOMEPNA
			      C         PUBLIC  pna_cr16
			      C ;
			      C ; Default value of "Disable Increment of Noise" (Reg.16[12])
			      C ;       HOMERUN = 1 -- disable 25% increase of noise slice
			      C ;       LONGRUN = 0 -- normal operation
			      C ; This will be done in Setup_HOMERUN_PHY()/Setup_LONGRUN_PHY
			      C ;
 1867 8005		      C pna_cr16        dw      8005h   ; default=ignore/high speed/low power
			      C          PUBLIC  p_PHY24 ; add by simon 2001.8.30
 1869 0000		      C p_PHY24          dw   0
			      C endif
			      C ;;++
			      C ;;;;++, 2000.6.27, htho
			      C ifdef HOMEPNA
			      C         PUBLIC  send_remote_cmd
 186B 00		      C send_remote_cmd         db      0       ; default = don't send remote command
			      C 
			      C         PUBLIC  pna_power_cmd, pna_speed_cmd
 186C 0800		      C pna_power_cmd           dw      0800h   ; command low power
 186E 0100		      C pna_speed_cmd           dw      0100h   ; command high speed
			      C 
			      C         PUBLIC  resend_remote_cmd_cnt, resend_remote_cmd_timer
 1870 00		      C resend_remote_cmd_cnt   db      0
 1871 0000		      C resend_remote_cmd_timer dw      0
			      C endif
			      C 
			      C         PUBLIC  switch_adapter
 1873 00		      C switch_adapter  db      0       ; 0 - none switch adapter, 1 - half, 2 - full
			      C ;;;;++
			      C 
			      C         PUBLIC  PortConfigCR0
			      C ;; Debug
			      C ;;-+, 980414, Hu-Tiong
			      C ;;PortConfigCR0          DD             (CR0_K_TXAP_NONE SHL CR0_V_TXAP) OR \
			      C ;;                                       (CR0_K_CA_0LW SHL CR0_V_CA) OR \
			      C ;;                                       (CR0_K_BL_0LW  SHL CR0_V_BL) OR \
			      C ;;                                       (CR0_K_DGW_1LW  SHL CR0_V_DGW)
			      C ;;-+, 2000.2.17, htho
			      C ;PortConfigCR0          DD             (CR0_K_TXAP_NONE SHL CR0_V_TXAP) OR \
			      C ;                                      (CR0_K_CA_0LW SHL CR0_V_CA) OR \
			      C ;                                      (CR0_K_BL_0LW  SHL CR0_V_BL) OR \
			      C ;                                      (CR0_K_DGW_4LW  SHL CR0_V_DGW)
 1874 00C00000		      C PortConfigCR0           DD             00C00000h
			      C ;;-+
			      C ;;-+
			      C 
			      C 
			      C         PUBLIC  PortConfigCR6
			      C 
			      C ;;-+, 2000.3.27, htho
			      C ;;CR6_DEFAULT             EQU     002C0000h
 = 02040000		      C CR6_DEFAULT             EQU     02040000h
			      C ;;-+
			      C ifdef SINGLE_PORT
 1878 02040100		      C PortConfigCR6           DD      (CR6_DEFAULT OR CR6_M_ISRW)
			      C else
			      C endif
			      C 
			      C ;;;;++, 2000.8.24, htho, support VLAN & Tx/Rx flow control
			      C         PUBLIC  vlan, fcrx, fctx
 187C 00000006		      C PortConfigCR15          dd      000000006h
 1880 00		      C vlan                    db      0       ; vlan = 0: disable(default), 1: enable
 1881 00		      C fcrx                    db      0       ; fcrx = 0: disable(default), 1: enable
 1882 00		      C fctx                    db      0       ; fctx = 0: disable(default), 1: enable
			      C ;;;;++
			      C 
			      C ;;;;++, 2000.9.19, htho, support DM9801 E4
 1883 00		      C pnaphy_rev      db      ?
			      C ;;;;++
			      C 
			      C ;;;;++, 2000.10.4, simulate line plug out/in by power off/on phy for DM9102A E3
 1884 00		      C dm9102a_e3      db      0
			      C ;;;;++
			      C 
			      C ;;++, 2001.3.30, htho, support HPNA speed setting
			      C         PUBLIC LSpeedNum
			      C ;;-+, 2001.6.12, htho, default lspeed=1000 instead of 700
 1885 03E8		      C LSpeedNum       dw      1000            ; must one of {1000, 500, 1400, 1600}
			      C ;;-+
 1887 0000		      C pna_cr29        dw      ?
 1889 0000		      C pna_cr30        dw      ?
 188B 0000		      C pna_cr31        dw      ?
			      C ;;++
			      C 
			      C ;;++, 980923, Hu-Tiong
 = 8000			      C BMCR_M_RST      EQU     8000h   ; Reset mask
 = 4000			      C BMCR_M_LB       EQU     4000h   ; loopback mask
 = 2000			      C BMCR_M_SL       EQU     2000h   ; Speed Select mask
 = 1000			      C BMCR_M_ANE      EQU     1000h   ; Auto-Negotiation Enable Mask
 = 0400			      C BMCR_M_IS       EQU     0400h   ; Isolate mask
 = 0200			      C BMCR_M_RAN      EQU     0200h   ; Restart Auto-Negotiation mask
 = 0100			      C BMCR_M_DM       EQU     0100h   ; Duplex Mode mask
 = 0080			      C BMCR_M_CT       EQU     0080h   ; Collision Test
			      C 
 = 0200			      C ANAR_RF         EQU     0200h   ; remote fault
 = 0400			      C ANAR_FCS        EQU     0400h   ; Flow Control Support
 = 0200			      C ANAR_T4         EQU     0200h   ; 100BASE-T4 Support
 = 0100			      C ANAR_TX_FDX     EQU     0100h   ; 100BASE-TX Full Duplex support
 = 0080			      C ANAR_TX_HDX     EQU     0080h   ; 100BASE-TX Half Duplex support
 = 0040			      C ANAR_10_FDX     EQU     0040h   ; 10BASE-T Full Duplex support
 = 0020			      C ANAR_10_HDX     EQU     0020h   ; 10BASE-T Half Duplex support
 = 0001			      C ANAR_CSMACD     EQU     0001h   ; device supports IEEE 802.3 CSMA/CD
			      C 
 = 03E0			      C ANAR_CAP_MASK   EQU     03E0h   ; advertisement capability mask ANAR[5..9]
 = 01E0			      C ANAR_CAP_ALL    EQU     (ANAR_TX_FDX+ANAR_TX_HDX+ANAR_10_FDX+ANAR_10_HDX)
			      C 
 = 05E1			      C ANAR_DEFAULT_VAL        EQU     (ANAR_FCS+ANAR_CAP_ALL+ANAR_CSMACD)
			      C 
 188D 05E1		      C anar            dw      ANAR_DEFAULT_VAL
			      C ;;++
			      C 
 188F 0000		      C SROMImage               DW 0  ; Contains base address of SROM memory image
			      C                               ; (Physically - data buffer of first rcv desc)
			      C 
 1891 00		      C AdapterNum              DB 0  ; Num of adapter as entry in SROM. default: 0
			      C                               ; meaning that only one adapter is present.
			      C 
			      C         PUBLIC  SROMPortFlag
 1892 00		      C SROMPortFlag        DB      0     ; Port type : 0 - TP, 1 - Full Duplex TP.
			      C                                   ;             2 - AutoSense
			      C                                   ;             3 - T4
			      C                                   ;             4 - 1M HOME PNA
			      C 
			      C         PUBLIC  InitPIDataRate
 1893 000A		      C InitPIDataRate      DW      10    ; Init Data rate (stored here
			      C                                   ; in order that it won't be deleted )
			      C 
			      C         PUBLIC  PHY_Number, PHYTYPE
 1895 01		      C PHY_Number      DB      1       ; PHY address
 1896 00		      C PHYTYPE         DB      DSIPHY
			      C ;;;;++, 2000.5.2, htho
			      C                 PUBLIC  PNATYPE
 = 0000			      C HOMERUN         EQU     0
 = 0001			      C LONGRUN         EQU     1
 1897 00		      C PNATYPE         DB      HOMERUN
			      C ;;;;++
			      C 
 1898 00000000		      C DM9009_CR12_image       DD      0
			      C 
			      C         PUBLIC  CR6_image
 189C 00000000		      C CR6_image       DD      ?
			      C 
			      C 
			      C ; Variables for storing SROM/Final Values of 90100 GPR -
 18A0 0100		      C UM9100_GprCtrl         DW 0100h
			      C 
 18A2 0000		      C UM9100_GprData10       DW 00h
 18A4 0000		      C UM9100_GprData100      DW 00h
 18A6 0000		      C UM9100_GprDataFD10     DW 00h
 18A8 0000		      C UM9100_GprDataFD100    DW 00h
			      C 
 18AA 1D		      C SROM_COMM10             DB 01Dh
 18AB 8D		      C SROM_COMM100            DB 08Dh
 18AC 1D		      C SROM_COMMFD10           DB 01Dh
 18AD 8D		      C SROM_COMMFD100          DB 08Dh
			      C 
			      C ;;
			      C ; Flag saying if an interrupt was pending before chip reset.
			      C         PUBLIC  TulipIntPosted
 18AE 0000		      C TulipIntPosted          DW      0
			      C 
 18B0 00		      C legacy                  DB 0  ; Default: Legacy mode not active
			      C 
 18B1 44 65 62 75 67 3A	      C Full_Duplex_msg         DB      'Debug: Full Duplex Mode'
       20 46 75 6C 6C 20
       44 75 70 6C 65 78
       20 4D 6F 64 65
 18C8 = 0017		      C Full_Duplex_msg_len     EQU     $ - Full_Duplex_msg
			      C 
 18C8 44 65 62 75 67 3A	      C Half_Duplex_msg         DB      'Debug: Half Duplex Mode'
       20 48 61 6C 66 20
       44 75 70 6C 65 78
       20 4D 6F 64 65
 18DF = 0017		      C Half_Duplex_msg_len     EQU     $ - Half_Duplex_msg
			      C 
 18DF 44 65 62 75 67 3A	      C PHY10_msg         DB      'Debug: Speed = 10 Mb'
       20 53 70 65 65 64
       20 3D 20 31 30 20
       4D 62
 18F3 = 0014		      C PHY10_msg_len     EQU     $ - PHY10_msg
			      C 
 18F3 44 65 62 75 67 3A	      C PHY100_msg         DB      'Debug: Speed = 100 Mb'
       20 53 70 65 65 64
       20 3D 20 31 30 30
       20 4D 62
 1908 = 0015		      C PHY100_msg_len     EQU     $ - PHY100_msg
			      C 
 1908 46 61 74 61 6C 20	      C SetupFrame_fail_msg     DB      'Fatal Error: Send setup frame is not completed.'
       45 72 72 6F 72 3A
       20 53 65 6E 64 20
       73 65 74 75 70 20
       66 72 61 6D 65 20
       69 73 20 6E 6F 74
       20 63 6F 6D 70 6C
       65 74 65 64 2E
 1937  0D 0A		      C                         DB      CR, LF
 1939 = 0031		      C SetupFrame_fail_msg_len EQU     $ - SetupFrame_fail_msg
			      C 
 1939 46 61 74 61 6C 20	      C SROM_Corrupted_msg      db      'Fatal Error: SROM corrupted.', 0Dh, 0Ah, '$'
       45 72 72 6F 72 3A
       20 53 52 4F 4D 20
       63 6F 72 72 75 70
       74 65 64 2E 0D 0A
       24
			      C 
 1958 46 61 74 61 6C 20	      C SROM_Version_not_msg    DB      'Fatal Error: SROM Version is not Version 3.', 0Dh, 0Ah, '$'
       45 72 72 6F 72 3A
       20 53 52 4F 4D 20
       56 65 72 73 69 6F
       6E 20 69 73 20 6E
       6F 74 20 56 65 72
       73 69 6F 6E 20 33
       2E 0D 0A 24
			      C 
 1986 46 61 74 61 6C 20	      C SROM_Count_not_One_msg  DB      'Fatal Error: SROM support controller > 1.', 0Dh, 0Ah, '$'
       45 72 72 6F 72 3A
       20 53 52 4F 4D 20
       73 75 70 70 6F 72
       74 20 63 6F 6E 74
       72 6F 6C 6C 65 72
       20 3E 20 31 2E 0D
       0A 24
			      C 
 19B2 46 61 74 61 6C 20	      C No_Match_ability_msg    DB      'Fatal Error: Auto-Negotiation fail (No Match Ability)', 0Dh, 0Ah, '
       45 72 72 6F 72 3A      C $'
       20 41 75 74 6F 2D
       4E 65 67 6F 74 69
       61 74 69 6F 6E 20
       66 61 69 6C 20 28
       4E 6F 20 4D 61 74
       63 68 20 41 62 69
       6C 69 74 79 29 0D
       0A 24
			      C 
			      C 
			      C ;;++, 980310, Hu-Tiong
 19EA 0D 0A 50 65 72 66	      C PerformAutoSenseMsg     db      0Dh, 0Ah, "Performing Power-Up Autosense...", 0Dh, 0Ah, '$'
       6F 72 6D 69 6E 67
       20 50 6F 77 65 72
       2D 55 70 20 41 75
       74 6F 73 65 6E 73
       65 2E 2E 2E 0D 0A
       24
 1A0F 0000		      C CheckAutoCompleteCnt    dw      0
 1A11 0000		      C AutoCompleteTimeOut     dw      0
			      C ;;++
			      C 
			      C ;;++, 980930, Hu-Tiong
			      C         PUBLIC  SetCR6
 1A13			      C SetCR6  PROC NEAR
			      C ;;--, 2000.1.31, hu-tiong
			      C if 0
			      C endif
			      C ;;--
			      C ;;++, 2000.1.31, hu-tiong
			      C ;if 0
 1A13  80 3E 1892 R 04	      C         cmp     SROMPortFlag, 4
 1A18  75 14		      C         jne     fnet_not_1m_home_pna
			      C 
 1A1A  66| 81 26 1878 R	      C         and     PortConfigCR6, NOT CR6_M_FDM
       FFFFFDFF
 1A23  66| 81 0E 1878 R	      C         or      PortConfigCR6,  CR6_M_MSPS      ; bit18 = 1, HOME PNA
       00040000
 1A2C  EB 38		      C         jmp     pi_done
			      C 
 1A2E			      C fnet_not_1m_home_pna:
			      C ;;++, 2000.6.27, htho, switching adapter support
 1A2E  80 3E 1873 R 00	      C         cmp     switch_adapter, 0
 1A33  74 0B		      C         je      use_internal_phy
			      C 
 1A35  66| 81 0E 1878 R	      C         or      PortConfigCR6,  CR6_M_MSPS      ; use external phy path
       00040000
 1A3E  EB 09		      C         jmp     chk_sromportflag
			      C 
 1A40			      C use_internal_phy:
			      C ;;++
 1A40  66| 81 26 1878 R	      C         and     PortConfigCR6, NOT CR6_M_MSPS
       FFFBFFFF
			      C ;endif
			      C ;;++
			      C ;;++, 2000.6.27, htho, switching adapter support
 1A49			      C chk_sromportflag:
			      C ;;++
 1A49  80 3E 1892 R 01	      C         cmp     SROMPortFlag, 1
 1A4E  74 0B		      C         je      fnet_set_full_duplex
			      C 
 1A50			      C fnet_set_half_duplex:
 1A50  66| 81 26 1878 R	      C         and     PortConfigCR6, NOT CR6_M_FDM
       FFFFFDFF
 1A59  EB 0B		      C         jmp     pi_done
			      C 
 1A5B			      C fnet_set_full_duplex:
 1A5B  66| 81 0E 1878 R	      C         or      PortConfigCR6, CR6_M_FDM
       00000200
 1A64  EB 00		      C         jmp     pi_done
			      C ;-------------------------------------------------------
 1A66			      C pi_done:
			      C ;;--, 980611, Hu-Tiong, for DM9102 cut4
			      C ;;++, 980303, Hu-Tiong
			      C ;
			      C ; FIFO's dual port RAM within the DM9102's MAC has problems to handle the
			      C ; situations while the FIFO is written by the network and read by the host
			      C ; simultaneously or vice versa. Set Bit 8 in CR6 ON will inhibit simultaneous
			      C ; read/write of the FIFO.
			      C ;
			      C ifdef SINGLE_PORT
 1A66  66| 81 0E 1878 R	      C         or      PortConfigCR6, CR6_M_ISRW ; inhibit simultaneous read/write
       00000100
			      C endif
			      C 
 1A6F  C3		      C         ret
 1A70			      C SetCR6  ENDP
			      C 
			      C 
			      C         PUBLIC  AutoDetectMediaType
 1A70			      C AutoDetectMediaType     PROC NEAR
			      C ;;++, 2000.6.27, htho, switching adapter support
 1A70  80 3E 1873 R 00	      C         cmp     switch_adapter, 0
 1A75  0F 85 0198	      C         jne     set_CR6
			      C ;;++
			      C 
			      C ;;;;--, 2000.4.6, htho
			      C if 0
			      C endif
			      C ;;;;--
			      C ;
			      C ; Check Auto-Negotiation & Link
			      C ;
 1A79			      C Check_Link_Partner:
			      C ;
			      C ; reset status register
			      C ;
 1A79  8A 3E 1895 R	      C         mov     bh, PHY_Number          ;; assume PHY address = <00001>
 1A7D  B3 01		      C         mov     bl, PHY_BMSR            ;; BMSR(Basic Mode Status Register) index
 1A7F  E8 0000 E	      C         call    Read_Register_PHY       ;; return AX = register value
			      C ;
			      C ; check if auto-negotiation complete
			      C ;
 1A82			      C CheckAutoComplete:
 1A82  8A 3E 1895 R	      C         mov     bh, PHY_Number          ;; assume PHY address = <00001>
 1A86  B3 01		      C         mov     bl, PHY_BMSR            ;; BMSR(Basic Mode Status Register) index
 1A88  E8 0000 E	      C         call    Read_Register_PHY       ;; return AX = register value
			      C ;;;;-+, 2000.4.6, htho
			      C ;;;;    test    ax, BMSR_M_AN           ;; Auto-Negotiation Complete ?
			      C ;;;;    jnz     Link_avail
 1A8B  83 E0 24		      C         and     ax, (BMSR_M_AN OR BMSR_M_LS)
 1A8E  83 F8 24		      C         cmp     ax, (BMSR_M_AN OR BMSR_M_LS)
 1A91  74 49		      C         je      Link_Established
			      C ;;;;-+
			      C 
 1A93  FF 06 1A0F R	      C         inc     CheckAutoCompleteCnt
 1A97  A1 1A0F R	      C         mov     ax, CheckAutoCompleteCnt
 1A9A  3B 06 1A11 R	      C         cmp     ax, AutoCompleteTimeOut
			      C ;;;;-+, 2000.4.6, htho, recover the original one
			      C ;-+, 2000.1.31, hu-tiong
 1A9E  73 02		      C         jae     Link_Fail
			      C ;;;;    jae     Link_avail
			      C ;-+
			      C ;;;;-+
 1AA0  F9		      C         stc
 1AA1  C3		      C         ret
			      C ;;;;--, 2000.4.6, htho
			      C if 0
			      C endif
			      C ;;;;--
			      C 
 1AA2			      C Link_Fail:
 1AA2  C7 06 02EC R 0001      C         mov     PreviousLinkStatus, LINK_FAIL
 1AA8  C7 06 1A0F R 0000      C         mov     CheckAutoCompleteCnt, 0
			      C 
 1AAE  F7 06 0000 E 0200      C         test    flagword, A_OPTION      ; Auto Negotiate mode?
 1AB4  75 03		      C         jnz     auto_fail_default       ; jmp if yes
 1AB6  E9 0158		      C         jmp     set_CR6
			      C 
 1AB9			      C auto_fail_default:
			      C ;++, 2000.1.31, hu-tiong
			      C ifdef   HOMEPNA
			      C ;;;;++, 2000.3.27, htho
 1AB9  80 3E 1896 R 02	      C         cmp     PHYTYPE, PNAPHY
 1ABE  75 0E		      C         jne     @F
			      C ;;;;++
 1AC0  C7 06 1893 R 0001      C         mov     InitPIDataRate, 1
 1AC6  C6 06 1892 R 04	      C         mov     SROMPortFlag, 4
			      C ;;;;-+, 2000.3.27
 1ACB  E9 0143		      C         jmp     set_CR6
 1ACE			      C @@:
			      C ;;;;else
			      C endif
			      C ;;;;-+
 1ACE  C7 06 1893 R 000A      C         mov     InitPIDataRate, 10      ; if link failed, assume it's 10base
 1AD4  C6 06 1892 R 00	      C         mov     SROMPortFlag, 0
			      C ;;;;--, 2000.3.27, htho
			      C ;;;;endif
			      C ;;;;--
			      C ;;-+
 1AD9  E9 0135		      C         jmp     set_CR6
			      C 
 1ADC			      C Link_Established:
 1ADC  C7 06 02EC R 0000      C         mov     PreviousLinkStatus, LINK_PASS
 1AE2  C7 06 1A0F R 0000      C         mov     CheckAutoCompleteCnt, 0
			      C ;
			      C ; check if link partner is capable of NWAY
			      C ;
 1AE8  8A 3E 1895 R	      C         mov     bh, PHY_Number          ;; assume PHY address
 1AEC  B3 06		      C         mov     bl, PHY_ANER            ;; ANER(Auto-Negotiation Expansion Register)
 1AEE  E8 0000 E	      C         call    Read_Register_PHY
 1AF1  A9 0001		      C         test    ax, ANER_M_LAA         ;; Link Partner Auto-negotiation able
 1AF4  0F 84 00AF	      C         jz      partner_NWAY_incapable
			      C 
 1AF8			      C partner_NWAY_capable:
 1AF8  8A 3E 1895 R	      C         mov     bh, PHY_Number
 1AFC  B3 05		      C         mov     bl, PHY_ANLPAR          ;; Auto-Negotiation Partner Ability Register
 1AFE  E8 0000 E	      C         call    Read_Register_PHY
 1B01  50		      C         push    ax
			      C 
			      C         ;; Local ability
 1B02  8A 3E 1895 R	      C         mov     bh, PHY_Number
 1B06  B3 04		      C         mov     bl, PHY_ANAR            ;; Auto-Negotiation Advertisement Register
 1B08  E8 0000 E	      C         call    Read_Register_PHY
			      C ;; -- Decide negotiation result
 1B0B  5B		      C         pop     bx                      ;; Partner ability
			      C 
 1B0C			      C ability_100basetx_FD:
 1B0C  A9 0100		      C         test    ax, 100h                ;; 100BASE-TX Full-Duplex ability
 1B0F  74 14		      C         jz      ability_100baset4
 1B11  F7 C3 0100	      C         test    bx, 100h
 1B15  74 0E		      C         jz      ability_100baset4
 1B17  C7 06 1893 R 0064      C         mov     InitPIDataRate, 100
 1B1D  C6 06 1892 R 01	      C         mov     SROMPortFlag, 1
			      C 
 1B22  E9 00EC		      C         jmp     set_CR6
			      C 
 1B25			      C ability_100baset4:
 1B25  A9 0200		      C         test    ax,200h                 ;; 100BASE-T4 ability
 1B28  74 14		      C         jz      ability_100basetx
 1B2A  F7 C3 0200	      C         test    bx, 200h
 1B2E  74 0E		      C         jz      ability_100basetx
 1B30  C7 06 1893 R 0064      C         mov     InitPIDataRate, 100
 1B36  C6 06 1892 R 03	      C         mov     SROMPortFlag, 3
 1B3B  E9 00D3		      C         jmp     set_CR6
			      C 
 1B3E			      C ability_100basetx:
 1B3E  A9 0080		      C         test    ax, 80h                 ;; 100BASE-TX Half-Duplex ability
 1B41  74 14		      C         jz      ability_10basefd
 1B43  F7 C3 0080	      C         test    bx, 80h
 1B47  74 0E		      C         jz      ability_10basefd
 1B49  C7 06 1893 R 0064      C         mov     InitPIDataRate, 100
 1B4F  C6 06 1892 R 00	      C         mov     SROMPortFlag, 0
			      C 
 1B54  E9 00BA		      C         jmp     set_CR6
			      C 
 1B57			      C ability_10basefd:
 1B57  A9 0040		      C         test    ax, 40h                 ;; 10BASE-T Full-Duplex ability
 1B5A  74 14		      C         jz      ability_10base
 1B5C  F7 C3 0040	      C         test    bx, 40h
 1B60  74 0E		      C         jz      ability_10base
 1B62  C7 06 1893 R 000A      C         mov     InitPIDataRate, 10
 1B68  C6 06 1892 R 01	      C         mov     SROMPortFlag, 1
 1B6D  E9 00A1		      C         jmp     set_CR6
			      C 
 1B70			      C ability_10base:
			      C ;;++, 2000.6.12, htho, renew nway alogrithm
 1B70  A9 0020		      C         test    ax, 20h                 ;; 10BASE-T Half-Duplex ability
 1B73  74 14		      C         jz      capability_mismatch
 1B75  F7 C3 0020	      C         test    bx, 20h
 1B79  74 0E		      C         jz      capability_mismatch
			      C ;;++
 1B7B  C7 06 1893 R 000A      C         mov     InitPIDataRate, 10
 1B81  C6 06 1892 R 00	      C         mov     SROMPortFlag, 0
 1B86  E9 0088		      C         jmp     set_CR6
			      C 
			      C ;;++, 2000.6.12, htho, renew nway alogrithm
 1B89			      C capability_mismatch:
 1B89  8A 3E 1895 R	      C         mov     bh, PHY_Number          ;; assume PHY address = <00001>
 1B8D  B3 00		      C         mov     bl, PHY_BMCR
 1B8F  E8 0000 E	      C         call    Read_Register_PHY
 1B92  A9 2000		      C         test    ax, 2000h
 1B95  74 08		      C         jz      PHY_10MB
			      C 
			      C ;;--- 100MB
 1B97			      C PHY_100MB:
 1B97  C7 06 1893 R 0064      C         mov     InitPIDataRate, 100
			      C ;       jmp     force_media_type
 1B9D  EB 72		      C         jmp     set_CR6
			      C 
 1B9F			      C PHY_10MB:
 1B9F  C7 06 1893 R 000A      C         mov     InitPIDataRate, 10
 1BA5  EB 6A		      C         jmp     set_CR6
			      C ;;++
			      C 
 1BA7			      C partner_NWAY_incapable:
			      C ;;++, 980303, Hu-Tiong
			      C ;; If auto-negotiation failed, line speed of remote partner can still
			      C ;; be distinquished but duplex mode has no way to find out.
			      C ;; We just assume it to be in half duplex mode.
 1BA7  F7 06 0000 E 0200      C         test    flagword, A_OPTION      ; Auto Negotiate speed and duplex mode?
 1BAD  74 23		      C         jz      force_media_type        ; jmp if yes
 1BAF  C6 06 1892 R 00	      C         mov     SROMPortFlag, 0
			      C ;;++
 1BB4			      C find_partner_speed:
			      C COMMENT %
			      C         cmp     PHYTYPE, DSIPHY
			      C         je      dsi_phy
			      C ; if it's a NS's DP83840 compatible PHY
			      C ; Check PHY Address Register (PAR -- 19h) bit 6
			      C ; bit6 = 1 - 10Mb
			      C ;        0 - 100Mb
			      C         mov     bh, PHY_Number          ;; assume PHY address = <00001>
			      C         mov     bl, PHY_PAR             ;; PAR (PHY Address Register)
			      C         call    Read_Register_PHY
			      C 
			      C         test    ax, 40h
			      C         jnz     PHY_10MB
			      C         jmp     PHY_100MB
			      C %
 1BB4			      C dsi_phy:
 1BB4  8A 3E 1895 R	      C         mov     bh, PHY_Number          ;; assume PHY address = <00001>
 1BB8  B3 00		      C         mov     bl, PHY_BMCR
 1BBA  E8 0000 E	      C         call    Read_Register_PHY
 1BBD  A9 2000		      C         test    ax, 2000h
 1BC0  74 08		      C         jz      parallel_detect_PHY_10MB
			      C 
			      C ;;--- 100MB
 1BC2			      C parallel_detect_PHY_100MB:
 1BC2  C7 06 1893 R 0064      C         mov     InitPIDataRate, 100
			      C ;       jmp     force_media_type
 1BC8  EB 47		      C         jmp     set_CR6
			      C 
 1BCA			      C parallel_detect_PHY_10MB:
 1BCA  C7 06 1893 R 000A      C         mov     InitPIDataRate, 10
 1BD0  EB 3F		      C         jmp     set_CR6
			      C 
 1BD2			      C force_media_type:
			      C ;
			      C ; disable auto-negotiation, and set BMCR to the foced media type
			      C ;
 1BD2  33 D2		      C         xor     dx, dx
			      C 
 1BD4  83 3E 1893 R 64	      C         cmp     InitPIDataRate, 100
 1BD9  75 04		      C         jne     force_duplex
 1BDB  81 CA 2000	      C         or      dx, BMCR_M_SL
 1BDF			      C force_duplex:
 1BDF  80 3E 1892 R 01	      C         cmp     SROMPortFlag, 1
 1BE4  75 04		      C         jne     set_BMCR
 1BE6  81 CA 0100	      C         or      dx, BMCR_M_DM
 1BEA			      C set_BMCR:
			      C ;;++, 2001.6.12, htho, we need to write at last 2 times to dm9102a E3 to
			      C ;; force it to correct mode after power on/off it
 1BEA  52		      C         push    dx
			      C ;;++
 1BEB  8A 3E 1895 R	      C         mov     bh, PHY_Number
 1BEF  B3 00		      C         mov     bl, PHY_BMCR
 1BF1  E8 0000 E	      C         call    Write_Register_PHY
			      C 
			      C ;;++, 2001.6.12, htho, we need to write at last 2 times to dm9102a E3 to
			      C ;; force it to correct mode after power on/off it
 1BF4  5A		      C         pop     dx
			      C 
 1BF5  80 3E 1884 R 01	      C         cmp     dm9102a_e3, 1
 1BFA  75 15		      C         jne     @F
			      C 
 1BFC  52		      C         push    dx
			      C 
 1BFD  B9 0FFF		      C         mov     cx, 0FFFh
 1C00			      C abc_loop:
 1C00  51		      C         push    cx
 1C01  E8 FAC6		      C         call    SROMDelay
 1C04  59		      C         pop     cx
 1C05  E2 F9		      C         loop    abc_loop
			      C 
 1C07  5A		      C         pop     dx
			      C 
 1C08  8A 3E 1895 R	      C         mov     bh, PHY_Number
 1C0C  B3 00		      C         mov     bl, PHY_BMCR
 1C0E  E8 0000 E	      C         call    Write_Register_PHY
 1C11			      C @@:
			      C ;;++
			      C ;;---------------------------------------------------------------------------
			      C ; Set correct value into CR6
			      C ;-----------------------------
 1C11			      C set_CR6:
			      C ;;;;++, 2001.8.13, htho
			      C ; Reset PNA PHY to avoid accumulation of Noise Floor in Reg. 25 of DM9801 E3
			      C ; while user warm restart the PC or unload/load driver again.
			      C ; This reset must take the PNA PHY a few seconds to reach a stable state, so
			      C ; we must pospond the pna phy setting some time later (after startup auto).
			      C ifdef HOMEPNA
 1C11  80 3E 1896 R 02	      C         cmp     PHYTYPE, PNAPHY
 1C16  75 27		      C         jne     @F
 1C18  8B 16 2469 R	      C         mov     dx, p_CR6
 1C1C  66| ED		      C         in      eax, dx
 1C1E  66| 50		      C         push    eax
 1C20  66| 0D 00040000	      C         or      eax, CR6_M_MSPS
 1C26  66| EF		      C         out     dx, eax
 1C28  80 3E 1897 R 01	      C         cmp     PNATYPE, LONGRUN
 1C2D  74 05		      C         je      slr
 1C2F  E8 058A		      C         call    Setup_HOMERUN_PHY
 1C32  EB 03		      C         jmp     espna
 1C34			      C slr:
 1C34  E8 0686		      C         call    Setup_LONGRUN_PHY
 1C37			      C espna:
 1C37  66| 58		      C         pop     eax
 1C39  8B 16 2469 R	      C         mov     dx, p_CR6
 1C3D  66| EF		      C         out     dx, eax
 1C3F			      C @@:
			      C endif
			      C ;;;;++
			      C 
 1C3F  E8 FDD1		      C         call    SetCR6
			      C 
 1C42  F8		      C         clc
 1C43  C3		      C         ret
 1C44			      C AutoDetectMediaType     ENDP
			      C ;;++
			      C 
			      C         PUBLIC  DynamicAutoDetect
 1C44			      C DynamicAutoDetect  PROC NEAR
			      C ;;++, 2000.6.27, htho, switching adapter support
 1C44  80 3E 1873 R 00	      C         cmp     switch_adapter, 0
 1C49  0F 85 0150	      C         jne     QuitDynamicAutoDetect
			      C ;;++
			      C ;;;;++, 2000.4.6, htho
 1C4D  A1 0000 E	      C         mov     ax, flagword
 1C50  25 07E0		      C         and     ax, (A_OPTION OR XF_OPTION OR XH_OPTION OR F_OPTION OR H_OPTION OR T_OPTION)
 1C53  3D 0400		      C         cmp     ax, T_OPTION
 1C56  0F 84 0143	      C         je      QuitDynamicAutoDetect
			      C ;;;;++
			      C 
			      C ;add by simon 2001.8.30 
			      C ;check the phy reg24 ,if the noise_level exeeced peak_level
			      C ;then reset the noise_floor 
			      C ;***********************************
			      C ifdef HOMEPNA
 1C5A  8A 3E 1895 R	      C       mov       bh, PHY_Number
 1C5E  B3 18		      C       mov       bl, 24
 1C60  E8 0000 E	      C       call      Read_Register_PHY
 1C63  8B 1E 1869 R	      C       mov bx,p_PHY24
 1C67  B1 08		      C       mov cl,8
 1C69  D3 EB		      C       shr bx,cl
 1C6B  38 D8		      C       cmp al,bl
 1C6D  72 10		      C       jb check_exit
 1C6F  A1 1869 R	      C       mov       ax,p_PHY24
 1C72  8A D0		      C       mov       dl, al
 1C74  B6 F0		      C       mov       dh, 0F0h
 1C76  8A 3E 1895 R	      C       mov       bh, PHY_Number
 1C7A  B3 19		      C       mov       bl, 25
 1C7C  E8 0000 E	      C       call      Write_Register_PHY
			      C 
			      C 
			      C 
			      C endif
			      C 
 1C7F			      C check_exit:
			      C ;***********************************
			      C 
			      C ;
			      C ; check link staus from CR12[0..1] (General Purpose Pin Register)
			      C ;
 1C7F  8B 16 2475 R	      C         mov     dx, p_CR12
 1C83  66| ED		      C         in      eax, dx
 1C85  66| A9 00000003	      C         test    eax, 0003h
 1C8B  75 3E		      C         jnz     Link_Status_Pass
 1C8D  83 3E 02EC R 00	      C         cmp     PreviousLinkStatus, LINK_PASS
 1C92  0F 85 0107	      C         jne     QuitDynamicAutoDetect
			      C ;
			      C ; Link status change from PASS to FAIL
			      C ;
 1C96  C7 06 02EC R 0001      C         mov     PreviousLinkStatus, LINK_FAIL
			      C 
			      C ifdef HOMEPNA
 1C9C  80 3E 1896 R 02	      C         cmp     PHYTYPE, PNAPHY
 1CA1  75 25		      C         jne     @F
			      C         ;
			      C         ; 100BASE-T link fail, use HOME PNA
			      C         ;
 1CA3  C6 06 1892 R 04	      C         mov     SROMPortFlag, 4
 1CA8  C7 06 1893 R 0001      C         mov     InitPIDataRate, 1
			      C 
 1CAE  66| A1 1878 R	      C         mov     eax, PortConfigCR6
 1CB2  66| 25 FFFFFDFF	      C         and     eax, NOT CR6_M_FDM      ; CR6 bit9  = 0, half duplex
 1CB8  66| 0D 00040000	      C         or      eax, CR6_M_MSPS         ; CR6 bit18 = 1, HOME PNA
 1CBE  66| A3 1878 R	      C         mov     PortConfigCR6, eax
 1CC2  E8 0457		      C         call    PortCR6Write
			      C 
			      C ;;;;-+, 2000.6.27, rewrite PNA PHY setting
			      C         ;
			      C         ; PNA PHY may need to resend remote command this time
			      C         ;
 1CC5  E8 04BA		      C         call    PNA_Set_CR16
			      C ;;;;-+
 1CC8			      C @@:
			      C endif
			      C 
 1CC8  E9 00D2		      C         jmp     QuitDynamicAutoDetect
			      C 
 1CCB			      C Link_Status_Pass:
 1CCB  83 3E 02EC R 01	      C         cmp     PreviousLinkStatus, LINK_FAIL
 1CD0  0F 85 00C9	      C         jne     QuitDynamicAutoDetect
			      C ;
			      C ; Link status change from FAIL to PASS
			      C ;
 1CD4  C7 06 02EC R 0000      C         mov     PreviousLinkStatus, LINK_PASS
			      C         ;
			      C         ; use 100BASE-T, CR6 bit18=0
			      C         ;
			      C ifdef HOMEPNA
			      C ;;-+, 2000.2.16, hu-tiong
			      C ;       mov     dx, p_CR6
			      C ;       in      eax, dx
			      C ;
			      C ;       and     eax, NOT CR6_M_MSPS     ; CR6 bit18 = 0, 100Base-T
			      C ;
			      C ;       out     dx, eax
 1CDA  66| A1 1878 R	      C         mov     eax, PortConfigCR6
 1CDE  66| 25 FFFBFFFF	      C         and     eax, NOT CR6_M_MSPS
 1CE4  66| A3 1878 R	      C         mov     PortConfigCR6, eax
 1CE8  E8 0431		      C         call    PortCR6Write
			      C ;;-+
			      C endif
			      C         ;
			      C         ; reset status register
			      C         ;
 1CEB  8A 3E 1895 R	      C         mov     bh, PHY_Number          ; assume PHY address = <00001>
 1CEF  B3 01		      C         mov     bl, PHY_BMSR            ; BMSR(Basic Mode Status Register) index
 1CF1  E8 0000 E	      C         call    Read_Register_PHY       ; return AX = register value
			      C         ;
			      C         ; check auto-negotiation complete & link status
			      C         ;
 1CF4  B9 05FF		      C         mov     cx, 05ffh
 1CF7			      C DAN_loop:
 1CF7  51		      C         push    cx
 1CF8  8A 3E 1895 R	      C         mov     bh, PHY_Number          ; assume PHY address = <00001>
 1CFC  B3 01		      C         mov     bl, PHY_BMSR            ; BMSR(Basic Mode Status Register) index
 1CFE  E8 0000 E	      C         call    Read_Register_PHY       ; return AX = register value
 1D01  59		      C         pop     cx
			      C 
 1D02  83 E0 24		      C         and     ax, BMSR_M_AN OR BMSR_M_LS
 1D05  83 F8 24		      C         cmp     ax, BMSR_M_AN OR BMSR_M_LS
 1D08  74 12		      C         je      DAN_AutoComplete
			      C 
 1D0A  E8 F9BD		      C         call    SROMDelay
 1D0D  E2 E8		      C         loop    DAN_loop
			      C 
 1D0F  C6 06 1892 R 00	      C         mov     SROMPortFlag, 0
 1D14  C7 06 1893 R 000A      C         mov     InitPIDataRate, 10
			      C 
 1D1A  EB 5F		      C         jmp     DAN_set_cr6
			      C 
 1D1C			      C DAN_AutoComplete:
 1D1C  8A 3E 1895 R	      C         mov     bh, PHY_Number          ; assume PHY address = <00001>
 1D20  B3 11		      C         mov     bl, PHY_DSCSR           ; DSCSR(DAVICOM Specified Configuration and Status Register)
 1D22  E8 0000 E	      C         call    Read_Register_PHY       ; return AX = register value
			      C 
 1D25  25 F000		      C         and     ax, 0F000h
			      C 
 1D28  3D 1000		      C         cmp     ax, 1000h
 1D2B  75 0D		      C         jne     anc_not_10m_half
			      C 
 1D2D  C6 06 1892 R 00	      C         mov     SROMPortFlag, 0
 1D32  C7 06 1893 R 000A      C         mov     InitPIDataRate, 10
 1D38  EB 41		      C         jmp     DAN_set_cr6
			      C 
 1D3A			      C anc_not_10m_half:
 1D3A  3D 2000		      C         cmp     ax, 2000h
 1D3D  75 0D		      C         jne     anc_not_10m_full
			      C 
 1D3F  C6 06 1892 R 01	      C         mov     SROMPortFlag, 1
 1D44  C7 06 1893 R 000A      C         mov     InitPIDataRate, 10
 1D4A  EB 2F		      C         jmp     DAN_set_cr6
			      C 
 1D4C			      C anc_not_10m_full:
 1D4C  3D 4000		      C         cmp     ax, 4000h
 1D4F  75 0D		      C         jne     anc_not_100m_half
			      C 
 1D51  C6 06 1892 R 00	      C         mov     SROMPortFlag, 0
 1D56  C7 06 1893 R 0064      C         mov     InitPIDataRate, 100
 1D5C  EB 1D		      C         jmp     DAN_set_cr6
			      C 
 1D5E			      C anc_not_100m_half:
 1D5E  3D 8000		      C         cmp     ax, 8000h
 1D61  75 0D		      C         jne     anc_not_100m_full
			      C 
 1D63  C6 06 1892 R 00	      C         mov     SROMPortFlag, 0
 1D68  C7 06 1893 R 0064      C         mov     InitPIDataRate, 100
 1D6E  EB 0B		      C         jmp     DAN_set_cr6
			      C 
 1D70			      C anc_not_100m_full:
 1D70  C6 06 1892 R 00	      C         mov     SROMPortFlag, 0
 1D75  C7 06 1893 R 000A      C         mov     InitPIDataRate, 10
			      C 
 1D7B			      C DAN_set_cr6:
			      C 
			      C ;;-+, 2000.2.16, hu-tiong
			      C ;       mov     dx, p_CR6
			      C ;       in      eax, dx
 1D7B  66| A1 1878 R	      C         mov     eax, PortConfigCR6
			      C ;;-+
			      C 
 1D7F  80 3E 1892 R 01	      C         cmp     SROMPortFlag, 1
 1D84  74 08		      C         je      DAN_set_full_duplex
			      C 
 1D86			      C DAN_set_half_duplex:
 1D86  66| 25 FFFFFDFF	      C         and     eax, NOT CR6_M_FDM
 1D8C  EB 08		      C         jmp     DAN_done
			      C 
 1D8E			      C DAN_set_full_duplex:
 1D8E  66| 0D 00000200	      C         or      eax, CR6_M_FDM
 1D94  EB 00		      C         jmp     DAN_done
			      C ;-------------------------------------------------------
 1D96			      C DAN_done:
			      C ;;-+, 2000.2.16, hu-tiong
			      C ;       mov     dx, p_CR6
			      C ;       out     dx, eax
 1D96  66| A3 1878 R	      C         mov     PortConfigCR6, eax
 1D9A  E8 037F		      C         call    PortCR6Write
			      C ;;-+
			      C 
 1D9D			      C QuitDynamicAutoDetect:
 1D9D  C3		      C         ret
 1D9E			      C DynamicAutoDetect  ENDP
			      C ;--------------------------------------------------------------------+
			      C ; Name : PortInit
			      C ;
			      C ; Description: Initializes the hardware.
			      C ;               . Get Ethernet address from SROM.
			      C ;               . Setup CR6 & CR12 initial value.
			      C ;               . Decide media type according to options.
			      C ;
			      C ; Enter :
			      C ;
			      C ; Return : Carry flag set if error.
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C           ALIGN  4
			      C           PUBLIC PortInit
 1DA0			      C PortInit  PROC  NEAR
 1DA0  06		      C         push es
 1DA1  57		      C         push di
 1DA2  56		      C         push si
 1DA3  66| 50		      C         push eax
 1DA5  66| 51		      C         push ecx
 1DA7  66| 52		      C         push edx
			      C 
 1DA9  8C D8		      C         mov ax, ds
 1DAB  8E C0		      C         mov es, ax
			      C ;
			      C ; -- Assert software reset
			      C ;
 1DAD  66| B8 00000001	      C         mov  eax, CR0_M_SR
 1DB3  8B 16 245D R	      C         mov  dx, p_CR0
 1DB7  66| EF		      C         out  dx, eax
			      C 
			      C ;; --- Process speed & xmt mode options
			      C ;;        test    flagword, S_OPTION
			      C ;;        jnz      fd_select                      ;; Jump if setect 10Mb
			      C ;;        mov     InitPIDataRate, 100
			      C 
			      C ;;fd_select:
			      C ;;        test    flagword, F_OPTION
			      C ;;        jz      fnet_pci_enet_rom_read          ;; Jump if no select (Half-duplex)
			      C ;;        mov     SROMPortFlag, 1                 ;; Full Deplex flag
			      C 
 1DB9			      C fnet_pci_enet_rom_read:                    ; DM9100 READ
 1DB9  B9 0040		      C         mov     cx, SROM_93LC46B_LEN       ; CX - Num of words to read ;; (64 words)
 1DBC  8B 36 1028 R	      C         mov     si, RcvCurrentDescriptor   ; SI - Address into where to read
 1DC0  8B 74 10		      C         mov     si, [si].RCV_DESCRIPTOR.p_RcvBuffer
 1DC3  89 36 188F R	      C         mov     SROMImage, si
 1DC7  E8 FA46		      C         call    ReadSROM
 1DCA  73 0A		      C         jnc     fnet_verify_version             ;; Jump if not legacy
			      C 
			      C ;;--, 2000.1.31, hu-tiong
			      C if 0
			      C endif
			      C ;;--
 1DCC  BA 1939 R	      C         mov     dx, OFFSET SROM_Corrupted_msg
 1DCF  B4 09		      C         mov     ah, 9
 1DD1  CD 21		      C         int     21h
 1DD3  E9 01CB		      C         jmp     pi_ret
			      C 
			      C ; Verify version number of SROM
			      C ;-------------------------------
 1DD6			      C fnet_verify_version:
			      C ;;--, 2000.1.31, hu-tiong
			      C if 0
			      C endif
			      C ;;--
			      C 
 1DD6			      C srom_ieee:
			      C ; Set IEEE adress read from SROM
			      C ;---------------------------------
 1DD6  8D 7C 14		      C         lea     di, [si].NS_Ether_Addr
 1DD9  8A 44 1A		      C         mov     al, [si].NS_Dev_Number
 1DDC  A2 1891 R	      C         mov     AdapterNum, al
			      C ;;        add     BYTE PTR [di+5], al
			      C ;;        adc     BYTE PTR [di+4], 0
			      C ;;        adc     BYTE PTR [di+3], 0
			      C ;;        adc     BYTE PTR [di+2], 0
			      C ;;        adc     BYTE PTR [di+1], 0
			      C ;;        adc     BYTE PTR [di], 0
			      C 
			      C ; Extract IEEE address
 1DDF  56		      C         push    si
 1DE0  8B F7		      C         mov     si, di
 1DE2  BF 0000 E	      C         mov     di, OFFSET rom_address
 1DE5  66| B9 00000006	      C         mov     ecx, 6
			      C 
 1DEB			      C ieee_byte_loop:                 ; Loop over six bytes of IEEE address
 1DEB  8A 04		      C         mov     al, BYTE PTR [si]
 1DED  AA		      C         stosb
 1DEE  46		      C         inc     si
 1DEF  E2 FA		      C         loop    ieee_byte_loop
			      C 
			      C ;    Initialize current station address
			      C ;------------------------------------------------------------------
 1DF1			      C pi_init_current_addr:
 1DF1  BF 0000 E	      C         mov     di, OFFSET my_address
 1DF4  BE 0000 E	      C         mov     si, OFFSET rom_address
			      C 
 1DF7			      C pi_copy_IEEE_address:
 1DF7  A5		      C         movsw
 1DF8  A5		      C         movsw
 1DF9  A5		      C         movsw
			      C 
 1DFA  5E		      C         pop     si                      ;; Pop SROM pointer
			      C ;Additional SROM processing:
			      C ;---------------------------------------------------------------------
			      C ; omitted
			      C ;;++, 2000.6.27, htho, switching adapter support
			      C         ;
			      C         ; DS:SI --> local SROM data buffer
			      C         ;
 1DFB  E8 0571		      C         call    check_switching_adapter
			      C ;;++
			      C ;;;;++, 2000.8.24, htho, support DM9009(DM9102 without 100M PHY capability)
 1DFE  E8 05C3		      C         call    check_dm9009
			      C ;;;;++
			      C ;;;;++, 2000.8.24, htho, support VLAN & Tx/Rx flow control
 1E01  E8 05F5		      C         call    config_cr15
			      C ;;;;++
			      C ;;;;++, 2000.10.4, simulate line plug out/in by power off/on phy for DM9102A E3
 1E04  E8 0632		      C         call    check_dm9102a_e3
			      C ;;;;++
			      C 
			      C ;;---------------------------------------------------------------------------
			      C ;; --- Run auto-negotiation
			      C ;;;--- Read PHY OUI
			      C ;;++, 2000.3.27, htho
			      C ifdef HOMEPNA
 1E07  8B 16 2469 R	      C         mov     dx, p_CR6
 1E0B  66| ED		      C         in      eax, dx
			      C 
 1E0D  66| 50		      C         push    eax
			      C 
 1E0F  66| 0D 00040000	      C         or      eax, CR6_M_MSPS
 1E15  66| EF		      C         out     dx, eax
			      C 
 1E17  8A 3E 1895 R	      C         mov     bh, PHY_Number          ;; assume PHY address = <00001>
 1E1B  B3 03		      C         mov     bl, PHY_PHYIDR2         ;; PHYIDR1(PHY IDENTIFIER REGISTER#2) index
 1E1D  E8 0000 E	      C         call    Read_Register_PHY       ;; return AX = register value
			      C 
 1E20  C6 06 1896 R 00	      C         mov     PHYTYPE, DSIPHY
			      C 
			      C ;;;;-+, 2000.9.19, htho, support DM9801 E4
			      C ;;;;    cmp     ax, 0B900h              ; DM9801 PHY ID1=0181h, PHY ID2=B900h
 1E25  8A D8		      C         mov     bl, al
 1E27  80 E3 0F		      C         and     bl, 0Fh
 1E2A  88 1E 1883 R	      C         mov     pnaphy_rev, bl
 1E2E  83 E0 F0		      C         and     ax, 0FFF0h
 1E31  3D B900		      C         cmp     ax, 0B900h
			      C ;;;;-+
 1E34  75 2B		      C         jne     restore_cr6
			      C 
			      C ;;;;++, 2001.8.13, htho
			      C ; Reset PNA PHY to avoid accumulation of Noise Floor in Reg. 25 of DM9801 E3
			      C ; while user warm restart the PC or unload/load driver again.
			      C ; This reset must take the PNA PHY a few seconds to reach a stable state, so
			      C ; we must pospond the pna phy setting some time later (after startup auto).
 1E36  BA 8000		      C         mov     dx, 8000h
 1E39  8A 3E 1895 R	      C         mov     bh, PHY_Number
 1E3D  B3 00		      C         mov     bl, PHY_BMCR
 1E3F  E8 0000 E	      C         call    Write_Register_PHY
			      C ;;;;++
			      C 
 1E42  C6 06 1896 R 02	      C         mov     PHYTYPE, PNAPHY
			      C 
			      C ;;;;-+, 2000.6.27, rewrite PNA PHY setting
			      C ;;;;++, 2000.5.2, htho, check if PNAPHY is HOMERUN or LONGRUN
 1E47  8A 3E 1895 R	      C         mov     bh, PHY_Number
 1E4B  B3 1F		      C         mov     bl, 31                  ; Transmit Pulse Width, Cycles
 1E4D  E8 0000 E	      C         call    Read_Register_PHY
			      C ;;-+, 2001.3.30, htho, support HPNA speed setting
			      C ;; Reg 31 will not always be 110Fh after different speed setting for DM9802
			      C ;;      cmp     ax, 110Fh
			      C ;;      jne     HomeRunFound
 1E50  3D 4404		      C         cmp     ax, 4404h
 1E53  74 07		      C         je      HomeRunFound
			      C ;;-+
			      C ;;;;;   mov     bh, PHY_Number
			      C ;;;;;   mov     bl, 29                  ; Transmit Pulse Width, Cycles
			      C ;;;;;   call    Read_Register_PHY
			      C ;;;;;   cmp     ax, 5450h
			      C ;;;;;   jne     @F
			      C ;
			      C ; LONG-RUN phy is found on board
			      C ;
 1E55  C6 06 1897 R 01	      C         mov     PNATYPE, LONGRUN
			      C 
			      C ;;;;--, 2001.8.13, htho
			      C ; Reset PNA PHY to avoid accumulation of Noise Floor in Reg. 25 of DM9801 E3
			      C ; while user warm restart the PC or unload/load driver again.
			      C ; This reset must take the PNA PHY a few seconds to reach a stable state, so
			      C ; we must pospond the pna phy setting some time later (after startup auto).
			      C ;;;;    call    Setup_LONGRUN_PHY
			      C ;;;;__
			      C 
 1E5A  EB 05		      C         jmp     restore_cr6
			      C 
			      C ;
			      C ; HOME-RUN phy is found on board
			      C ;
 1E5C			      C HomeRunFound:
 1E5C  C6 06 1897 R 00	      C         mov     PNATYPE, HOMERUN        ; default to HOMERUN
			      C 
			      C ;;;;--, 2001.8.13, htho
			      C ; Reset PNA PHY to avoid accumulation of Noise Floor in Reg. 25 of DM9801 E3
			      C ; while user warm restart the PC or unload/load driver again.
			      C ; This reset must take the PNA PHY a few seconds to reach a stable state, so
			      C ; we must pospond the pna phy setting some time later (after startup auto).
			      C ;;;;    call    Setup_HOMERUN_PHY
			      C ;;;;--
			      C 
			      C ;;;;++
			      C ;;;;-+
			      C 
 1E61			      C restore_cr6:
 1E61  66| 58		      C         pop     eax
 1E63  8B 16 2469 R	      C         mov     dx, p_CR6
 1E67  66| EF		      C         out     dx, eax
			      C else
			      C endif
			      C ;;++
			      C 
			      C ;; -- Process fource media options
 1E69			      C Operation:
			      C 
 1E69  F7 06 0000 E 0200      C         test    flagword, A_OPTION      ; Auto Negotiate speed and duplex mode?
 1E6F  0F 85 0095	      C         jnz     Auto_Negotiate          ; jmp if yes
			      C 
			      C ;;;;++, 2000.8.24, htho, support DM9009(DM9102 without 100M PHY capability)
 1E73  80 3E 2454 R 01	      C         cmp     ChipType, DM9009_CHIP   ; no 100M PHY capability
 1E78  74 36		      C         je      Not_100HD
			      C ;;;;++
			      C 
 1E7A  F7 06 0000 E 0100      C         test    flagword, XF_OPTION     ; forced 100Mb Full-Duplex?
 1E80  74 13		      C         jz      Not_100FD               ; jmp if not
			      C 
 1E82  C7 06 1893 R 0064      C         mov     InitPIDataRate, 100     ; speed = 100Mb
 1E88  C6 06 1892 R 01	      C         mov     SROMPortFlag, 1         ; Full Duplex TP
			      C ;;-+, 2001.6.21, htho, dual speed hub link fail while forced 10/100 full duplex
			      C ;;      mov     anar, ANAR_FCS+ANAR_TX_FDX+ANAR_CSMACD
 1E8D  C7 06 188D R 0581      C         mov     anar, ANAR_FCS+ANAR_TX_FDX+ANAR_TX_HDX+ANAR_CSMACD
			      C ;;-+
 1E93  EB 73		      C         jmp     short Auto_Negotiate
			      C 
 1E95			      C Not_100FD:
 1E95  F7 06 0000 E 0080      C         test    flagword, XH_OPTION     ; forced 100Mb Half-Duplex?
 1E9B  74 13		      C         jz      Not_100HD               ; jmp if not
			      C 
 1E9D  C7 06 1893 R 0064      C         mov     InitPIDataRate, 100     ; speed = 100Mb
 1EA3  C6 06 1892 R 00	      C         mov     SROMPortFlag, 0         ; Half Duplex
 1EA8  C7 06 188D R 0481      C         mov     anar, ANAR_FCS+ANAR_TX_HDX+ANAR_CSMACD
 1EAE  EB 58		      C         jmp     short Auto_Negotiate
			      C 
 1EB0			      C Not_100HD:
 1EB0  F7 06 0000 E 0040      C         test    flagword, F_OPTION      ; forced 10Mb Full-Duplex?
 1EB6  74 13		      C         jz      Not_10FD                ; jmp if not
			      C 
 1EB8  C7 06 1893 R 000A      C         mov     InitPIDataRate, 10      ; speed = 10Mb
 1EBE  C6 06 1892 R 01	      C         mov     SROMPortFlag, 1         ; Full Duplex TP
			      C ;;-+, 2001.6.21, htho, dual speed hub link fail while forced 10/100 full duplex
			      C ;;      mov     anar, ANAR_FCS+ANAR_10_FDX+ANAR_CSMACD
 1EC3  C7 06 188D R 0461      C         mov     anar, ANAR_FCS+ANAR_10_FDX+ANAR_10_HDX+ANAR_CSMACD
			      C ;;-+
 1EC9  EB 3D		      C         jmp     short Auto_Negotiate
			      C 
 1ECB			      C Not_10FD:
 1ECB  F7 06 0000 E 0020      C         test    flagword, H_OPTION      ; forced 10Mb Half-Duplex?
 1ED1  74 13		      C         jz      Not_10HD                ; jmp if not, auto as default
			      C 
 1ED3  C7 06 1893 R 000A      C         mov     InitPIDataRate, 10      ; speed = 10Mb
 1ED9  C6 06 1892 R 00	      C         mov     SROMPortFlag, 0         ; Half Duplex
 1EDE  C7 06 188D R 0421      C         mov     anar, ANAR_FCS+ANAR_10_HDX+ANAR_CSMACD
 1EE4  EB 22		      C         jmp     Auto_Negotiate
			      C 
 1EE6			      C Not_10HD:
			      C ;;++2000.1.31, Hu-Tiong
			      C ifdef  HOMEPNA
 1EE6  F7 06 0000 E 0400      C         test    flagword, T_OPTION      ; forced 1Mb HomePNA
 1EEC  74 14		      C         jz      Not_1PNA
			      C 
 1EEE  C7 06 1893 R 0001      C         mov     InitPIDataRate, 1
 1EF4  C6 06 1892 R 04	      C         mov     SROMPortFlag, 4
			      C ;;;;-+, 2000.4.6, htho
			      C ;;;;    jmp     Auto_Negotiate
 1EF9  80 3E 1896 R 02	      C         cmp     PHYTYPE, PNAPHY
 1EFE  0F 84 0094	      C         je      pi_set_CR6
			      C ;;;;-+
 1F02			      C Not_1PNA:
			      C endif
			      C ;;++
 1F02  81 0E 0000 E 0200      C         or      flagword, A_OPTION      ; in case that media type not specified
			      C 
 1F08			      C Auto_Negotiate:
 1F08  BA 19EA R	      C         mov     dx, offset PerformAutoSenseMsg
 1F0B  B4 09		      C         mov     ah, 9
 1F0D  CD 21		      C         int     21h
			      C ;
			      C ; Reset PHY before configuration to make sure that previous installation of
			      C ; the driver will not affect the correct setting now.
			      C ; auto-negotiation.
			      C ;
			      C ;;;;++, 2000.3.27
			      C ifdef HOMEPNA
 1F0F  80 3E 1896 R 02	      C         cmp     PHYTYPE, PNAPHY
 1F14  75 0E		      C         jne     @F
			      C 
 1F16  8B 16 2469 R	      C         mov     dx, p_CR6
 1F1A  66| ED		      C         in      eax, dx
			      C 
 1F1C  66| 25 FFFBFFFF	      C         and     eax, NOT CR6_M_MSPS
 1F22  66| EF		      C         out     dx, eax
 1F24			      C @@:
			      C endif
			      C ;;;;++
			      C 
			      C ; must reset phy here, otherwise auto won't stop
 1F24  BA 8000		      C         mov     dx, 8000h
 1F27  8A 3E 1895 R	      C         mov     bh, PHY_Number
 1F2B  B3 00		      C         mov     bl, PHY_BMCR
 1F2D  E8 0000 E	      C         call    Write_Register_PHY
			      C 
			      C ;;;;++, 2000.4.6, htho
			      C ;
			      C ; write local capability to ANAR
			      C ;
 1F30  8B 16 188D R	      C         mov     dx, anar
 1F34  8A 3E 1895 R	      C         mov     bh, PHY_Number
 1F38  B3 04		      C         mov     bl, PHY_ANAR
 1F3A  E8 0000 E	      C         call    Write_Register_PHY
			      C 
 1F3D  E8 F78A		      C         call    SROMDelay
			      C 
			      C ;;;;++, 2000.10.4, simulate line plug out/in by power off/on phy for DM9102A E3
 1F40  80 3E 1884 R 01	      C         cmp     dm9102a_e3, 1
 1F45  74 0E		      C         je      @F
			      C ;;;;++
			      C ;
			      C ; restart auto-negotiation
			      C ;
 1F47  BA 1200		      C         mov     dx, BMCR_M_ANE+BMCR_M_RAN
 1F4A  8A 3E 1895 R	      C         mov     bh, PHY_Number
 1F4E  B3 00		      C         mov     bl, PHY_BMCR
 1F50  E8 0000 E	      C         call    Write_Register_PHY
			      C 
			      C ;;;;++, 2000.10.4, simulate line plug out/in by power off/on phy for DM9102A E3
 1F53  EB 31		      C         jmp     do_anc
 1F55			      C @@:
 1F55  BA 1800		      C         mov     dx, 1800h               ; power down phy
 1F58  8A 3E 1895 R	      C         mov     bh, PHY_Number
 1F5C  B3 00		      C         mov     bl, PHY_BMCR
 1F5E  E8 0000 E	      C         call    Write_Register_PHY
			      C 
 1F61  B9 5FFF		      C         mov     cx, 5FFFh
 1F64			      C pd_loop:
 1F64  51		      C         push    cx
 1F65  E8 F762		      C         call    SROMDelay               ;
 1F68  E8 F75F		      C         call    SROMDelay               ;
 1F6B  E8 F75C		      C         call    SROMDelay               ;
 1F6E  E8 F759		      C         call    SROMDelay               ; must wait for this long time
 1F71  E8 F756		      C         call    SROMDelay               ;
 1F74  E8 F753		      C         call    SROMDelay               ;
 1F77  59		      C         pop     cx
 1F78  E2 EA		      C         loop    pd_loop
			      C 
 1F7A  BA 1000		      C         mov     dx, 1000h               ; power on phy again
 1F7D  8A 3E 1895 R	      C         mov     bh, PHY_Number
 1F81  B3 00		      C         mov     bl, PHY_BMCR
 1F83  E8 0000 E	      C         call    Write_Register_PHY
 1F86			      C do_anc:
			      C ;;;;++
			      C ;;;;++
			      C 
 1F86  C7 06 1A11 R 0FFF      C         mov     AutoCompleteTimeOut, 0fffh
 1F8C			      C ANC_loop:
 1F8C  E8 F73B		      C         call    SROMDelay
 1F8F  E8 FADE		      C         call    AutoDetectMediaType
 1F92  72 F8		      C         jc      ANC_loop
 1F94  EB 03		      C         jmp     pi_port_reset
			      C ;
			      C ; notified by non MII PHY
			      C ;
 1F96			      C pi_set_CR6:
 1F96  E8 FA7A		      C         call    SetCR6
			      C ;
			      C ;   Reset everything, to start clean
			      C ;
			      C 
 1F99			      C pi_port_reset:
 1F99  E8 001C		      C         call    PortUpdateReceiveFilter
 1F9C  73 02		      C         jnc     Update_ok
 1F9E  EB 01		      C         jmp     pi_ret                          ;; Failure
			      C 
 1FA0			      C Update_ok:
 1FA0  F8		      C         clc
			      C 
 1FA1			      C pi_ret:
 1FA1  66| 5A		      C         pop     edx
 1FA3  66| 59		      C         pop     ecx
 1FA5  66| 58		      C         pop     eax
 1FA7  5E		      C         pop     si
 1FA8  5F		      C         pop     di
 1FA9  07		      C         pop     es
 1FAA  C3		      C         ret
 1FAB			      C PortInit  ENDP
			      C 
			      C ;--------------------------------------------------------------------+
			      C ; Name : PortReadTickCounter
			      C ;
			      C ; Description:
			      C ;       Reads the Timer tick count register which decrements by 2 from 65536
			      C ;       to 0 every 1/36.414 of a second.  Each 2 decrements of the count
			      C ;       represents 838 nsec's.
			      C ;
			      C ; Enter :
			      C ;
			      C ; Return : AX = current count.
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C         PUBLIC PortReadTickCounter
 1FAB			      C PortReadTickCounter     proc    near
			      C 
 1FAB  B0 06		      C         mov     al, 06h
 1FAD  E6 43		      C         out     43h, al                 ;Command 8254 to latch T0's count
			      C 
			      C         ;Now read the count.
			      C 
 1FAF  E4 40		      C         in      al, 40h                 ;Read LSB first
 1FB1  8A E0		      C         mov     ah, al
 1FB3  E4 40		      C         in      al, 40h                 ;Read MSB
 1FB5  86 C4		      C         xchg    al, ah                  ;Get in proper order
 1FB7  C3		      C         ret
			      C 
 1FB8			      C PortReadTickCounter     endp
			      C 
			      C EXTRN   rcv_mode_num : WORD
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Page 17 - 1


			      C         PAGE
			      C ;--------------------------------------------------------------------+
			      C ; Name : PortUpdateReceiveFilter
			      C ;
			      C ; Description: This function sends a setup frame to the DM9100 with
			      C ;              the current contents of the MulticastTable,
			      C ;              and the current station address.
			      C ;
			      C ;              The DM9100 gets reset as a result of calling this routine.
			      C ;              This routine assumes that the transmit and receive objects
			      C ;              are active when the routine is called. Upon exit,
			      C ;              the transmit and receive objects are left in an active,
			      C ;              but reinitialized state.
			      C ; Enter :
			      C ;
			      C ; Return : Carry set if an error occurred.
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C                          ALIGN  4
			      C                          PUBLIC PortUpdateReceiveFilter
 1FB8			      C PortUpdateReceiveFilter  PROC  NEAR
 1FB8  06		      C         push es
 1FB9  57		      C         push di
 1FBA  56		      C         push si
 1FBB  66| 50		      C         push eax
 1FBD  53		      C         push bx
 1FBE  51		      C         push cx
			      C 
 1FBF  FA		      C         cli
 1FC0  FC		      C         cld
			      C 
 1FC1  E8 006C		      C         call PortReset                  ; Reset Adapter
 1FC4  E8 EDCD		      C         call XmtEnable                  ; Reenable transmitter
			      C 
 1FC7  8C D8		      C         mov  ax, ds                     ; ES = DS
 1FC9  8E C0		      C         mov  es, ax
 1FCB  E8 EDEA		      C         call XmtGetSetupBuffer          ; Returns NEAR pointer to setup buffer
			      C                                         ; in AX.
 1FCE  8B F8		      C         mov  di, ax                     ; ES:DI points to setup buffer
 1FD0  8B D8		      C         mov  bx, ax                     ; Save NEAR pointer in BX
 1FD2  B9 00C0		      C         mov  cx, HW_K_SETUP_FRAME_SIZE  ;; (192)
 1FD5  C1 E9 02		      C         shr  cx, 2
 1FD8  66| B8 FFFFFFFF	      C         mov  eax, 0FFFFFFFFh
 1FDE  F3/ 66| AB	      C         rep  stosd                      ; Initialize setup buffer with FF's
			      C ;
			      C ; At this point, the setup buffer has been initialized with all FF's. This
			      C ; has the effect of filling the unused entries in the 16 address receive
			      C ; filter with the broadcast address. The DM9100 requires that a setup
			      C ; frame specify a valid address for all 16 entries. By setting the unused
			      C ; entries to broadcast, we don't have to worry about filling the unused
			      C ; entries with a copy of one of the valid entries, as recommended in the
			      C ; DM9100 spec.
			      C ;
			      C ; Now, place the current station address in the setup frame.
			      C ;
			      C                                         ; DS:SI points to the current address
 1FE1  BE 0000 E	      C         mov     si, OFFSET my_address
			      C 
 1FE4  8B FB		      C         mov  di, bx                     ; ES:DI points to start of setup buffer
 1FE6  66| 33 C0	      C         xor  eax, eax
 1FE9  AD		      C         lodsw                           ; Load word into AX
 1FEA  66| AB		      C         stosd                           ; Store dword EAX in setup buffer
 1FEC  AD		      C         lodsw                           ; Load word into AX
 1FED  66| AB		      C         stosd                           ; Store dword EAX in setup buffer
 1FEF  AD		      C         lodsw                           ; Load word into AX
 1FF0  66| AB		      C         stosd                           ; Store dword EAX in setup buffer
			      C 
			      C ; Now, determine the number of entries in the MulticastTable, and add
			      C ; those entries to the setup frame.
			      C 
 1FF2  8B 0E 248E R	      C         mov  cx, MulticastTable.table_current
 1FF6  BE 2490 R	      C         mov  si, OFFSET MulticastTable.table_multiaddr
			      C 
 1FF9			      C pesf_loop:
 1FF9  83 F9 00		      C         cmp  cx, 0
 1FFC  74 0F		      C         je   pesf_done
			      C 
 1FFE  AD		      C         lodsw                           ; Load word into AX
 1FFF  66| AB		      C         stosd                           ; Store dword EAX in setup buffer
 2001  AD		      C         lodsw                           ; Load word into AX
 2002  66| AB		      C         stosd                           ; Store dword EAX in setup buffer
 2004  AD		      C         lodsw                           ; Load word into AX
 2005  66| AB		      C         stosd                           ; Store dword EAX in setup buffer
			      C 
			      C ; 16 bytes storage for each address
 2007  83 C6 0A		      C         add  si, 10                     ; DS:SI points to next entry in
			      C                                         ; MulticastTable
 200A  49		      C         dec  cx
 200B  EB EC		      C         jmp  pesf_loop
			      C 
 200D			      C pesf_done:
 200D  E8 EDB8		      C         call XmtSendSetupFrame          ; Send the buffer
 2010  73 0B		      C         jnc     sendsetup_ok
 2012  BE 1908 R	      C         mov  si, OFFSET SetupFrame_fail_msg
 2015  B9 0031		      C         mov  cx, SetupFrame_fail_msg_len
 2018  E8 00E3		      C         call PortPrintMessage
			      C 
 201B  EB 0B		      C         jmp   pesf_exit                  ; If error, preserve the carry set
			      C 
 201D			      C sendsetup_ok:
 201D  83 3E 0000 E 01	      C         cmp     rcv_mode_num, 1
 2022  74 04		      C         je      pesf_exit
 2024  E8 F223		      C         call    RcvEnable
 2027  F8		      C         clc                             ; No error...clear carry
			      C 
 2028			      C pesf_exit:
			      C 
 2028  59		      C         pop cx
 2029  5B		      C         pop bx
 202A  66| 58		      C         pop eax
 202C  5E		      C         pop si
 202D  5F		      C         pop di
 202E  07		      C         pop es
 202F  C3		      C         ret
			      C 
 2030			      C PortUpdateReceiveFilter  ENDP
			      C 
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Page 18 - 1


			      C         PAGE
			      C ;--------------------------------------------------------------------+
			      C ; Name : PortReset
			      C ;
			      C ; Description: Set the receive mode on the interface associated with handle.
			      C ;               Can't use this function in the mutli-handle.
			      C ;
			      C ; Enter :
			      C ;
			      C ; Return :
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C            ALIGN  4
			      C            PUBLIC PortReset
 2030			      C PortReset  PROC  NEAR
 2030  66| 50		      C         push eax
 2032  52		      C         push dx
 2033  51		      C         push cx
 2034  53		      C         push bx
			      C 
			      C         DISABLE_ADAPTER_INTERRUPT  ; Disable adapter interrupts
 2035  66| 50		     1C         push   eax
 2037  52		     1C         push   dx
 2038  8B 16 246B R	     1C         mov    dx, p_CR7
 203C  66| B8 00000000	     1C         mov    eax, CR7_K_DEFAULT_OFF
 2042  66| EF		     1C         out    dx, eax
 2044  5A		     1C         pop    dx
 2045  66| 58		     1C         pop    eax
			      C 
 2047  66| B8 00000001	      C         mov  eax, CR0_M_SR       ; Assert software reset
 204D  8B 16 245D R	      C         mov  dx, p_CR0
 2051  66| EF		      C         out  dx, eax
			      C                                    ; Delay 50 PCI cycles here
			      C ;
			      C ;       Fix this hack by calling PortResetDelay...to be done
			      C ;
			      C 
			      C ;*************************************************************************
			      C ;*************************************************************************
			      C ;*** WARNING: This is a real HACK. I've put it here until I can figure ***
			      C ;*** out a more deterministic way of delaying 50 PCI cycles on an      ***
			      C ;*** arbitrary platform.                                               ***
			      C ;*************************************************************************
			      C ;*************************************************************************
 2053  B9 FFFF		      C         mov  cx, 0FFFFh
 2056			      C pr_loop:
			      C ;;        pusha
 2056  8B 16 245D R	      C         mov     dx, p_CR0
 205A  66| ED		      C         in      eax, dx
 205C  66| A9 00000001	      C         test    eax, 1
 2062  74 02		      C         jz      swreset_ok
			      C ;;        popa
 2064  E2 F0		      C         loop pr_loop
			      C 
			      C ;--- Raise the interrupt posted flag. Relevant for prevention of crash. ---
 2066			      C swreset_ok:
 2066  C7 06 18AE R 0001      C         mov     TulipIntPosted, 1
			      C 
 206C			      C pr_skip_configs:
 206C  66| A1 1874 R	      C         mov  eax, PortConfigCR0   ; Restore CR0
 2070  8B 16 245D R	      C         mov  dx, p_CR0
 2074  66| EF		      C         out  dx, eax
			      C 
 2076  8B 16 2467 R	      C         mov     dx, p_CR5              ;; Reset CR5
 207A  66| ED		      C         in      eax, dx
 207C  66| EF		      C         out     dx, eax
			      C 
			      C ;;++, 2000.2.21, hu-tiong
 207E  66| C7 06 1878 R	      C         mov     PortConfigCR6, CR6_DEFAULT
       02040000
 2087  E8 F989		      C         call    SetCR6
			      C ;;++
 208A  66| A1 1878 R	      C         mov  eax, PortConfigCR6   ; Restore CR6
 208E  8B 16 2469 R	      C         mov  dx, p_CR6
 2092  66| EF		      C         out  dx, eax
			      C 
			      C ;;;;--, 2000.6.27, rewrite PNA PHY setting
			      C ;;;;--
			      C 
			      C ;;++, 980623, Hu-Tiong, DM9102 E4 happens to tx extreme long packet sometimes
			      C ;;    Solutions:
			      C ;;      1. disable Jabber Clock -- make tx cut off after a range of 2048 bytes
			      C ;;         is transmitted.
			      C ;;      2. enable Host Unjab -- make tx channel is released immediately after
			      C ;;         jabber expiration.
 2094  8B 16 247B R	      C         mov     dx, p_CR15
			      C ;;;;-+, 2000.8.24, htho, support VLAN & Tx/Rx flow control
			      C ;;;;    in      eax, dx
			      C ;;;;    and     eax, 0FFFFFFF8h
			      C ;;;;    or      eax, 000000006h
 2098  66| A1 187C R	      C         mov     eax, PortConfigCR15
			      C ;;;;-+
 209C  66| EF		      C         out     dx, eax
			      C ;;-+
			      C 
			      C ;;;;--, 2000.8.24, htho, support DM9009(DM9102 without 100M PHY capability)
			      C ;;;;    cmp     ChipType, DM9009_CHIP
			      C ;;;;    je      Write_DM9009_CR12
			      C ;;;;--
			      C 
 209E  A1 18A0 R	      C         mov  ax, UM9100_GprCtrl    ; DM9100 chip - init CR12
 20A1  66| 25 0000FFFF	      C         and  eax, 0FFFFh
 20A7  8B 16 2475 R	      C         mov  dx, p_CR12
 20AB  66| EF		      C         out  dx, eax
			      C 
 20AD  A1 18A2 R	      C         mov  ax, UM9100_GprData10
 20B0  83 3E 1893 R 64	      C         cmp  InitPIDataRate, 100
 20B5  74 0C		      C         je   pr_fnet_100
 20B7  80 3E 1892 R 01	      C         cmp     SROMPortFlag, 1
 20BC  75 12		      C         jne  pr_CR12_data
 20BE  A1 18A6 R	      C         mov  ax, UM9100_GprDataFD10
 20C1  EB 0D		      C         jmp  pr_CR12_data
			      C 
 20C3			      C pr_fnet_100:
 20C3  A1 18A4 R	      C         mov  ax, UM9100_GprData100
 20C6  80 3E 1892 R 01	      C         cmp     SROMPortFlag, 1
 20CB  75 03		      C         jne  pr_CR12_data
 20CD  A1 18A8 R	      C         mov  ax, UM9100_GprDataFD100
			      C 
 20D0			      C pr_CR12_data:
 20D0  66| 25 0000FFFF	      C         and  eax, 0FFFFh
 20D6  8B 16 2475 R	      C         mov  dx, p_CR12
 20DA  66| EF		      C         out  dx, eax
			      C 
 20DC  EB 00		      C         jmp  pr_xmt_rcv_reset         ; skip on SIA initialization
			      C ;;;;--, 2000.8.24, htho, support DM9009(DM9102 without 100M PHY capability)
			      C ;;Write_DM9009_CR12:
			      C ;;        mov     eax, DM9009_CR12_image
			      C ;;        mov     dx, p_CR12
			      C ;;        out     dx, eax
			      C ;;;;--
			      C 
 20DE			      C pr_xmt_rcv_reset:
 20DE  E8 EC57		      C         call XmtReset
			      C 
 20E1  E8 F027		      C         call RcvReset
			      C 
 20E4  5B		      C         pop  bx
 20E5  59		      C         pop  cx
 20E6  5A		      C         pop  dx
 20E7  66| 58		      C         pop  eax
 20E9  C3		      C         ret
			      C 
 20EA			      C PortReset  ENDP
			      C 
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Page 19 - 1


			      C     PAGE
			      C ;--------------------------------------------------------------------+
			      C ; Name : PortResetDelay
			      C ;
			      C ; Description:
			      C ;       Spec. calls for 50 PCI cycles of delay between reset
			      C ;       and further accesses. Slowest PCI clock is 16Mhz. At 10Mhz PCI
			      C ;       clock (with safety margin) we have to wait 50cycles/10Mhz = 5000nsec.
			      C ;       PortReadTickCounter gives 419 nsec per count. We have to delay a delta
			      C ;       count of  5000ns/419ns = 11.93. We will round it up to 12.
			      C ;
			      C ;       Bottom line is that this routine returns after 5usec.
			      C ;
			      C ; Enter :
			      C ;
			      C ; Return :      AX = current count
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
 20EA			      C PortResetDelay  proc    near
			      C 
 20EA  53		      C         push    bx
 20EB  E8 FEBD		      C         call    PortReadTickCounter             ;Get initial value
 20EE  8B D8		      C         mov     bx, ax                  ;Save start value
			      C 
 20F0			      C Prd_loop:               ; Loop 12 times to get the proper delay
 20F0  E8 FEB8		      C         call    PortReadTickCounter
 20F3  F7 D8		      C         neg     ax
 20F5  03 C3		      C         add     ax, bx                  ;Get difference
 20F7  83 F8 0C		      C         cmp     ax, 12
 20FA  72 F4		      C         jb      SHORT Prd_loop
 20FC  5B		      C         pop     bx
 20FD  C3		      C         ret
 20FE			      C PortResetDelay  endp
			      C 
			      C ;--------------------------------------------------------------------+
			      C ; Name : PortPrintMessage
			      C ;
			      C ; Description:
			      C ; This function prints a message pointed to by DS:SI, that is CX bytes long.
			      C ; This function uses the BIOS video service at INT 10 to provide an OS
			      C ; independent method for displaying messages to the console during driver
			      C ; init.
			      C ;
			      C ; Enter :  DS:SI - Far pointer to message to print.
			      C ;             CX - Message length in bytes.
			      C ;
			      C ; Return :
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C                   PUBLIC PortPrintMessage
 20FE			      C PortPrintMessage  PROC NEAR
 20FE  56		      C         push si
 20FF  50		      C         push ax
 2100  53		      C         push bx
 2101  51		      C         push cx
 2102  9C		      C         pushf           ;    save flags
 2103  83 F9 00		      C         cmp     cx, 0
 2106  74 0B		      C         je      pm_exit
 2108  FC		      C         cld             ;    clear direction flag
 2109  BB 000F		      C         mov  bx,0Fh     ;    Set video attributes for INT 10 call
 210C			      C pm_loop:                ;    do {
 210C  AC		      C         lodsb           ;      get char at DS:(SI++)
 210D  B4 0E		      C         mov  ah,0EH
 210F  CD 10		      C         int  10H        ;      call BIOS INT 10 to print to console
 2111  E2 F9		      C         loop pm_loop    ;      CX--
			      C                         ;    while (CX != 0)
 2113			      C pm_exit:
 2113  9D		      C         popf            ;    restore flags
 2114  59		      C         pop cx
 2115  5B		      C         pop bx
 2116  58		      C         pop ax
 2117  5E		      C         pop si
 2118  C3		      C         ret
			      C 
 2119			      C PortPrintMessage  ENDP
			      C 
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Page 20 - 1


			      C         PAGE
			      C ;--------------------------------------------------------------------+
			      C ; Name : PortCR6Write
			      C ;
			      C ; Description:
			      C ; This function handles writes to CR6. The value in EAX is written to
			      C ; CR6.
			      C ;
			      C ; Enter :  EAX = Writed data
			      C ;
			      C ; Return :
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C                ALIGN  4
			      C                PUBLIC PortCR6Write
 211C			      C PortCR6Write  PROC  NEAR
 211C  66| 50		      C         push eax
 211E  66| 53		      C         push ebx
 2120  66| 51		      C         push ecx
 2122  52		      C         push dx
 2123  9C		      C         pushf
 2124  FA		      C         cli
			      C 
			      C 
 2125			      C pCR6_write_CR6:
 2125  8B 16 2469 R	      C         mov  dx, p_CR6
 2129  66| EF		      C         out  dx, eax            ; Write CR6 with desired value
			      C 
 212B			      C pCR6_exit:
 212B  9D		      C         popf
 212C  5A		      C         pop dx
 212D  66| 59		      C         pop ecx
 212F  66| 5B		      C         pop ebx
 2131  66| 58		      C         pop eax
 2133  C3		      C         ret
 2134			      C PortCR6Write  ENDP
			      C 
			      C ;;;;--, 2000.8.24, htho, support DM9009(DM9102 without 100M PHY capability)
			      C if 0
			      C endif
			      C ;;;;--
			      C 
			      C ;;++, 2000.2.21
			      C         PUBLIC Port_Hardware_Reset_PHY
 2134			      C Port_Hardware_Reset_PHY PROC
			      C ;
			      C ; Reset PHY through CR12 General Purpose pin
			      C ;
 2134  8B 16 2475 R	      C         mov     dx, p_CR12
 2138  66| B8 00000180	      C         mov     eax, 00000180h
 213E  66| EF		      C         out     dx, eax
			      C 
 2140  66| B8 00000080	      C         mov     eax, 00000080h
 2146  66| EF		      C         out     dx, eax
			      C 
 2148  66| B8 00000000	      C         mov     eax, 0
 214E  66| EF		      C         out     dx, eax
			      C 
 2150  C3		      C         ret
 2151			      C Port_Hardware_Reset_PHY ENDP
			      C ;;++, 2000.2.21
			      C 
			      C ;;;;++, 2000.6.27, rewrite PNA PHY setting
			      C         PUBLIC Reset_MAC_PHY
 2151			      C Reset_MAC_PHY PROC
 2151  8B 16 245D R	      C         mov     dx, p_CR0               ; reset MAC
 2155  66| B8 00000001	      C         mov     eax, 1
 215B  66| EF		      C         out     dx, eax
			      C 
 215D  E8 F56A		      C         call    SROMDelay
			      C 
			      C ifdef HOMEPNA
 2160  80 3E 1896 R 02	      C         cmp     PHYTYPE, PNAPHY
 2165  75 1A		      C         jne     @F
			      C 
 2167  8B 16 2469 R	      C         mov     dx, p_CR6
 216B  66| ED		      C         in      eax, dx
 216D  66| 0D 00040000	      C         or      eax, CR6_M_MSPS
 2173  66| EF		      C         out     dx, eax
			      C 
 2175  BA 8000		      C         mov     dx, BMCR_M_RST
 2178  8A 3E 1895 R	      C         mov     bh, PHY_Number
 217C  B3 00		      C         mov     bl, PHY_BMCR
 217E  E8 0000 E	      C         call    Write_Register_PHY
			      C 
 2181			      C @@:
			      C endif
 2181  C3		      C         ret
 2182			      C Reset_MAC_PHY ENDP
			      C 
			      C ifdef HOMEPNA
			      C         PUBLIC PNA_Set_CR16
 2182			      C PNA_Set_CR16 PROC
 2182  E8 0016		      C         call    Write_PNA_CR16
			      C 
 2185  9C		      C         pushf
 2186  FA		      C         cli
 2187  80 3E 186B R 01	      C         cmp     send_remote_cmd, 1
 218C  75 0B		      C         jne     @F
			      C 
 218E  C6 06 1870 R 03	      C         mov     resend_remote_cmd_cnt, 3
 2193  C7 06 1871 R 0000      C         mov     resend_remote_cmd_timer, 0
 2199			      C @@:
 2199  9D		      C         popf
			      C 
 219A  C3		      C         ret
 219B			      C PNA_Set_CR16 ENDP
			      C 
 219B			      C Write_PNA_CR16 PROC
 219B  8B 16 1867 R	      C         mov     dx, pna_cr16
 219F  81 E2 F0FF	      C         and     dx, NOT 0F00h
			      C 
 21A3  80 3E 186B R 00	      C         cmp     send_remote_cmd, 0
 21A8  74 08		      C         je      @F
 21AA  0B 16 186C R	      C         or      dx, pna_power_cmd
 21AE  0B 16 186E R	      C         or      dx, pna_speed_cmd
 21B2			      C @@:
			      C 
 21B2  8A 3E 1895 R	      C         mov     bh, PHY_Number
 21B6  B3 10		      C         mov     bl, 16
 21B8  E8 0000 E	      C         call    Write_Register_PHY
			      C 
 21BB  C3		      C         ret
 21BC			      C Write_PNA_CR16 ENDP
			      C 
 21BC			      C Setup_HOMERUN_PHY PROC
			      C         ;
			      C         ; disable %25 increase of noise slice for HOMERUN
			      C         ;
			      C ;;;;++, 2000.9.19, htho, support DM9801 E4
 21BC  80 3E 1883 R 00	      C         cmp     pnaphy_rev, 0
 21C1  75 08		      C         jne     @F
			      C ;;;;++
 21C3  81 0E 1867 R 1000      C         or      pna_cr16, 1000h
			      C ;;;;++, 2000.9.19, htho, support DM9801 E4
 21C9  EB 06		      C         jmp     gosetcr16
 21CB			      C @@:
 21CB  81 26 1867 R EFFF      C         and     pna_cr16, NOT 1000h
 21D1			      C gosetcr16:
			      C ;;;;++
			      C         ;
			      C         ; PNA PHY may need to resend remote command this time
			      C         ;
 21D1  E8 FFAE		      C         call    PNA_Set_CR16
			      C 
			      C ;;-+, 2001.5.25, different 9801 R24/R25 operation between E3 and E4/5...
			      C ;       mov     bh, PHY_Number
			      C ;       mov     bl, 24
			      C ;       call    Read_Register_PHY
			      C ;
			      C ;       mov     dl, al
			      C ;       add     dl, 3
			      C ;       mov     dh, 0F0h
			      C ;       mov     bh, PHY_Number
			      C ;       mov     bl, 25
			      C ;       call    Write_Register_PHY
 21D4  80 3E 1883 R 00	      C         cmp     pnaphy_rev, 0
 21D9  75 1E		      C         jne     @F              ; it's 9801 E4/E5...
			      C 
			      C         ; it's 9801 E3
			      C 
 21DB  8A 3E 1895 R	      C         mov     bh, PHY_Number
 21DF  B3 18		      C         mov     bl, 24
 21E1  E8 0000 E	      C         call    Read_Register_PHY
 21E4  A3 1869 R	      C         mov     p_PHY24,ax
 21E7  8A D0		      C         mov     dl, al
			      C ;**********************************************************
			      C ;add by simon 2001.8.27
			      C ;strore phy reg24's value into p_PHY24
			      C ;
			      C ;**********************************************************
			      C 
			      C        ;; add     dl, 0Dh  mark by simon, just add 8
 21E9  80 C2 08		      C         add     dl, 8
 21EC  B6 F0		      C         mov     dh, 0F0h
 21EE  8A 3E 1895 R	      C         mov     bh, PHY_Number
 21F2  B3 19		      C         mov     bl, 25
 21F4  E8 0000 E	      C         call    Write_Register_PHY
			      C 
 21F7  EB 36		      C         jmp     hr_set_speed
 21F9			      C @@:
			      C         ; it's 9801 E4/E5...
			      C 
 21F9  8A 3E 1895 R	      C         mov     bh, PHY_Number
 21FD  B3 11		      C         mov     bl, 17
 21FF  E8 0000 E	      C         call    Read_Register_PHY
 2202  83 C8 08		      C         or      ax, 08h
			      C 
 2205  8B D0		      C         mov     dx, ax
 2207  8A 3E 1895 R	      C         mov     bh, PHY_Number
 220B  B3 11		      C         mov     bl, 17
 220D  E8 0000 E	      C         call    Write_Register_PHY
			      C 
 2210  8A 3E 1895 R	      C         mov     bh, PHY_Number
 2214  B3 19		      C         mov     bl, 25
 2216  E8 0000 E	      C         call    Read_Register_PHY
			      C 
 2219  50		      C         push    ax
			      C 
 221A  8A 3E 1895 R	      C         mov     bh, PHY_Number
 221E  B3 18		      C         mov     bl, 24
 2220  E8 0000 E	      C         call    Read_Register_PHY
			      C 
 2223  5A		      C         pop     dx
 2224  8A D0		      C         mov     dl, al
 2226  8A 3E 1895 R	      C         mov     bh, PHY_Number
 222A  B3 19		      C         mov     bl, 25
 222C  E8 0000 E	      C         call    Write_Register_PHY
			      C 
 222F			      C hr_set_speed:
			      C ;;-+
			      C 
			      C ;;++, 2001.3.30, htho, support HPNA speed setting
			      C ;;-+, 2001.6.12, htho, default lspeed=1000 instead of 700
 222F  81 3E 1885 R 03E8      C         cmp     LSpeedNum, 1000
			      C ;;-+
 2235  75 14		      C         jne     Set_HOMERUN_LSpeed_500
			      C 
 2237  C7 06 1887 R 4014      C         mov     pna_cr29, 4014h
 223D  C7 06 1889 R 1C2C      C         mov     pna_cr30, 1C2Ch
 2243  C7 06 188B R 4404      C         mov     pna_cr31, 4404h
 2249  EB 4A		      C         jmp     Set_HOMERUN_LSpeed
			      C 
 224B			      C Set_HOMERUN_LSpeed_500:
 224B  81 3E 1885 R 01F4      C         cmp     LSpeedNum, 500
 2251  75 14		      C         jne     Set_HOMERUN_LSpeed_1400
			      C 
 2253  C7 06 1887 R 4014      C         mov     pna_cr29, 4014h
			      C ;;-+, 2001.6.12, htho, error CR31 value while lseedp=500 for homerun
			      C ;;      mov     pna_cr30, 1C2Ch
 2259  C7 06 1889 R 1C3F      C         mov     pna_cr30, 1C3Fh
			      C ;;-+
 225F  C7 06 188B R 4404      C         mov     pna_cr31, 4404h
 2265  EB 2E		      C         jmp     Set_HOMERUN_LSpeed
			      C 
 2267			      C Set_HOMERUN_LSpeed_1400:
 2267  81 3E 1885 R 0578      C         cmp     LSpeedNum, 1400
 226D  75 14		      C         jne     Set_HOMERUN_LSpeed_1600
			      C 
 226F  C7 06 1887 R 200C      C         mov     pna_cr29, 200Ch
 2275  C7 06 1889 R 141C      C         mov     pna_cr30, 141Ch
 227B  C7 06 188B R 4404      C         mov     pna_cr31, 4404h
 2281  EB 12		      C         jmp     Set_HOMERUN_LSpeed
			      C 
 2283			      C Set_HOMERUN_LSpeed_1600:
 2283  C7 06 1887 R 200C      C         mov     pna_cr29, 200Ch
 2289  C7 06 1889 R 121C      C         mov     pna_cr30, 121Ch
 228F  C7 06 188B R 4404      C         mov     pna_cr31, 4404h
			      C 
 2295			      C Set_HOMERUN_LSpeed:
 2295  8B 16 1887 R	      C         mov     dx, pna_cr29
 2299  8A 3E 1895 R	      C         mov     bh, PHY_Number
 229D  B3 1D		      C         mov     bl, 29
 229F  E8 0000 E	      C         call    Write_Register_PHY
			      C 
 22A2  8B 16 1889 R	      C         mov     dx, pna_cr30
 22A6  8A 3E 1895 R	      C         mov     bh, PHY_Number
 22AA  B3 1E		      C         mov     bl, 30
 22AC  E8 0000 E	      C         call    Write_Register_PHY
			      C 
 22AF  8B 16 188B R	      C         mov     dx, pna_cr31
 22B3  8A 3E 1895 R	      C         mov     bh, PHY_Number
 22B7  B3 1F		      C         mov     bl, 31
 22B9  E8 0000 E	      C         call    Write_Register_PHY
			      C ;;++
 22BC  C3		      C         ret
 22BD			      C Setup_HOMERUN_PHY ENDP
			      C 
 22BD			      C Setup_LONGRUN_PHY PROC
			      C         ;
			      C         ; enable %25 increase of noise slice for LONGRUN
			      C         ;
 22BD  81 26 1867 R EFFF      C         and     pna_cr16, NOT 1000h
			      C 
			      C         ;
			      C         ; PNA PHY may need to resend remote command this time
			      C         ;
 22C3  E8 FEBC		      C         call    PNA_Set_CR16
			      C 
 22C6  8A 3E 1895 R	      C         mov     bh, PHY_Number          ; set low byte of Reg. 25 to 02h
 22CA  B3 19		      C         mov     bl, 25
 22CC  E8 0000 E	      C         call    Read_Register_PHY
 22CF  8B D0		      C         mov     dx, ax
			      C 
 22D1  81 E2 FF00	      C         and     dx, 0FF00h
 22D5  83 CA 02		      C         or      dx, 02h
 22D8  8A 3E 1895 R	      C         mov     bh, PHY_Number
 22DC  B3 19		      C         mov     bl, 25
 22DE  E8 0000 E	      C         call    Write_Register_PHY
			      C 
			      C ;;++, 2001.3.30, htho, support HPNA speed setting
			      C ;;-+, 2001.6.12, htho, default lspeed=1000 instead of 700
 22E1  81 3E 1885 R 03E8      C         cmp     LSpeedNum, 1000
			      C ;;-+
 22E7  75 14		      C         jne     Set_LONGRUN_LSpeed_500
			      C 
 22E9  C7 06 1887 R 5450      C         mov     pna_cr29, 5450h
 22EF  C7 06 1889 R 1C2C      C         mov     pna_cr30, 1C2Ch
 22F5  C7 06 188B R 110F      C         mov     pna_cr31, 110Fh
 22FB  EB 4A		      C         jmp     Set_LONGRUN_LSpeed
			      C 
 22FD			      C Set_LONGRUN_LSpeed_500:
 22FD  81 3E 1885 R 01F4      C         cmp     LSpeedNum, 500
 2303  75 14		      C         jne     Set_LONGRUN_LSpeed_1400
			      C 
 2305  C7 06 1887 R 5450      C         mov     pna_cr29, 5450h
 230B  C7 06 1889 R 1C3F      C         mov     pna_cr30, 1C3Fh
 2311  C7 06 188B R 110F      C         mov     pna_cr31, 110Fh
 2317  EB 2E		      C         jmp     Set_LONGRUN_LSpeed
			      C 
 2319			      C Set_LONGRUN_LSpeed_1400:
 2319  81 3E 1885 R 0578      C         cmp     LSpeedNum, 1400
 231F  75 14		      C         jne     Set_LONGRUN_LSpeed_1600
			      C 
 2321  C7 06 1887 R 3010      C         mov     pna_cr29, 3010h
 2327  C7 06 1889 R 141C      C         mov     pna_cr30, 141Ch
 232D  C7 06 188B R 110B      C         mov     pna_cr31, 110Bh
 2333  EB 12		      C         jmp     Set_LONGRUN_LSpeed
			      C 
 2335			      C Set_LONGRUN_LSpeed_1600:
 2335  C7 06 1887 R 3010      C         mov     pna_cr29, 3010h
 233B  C7 06 1889 R 121C      C         mov     pna_cr30, 121Ch
 2341  C7 06 188B R 110B      C         mov     pna_cr31, 110Bh
			      C 
 2347			      C Set_LONGRUN_LSpeed:
 2347  8B 16 1887 R	      C         mov     dx, pna_cr29
 234B  8A 3E 1895 R	      C         mov     bh, PHY_Number
 234F  B3 1D		      C         mov     bl, 29
 2351  E8 0000 E	      C         call    Write_Register_PHY
			      C 
 2354  8B 16 1889 R	      C         mov     dx, pna_cr30
 2358  8A 3E 1895 R	      C         mov     bh, PHY_Number
 235C  B3 1E		      C         mov     bl, 30
 235E  E8 0000 E	      C         call    Write_Register_PHY
			      C 
 2361  8B 16 188B R	      C         mov     dx, pna_cr31
 2365  8A 3E 1895 R	      C         mov     bh, PHY_Number
 2369  B3 1F		      C         mov     bl, 31
 236B  E8 0000 E	      C         call    Write_Register_PHY
			      C ;;++
 236E  C3		      C         ret
 236F			      C Setup_LONGRUN_PHY ENDP
			      C endif
			      C 
			      C ;
			      C ; On Entry:
			      C ;
			      C ;       DS:SI --> local SROM data buffer
			      C ;
 236F			      C check_switching_adapter PROC
 236F  80 7C 12 14	      C         cmp     [si].NS_SROM_version, 14h       ; SROM v4.01
 2373  74 02		      C         je      srom_v401_chk_sw
 2375  EB 0E		      C         jmp     srom_v300_chk_sw
 2377			      C srom_v401_chk_sw:
 2377  83 7C 20 02	      C         cmp     [si+32], 2                      ; hlaf switching adapter
 237B  74 1D		      C         je      half_sw_adapt
 237D  83 7C 20 03	      C         cmp     [si+32], 3
 2381  74 29		      C         je      full_sw_adapt
 2383  EB 39		      C         jmp     not_sw_adapt
			      C 
 2385			      C srom_v300_chk_sw:
			      C         ;
			      C         ; while SROM version is v3.00,
			      C         ;    half switch : Sub Vendor ID = 0391h, Sub Device ID = 8212h
			      C         ;    full switch : Sub Vendor ID = 0491h, Sub Device ID = 8212h
			      C         ;
 2385  81 7C 02 8212	      C         cmp     [si].NS_SS_ID, 8212h
 238A  75 32		      C         jne     not_sw_adapt
 238C  81 3C 0391	      C         cmp     [si].NS_SS_Vendor_ID, 0391h
 2390  74 08		      C         je      half_sw_adapt
 2392  81 3C 0491	      C         cmp     [si].NS_SS_Vendor_ID, 0491h
 2396  74 14		      C         je      full_sw_adapt
 2398  EB 24		      C         jmp     not_sw_adapt
			      C 
 239A			      C half_sw_adapt:
 239A  C6 06 1873 R 01	      C         mov     switch_adapter, 1       ; half switching adapter
			      C 
 239F  C7 06 1893 R 0064      C         mov     InitPIDataRate, 100
 23A5  C6 06 1892 R 00	      C         mov     SROMPortFlag, 0
			      C 
 23AA  EB 17		      C         jmp     chk_sw_exit
			      C 
 23AC			      C full_sw_adapt:
 23AC  C6 06 1873 R 02	      C         mov     switch_adapter, 2       ; full switching adapter
			      C 
 23B1  C7 06 1893 R 0064      C         mov     InitPIDataRate, 100
 23B7  C6 06 1892 R 01	      C         mov     SROMPortFlag, 1
 23BC  EB 05		      C         jmp     chk_sw_exit
			      C 
 23BE			      C not_sw_adapt:
 23BE  C6 06 1873 R 00	      C         mov     switch_adapter, 0       ; not switching adapter
			      C 
 23C3			      C chk_sw_exit:
 23C3  C3		      C         ret
 23C4			      C check_switching_adapter ENDP
			      C ;;;;++
			      C ;;;;++, 2000.8.24, htho, support DM9009(DM9102 without 100M PHY capability)
 23C4			      C check_dm9009 PROC
 23C4  80 3E 2454 R 01	      C         cmp     ChipType, DM9009_CHIP
 23C9  74 13		      C         je      its_dm9009
 23CB  80 7C 12 14	      C         cmp     [si].NS_SROM_version, 14h       ; SROM v4.01
 23CF  75 27		      C         jne     chk_dm9009_exit
 23D1  81 7C 0A 1282	      C         cmp     [si+10], 90091282h
 23D6  75 20		      C         jne     chk_dm9009_exit
 23D8  81 3C 0990	      C         cmp     [si], 82120990h
 23DC  75 1A		      C         jne     chk_dm9009_exit
 23DE			      C its_dm9009:
			      C         extrn   dm9009_chip_msg: byte
			      C         extrn   printmsg: near
 23DE  BA 0000 E	      C         mov     dx, OFFSET dm9009_chip_msg
 23E1  E8 0000 E	      C         call    printmsg
			      C 
 23E4  F7 06 0000 E 0180      C         test    flagword, XF_OPTION OR XH_OPTION
 23EA  74 06		      C         jz      @F
			      C         extrn   dm9009_warning_msg: byte
 23EC  BA 0000 E	      C         mov     dx, OFFSET dm9009_warning_msg
 23EF  E8 0000 E	      C         call    printmsg
 23F2			      C @@:
 23F2  C7 06 188D R 0461      C         mov     anar, (ANAR_FCS+ANAR_10_FDX+ANAR_10_HDX+ANAR_CSMACD)
 23F8			      C chk_dm9009_exit:
 23F8  C3		      C         ret
 23F9			      C check_dm9009 ENDP
			      C ;;;;++
			      C ;;;;++, 2000.8.24, htho, support VLAN & Tx/Rx flow control
 23F9			      C config_cr15 proc
 23F9  80 3E 1880 R 01	      C         cmp     vlan, 1
 23FE  74 06		      C         je      vlan_enable
 2400  F6 44 2B 80	      C         test    byte ptr [si+43], 80h
 2404  74 06		      C         jz      cfg_rx_flow_control
 2406			      C vlan_enable:
 2406  66| 83 0E 187C R	      C         or      PortConfigCR15, 00000040h
       40
			      C 
 240C			      C cfg_rx_flow_control:
 240C  80 3E 1881 R 01	      C         cmp     fcrx, 1
 2411  74 06		      C         je      rx_flow_control_enable
 2413  F6 44 28 01	      C         test    byte ptr [si+40], 01h
 2417  74 09		      C         jz      cfg_tx_flow_control
 2419			      C rx_flow_control_enable:
 2419  66| 81 0E 187C R	      C         or      PortConfigCR15, 00000400h
       00000400
			      C 
 2422			      C cfg_tx_flow_control:
 2422  80 3E 1882 R 01	      C         cmp     fctx, 1
 2427  74 06		      C         je      tx_flow_control_enable
 2429  F6 44 28 0E	      C         test    byte ptr [si+40], 0Eh
 242D  74 09		      C         jz      cfg_cr15_exit
 242F			      C tx_flow_control_enable:
 242F  66| 81 0E 187C R	      C         or      PortConfigCR15, 00009800h
       00009800
			      C 
 2438			      C cfg_cr15_exit:
 2438  C3		      C         ret
 2439			      C config_cr15 endp
			      C ;;;;++
			      C ;;;;++, 2000.10.4, simulate line plug out/in by power off/on phy for DM9102A E3
			      C         EXTRN   InitConfigRegRead: near ; invalid in runtime time
 2439			      C check_dm9102a_e3 proc
 2439  C6 06 1884 R 00	      C         mov     dm9102a_e3, 0
 243E  BA 0050		      C         mov     dx, 50h                 ; PCIPMR Power Management Register
 2441  E8 0000 E	      C         call    InitConfigRegRead
 2444  66| C1 E8 10	      C         shr     eax, 16                 ; PCIPMR[18..16] = 001 -- E3
 2448  24 07		      C         and     al, 07h                 ; PCIPMR[18..16] = 010 -- E5
 244A  3C 01		      C         cmp     al, 01h
 244C  75 05		      C         jne     @F
 244E  C6 06 1884 R 01	      C         mov     dm9102a_e3, 1
 2453			      C @@:
 2453  C3		      C         ret
 2454			      C check_dm9102a_e3 endp
			      C ;;;;++
			      C 
			      C include rtdata.asm
			      C 
			      C         PUBLIC  ChipType
 2454 00		      C ChipType        DB      0       ;; 0 - DM9100, 1 - DM9009
			      C 
			      C ;
			      C ; These three variables are initialized in the MACINIT.ASM module, and
			      C ; define the physically mapped block of memory that is locked down at
			      C ; init time for the transmit and receive DMA buffers. 
			      C ;
			      C                 PUBLIC p_PhysBlockVirt, p_PhysBlockPhys, PhysBlockSize
 2455 0000		      C p_PhysBlockVirt DW  0
 2457 00000000		      C p_PhysBlockPhys DD  0
 245B 0000		      C PhysBlockSize   DW  0
			      C 
			      C ;
			      C ; The following variables are physical I/O address pointers to the Tulip
			      C ; and PLX control registers. These are initialized in the InitTulipRegOffsets
			      C ; function in the module macinit.asm during driver init time. As a general
			      C ; convention in this driver, any variable prefixed with a p_ is a pointer
			      C ; variable. 
			      C ;
			      C 
			      C         PUBLIC p_CR0, p_CR1, p_CR2, p_CR3, p_CR4, p_CR5, p_CR6, p_CR7
			      C         PUBLIC p_CR8, p_CR9, p_CR10, p_CR11, p_CR12, p_CR13, p_CR14
			      C         PUBLIC p_CR15, p_PCIID, p_PCICS, p_PCIRV, p_PCILT, p_PCIIO
			      C 
 245D 0000		      C p_CR0        DW ?
 245F 0000		      C p_CR1        DW ?
 2461 0000		      C p_CR2        DW ?
 2463 0000		      C p_CR3        DW ?
 2465 0000		      C p_CR4        DW ?
 2467 0000		      C p_CR5        DW ?
 2469 0000		      C p_CR6        DW ?
 246B 0000		      C p_CR7        DW ?
 246D 0000		      C p_CR8        DW ?
 246F 0000		      C p_CR9        DW ?
 2471 0000		      C p_CR10       DW ?
 2473 0000		      C p_CR11       DW ?
 2475 0000		      C p_CR12       DW ?
 2477 0000		      C p_CR13       DW ?
 2479 0000		      C p_CR14       DW ?
 247B 0000		      C p_CR15       DW ?
			      C 
 247D 0000		      C p_PCIID        DW ?
 247F 0000		      C p_PCICS        DW ?
 2481 0000		      C p_PCIRV        DW ?
 2483 0000		      C p_PCILT        DW ?
 2485 0000		      C p_PCIIO        DW ?
			      C 
			      C                 PUBLIC PICIntOff, PICIntOn, PICIntMask, PICAckSlave
 2487 00		      C PICIntOff       DB ?    ; Masks for enabling and disabling interrupts at
 2488 00		      C PICIntOn        DB ?    ; the PIC Chip
 2489 0000		      C PICIntMask      DW ?    ; I/O Address of the PICIntMask
 248B 00		      C PICAckSlave     DB ?    ; Flag to ACK Slave interrupt for IRQ 9,10,11
			      C 
			      C ; DM9100 allowes 16 addresses in its setup packet. We save  two  addresses:
			      C ; One for the satation address, the second for broadcast address. Therefore
			      C ; the multicast table can hold only 14 addresses.
			      C ;--------------------------------------------------------------------------
			      C                 PUBLIC  MulticastTable
 248C			      C MulticastTable  LABEL  BYTE
 248C  000E		      C                 DW      14              ; Max number of multicast addresses
 248E  0000		      C                 DW      0               ; Current number of addresses
 2490  00E0 [		      C                 DB      14*16 DUP (0)   ; Storage for 14 BYTE[16] addresses
        00
       ]
			      C 
			      C 
			      C include isr.asm
			      C ;*****************************************************************************
			      C ;* Name : ISR.ASM
			      C ;*
			      C ;* All rights reserved by DAVICOM, 1996
			      C ;*
			      C ;* Description :
			      C ;*
			      C ;* Functions :
			      C ;*	. InterruptMain
			      C ;*
			      C ;* Author :
			      C ;*
			      C ;* Date :
			      C ;*
			      C ;* Change Notes :
			      C ;* Date - Modifier
			      C ;*     Cause :
			      C ;*  Modified :
			      C ;*    Result :
			      C ;
			      C ; Maintainers:
			      C ;
			      C ; John H.T. Ho		htho
			      C ;
			      C ;
			      C ; Revision History:
			      C ;
			      C ; Date	     Modfier.	Modification Descriptions
			      C ; ---------- ---------- ------------------------------------------
			      C ; 2000.4.6	htho	port rese while rx hang
			      C ;
			      C ;*
			      C ;*****************************************************************************
			      C 
			      C .386
			      C 
			      C EXTRN	their_isr : DWORD
			      C EXTRN	our_stack : BYTE
			      C 
			      C 		PUBLIC InterruptSemaphore
 2570 00		      C InterruptSemaphore  DB 0
			      C 
 2571 00000000		      C CR5_image	   DD ?
			      C 
			      C 		PUBLIC save_int_ss, save_int_sp
 2575 0000		      C save_int_ss	DW ?
 2577 0000		      C save_int_sp	DW ?
			      C 
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Page 21 - 1


			      C 		PAGE
			      C 
			      C ;--------------------------------------------------------------------+
			      C ; Name : InterruptMain
			      C ;
			      C ; Description: This is the device ISR.
			      C ;	       This ISR handles receive interrupts from the adapter.
			      C ;
			      C ; Enter :
			      C ; Return :
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C 		PUBLIC	InterruptMain
 2579			      C InterruptMain	PROC	FAR
			      C 
			      C 	ENTER_ISR			; Do OS specific entry stuff
 2579  66| 60		     1C         pushad                          
 257B  1E		     1C         push    ds                      
 257C  06		     1C         push    es                      
 257D  8C C8		     1C         mov     ax, cs                  
 257F  8E D8		     1C         mov     ds, ax
			      C 
 2581  FA		      C 	cli				; Momentarily block system interrupts
 2582  FC		      C 	cld				; Set the direction flag forward
			      C 
 2583  B0 01		      C 	mov  al, 1			; Set the semaphore
 2585  86 06 2570 R	      C 	xchg InterruptSemaphore, al
 2589  3C 00		      C 	cmp  al, 0			; Check previous value of sempahore
 258B  74 09		      C 	je   im_clear			; if it was already set, chain
			      C 
			      C ;------------------- Support interrupt sharing
			      C 
 258D			      C im_chain:
			      C 
			      C 	POP_REGISTERS			   ; clean up caller's stack
 258D  07		     1C         pop  es                 
 258E  1F		     1C         pop  ds                 
 258F  66| 61		     1C         popad                   
 2591  2E: FF 2E 0000 E	      C 	jmp	DWORD PTR cs:their_isr
			      C 
 2596			      C im_clear:
			      C 	DISABLE_ADAPTER_INTERRUPT	; Block adapter ints (use caller's stack)
 2596  66| 50		     1C         push   eax
 2598  52		     1C         push   dx
 2599  8B 16 246B R	     1C         mov    dx, p_CR7
 259D  66| B8 00000000	     1C         mov    eax, CR7_K_DEFAULT_OFF
 25A3  66| EF		     1C         out    dx, eax
 25A5  5A		     1C         pop    dx
 25A6  66| 58		     1C         pop    eax
			      C 
			      C 
			      C ;     Is this interrupt for us?
			      C 
			      C 	;Get the interrupt status bits (CR5)
			      C 	;------------------------------------
 25A8  8B 16 2467 R	      C 	mov	dx,  p_CR5
 25AC  66| ED		      C 	in	eax, dx
 25AE  66| A3 2571 R	      C 	mov	CR5_image, eax
			      C 
			      C 	;Test if this interrupt is from Tulip
			      C 	;------------------------------------
 25B2  66| A9 00018041	      C 	test	eax, CR7_K_DEFAULT_ON	       ;; NI | AI | RI
 25B8  75 57		      C 	jnz	im_our_int			  ; it's our interrupt
			      C 
			      C 	;Not our interrupt; restore adapter interrupt, semaphore, and chain
			      C 	;------------------------------------------------------------------
 25BA  83 3E 18AE R 01	      C 	cmp	TulipIntPosted, 1 ;Was an interrupt posted from prev. reset?
 25BF  74 19		      C 	je	im_posted_int
			      C 	ENABLE_ADAPTER_INTERRUPT
 25C1  66| 50		     1C         push   eax
 25C3  52		     1C         push   dx
 25C4  8B 16 246B R	     1C         mov    dx, p_CR7
 25C8  66| B8 00018041	     1C         mov    eax, CR7_K_DEFAULT_ON
 25CE  66| EF		     1C         out    dx, eax
 25D0  5A		     1C         pop    dx
 25D1  66| 58		     1C         pop    eax
 25D3  C6 06 2570 R 00	      C 	mov	InterruptSemaphore, 0
 25D8  EB B3		      C 	jmp	im_chain
			      C 
 25DA			      C im_posted_int:
			      C ;;-- Reset post interrupt before initialized.
			      C 	;Previous possible interrupt posted before Chip reset
			      C 	;----------------------------------------------------
 25DA  66| 83 E0 FB	      C 	and	eax, 0FFFFFFFBh
 25DE  66| EF		      C 	out	dx, eax 	     ;; If set, reset EB, TS, RS, NIS
			      C 
 25E0  C7 06 18AE R 0000      C 	mov	TulipIntPosted, 0
			      C 
			      C 	SAVE_DOS_STACK
 25E6  2E: 8C 16 2575 R	     1C         mov     cs:[save_int_ss], ss            
 25EB  2E: 89 26 2577 R	     1C         mov     cs:[save_int_sp], sp            
 25F0  8C C8		     1C         mov     ax, cs                          
 25F2  8E D0		     1C         mov     ss, ax
 25F4  BC 0000 E	     1C         mov     sp, OFFSET our_stack              
			      C 	ACK_PIC_INTERRUPT	;; Issue EOI, Could accept next interrupt
 25F7  B0 20		     1C         mov     al, 20h                 
 25F9  2E: F6 06 248B R	     1C         test    CS:PICAckSlave,0FFh
       FF
 25FF  74 02		     1C         jz      ??0000
 2601  E6 A0		     1C         out     0A0h, al                
 2603			     1C ??0000:
 2603  E6 20		     1C         out     020h, al                
			      C 	RESTORE_DOS_STACK
 2605  2E: 8E 16 2575 R	     1C         mov  ss, cs:[save_int_ss]               
 260A  2E: 8B 26 2577 R	     1C         mov  sp, cs:[save_int_sp]
 260F  EB 78		      C 	jmp	im_exit_after
			      C 
			      C 	;Clear active interrupts
			      C 	;---------------------------------
 2611			      C im_our_int:
 2611  66| 83 E0 FB	      C 	and	eax, 0FFFFFFFBh 	; don't write TU bit (TxHang Stuff)
 2615  66| EF		      C 	out	dx, eax 		;; Clear CR5
			      C 
			      C 	SAVE_DOS_STACK			; Use our own stack
 2617  2E: 8C 16 2575 R	     1C         mov     cs:[save_int_ss], ss            
 261C  2E: 89 26 2577 R	     1C         mov     cs:[save_int_sp], sp            
 2621  8C C8		     1C         mov     ax, cs                          
 2623  8E D0		     1C         mov     ss, ax
 2625  BC 0000 E	     1C         mov     sp, OFFSET our_stack              
			      C 
			      C 	ACK_PIC_INTERRUPT		; Issue EOI to the 8259 PIC Chips
 2628  B0 20		     1C         mov     al, 20h                 
 262A  2E: F6 06 248B R	     1C         test    CS:PICAckSlave,0FFh
       FF
 2630  74 02		     1C         jz      ??0001
 2632  E6 A0		     1C         out     0A0h, al                
 2634			     1C ??0001:
 2634  E6 20		     1C         out     020h, al                
			      C 
 2636  FB		      C 	sti				; Re-enable system wide interrupts
			      C 
			      C ;
			      C ; ISR Processing Goes Here
			      C ;
 2637			      C tx_int:
 2637  FA		      C 	cli
			      C 
 2638  66| F7 06 2571 R	      C 	test   CR5_image, CR7_M_TXCIE
       00000001
 2641  74 28		      C 	jz     rx_int
			      C 
			      C ;-- check if currently transmiting packet complete
 2643  8B 3E 0C26 R	      C 	mov	di, NextTxPollPtr
			      C 
 2647  66| F7 05 80000000     C 	test	[di].XMT_DESCRIPTOR.TDES0, TDES0_M_OWN
 264E  75 1B		      C 	jnz	rx_int		       ; exit if transmit not complete
			      C 
			      C ;-- transmit complete, kick transmit poll for next waiting if any
			      C 
			      C 	;-- reset TxHangCounter to prevent timer handler from reseting the chip
 2650  C7 06 02AE R 0000      C 	mov	TxHangCounter, 0
			      C 
			      C 	;-- decrement transmit pending count
 2656  FF 0E 0C28 R	      C 	dec	TxPendingCnt
			      C 
			      C 	;-- advance NextTxPollPtr to next waiting
 265A  8B 45 12		      C 	mov	ax, [di].XMT_DESCRIPTOR.p_XmtNext
 265D  A3 0C26 R	      C 	mov	NextTxPollPtr, ax	; advance to next waiting
			      C 
			      C ;;-- check if any other patcket pending
 2660  83 3E 0C28 R 00	      C 	 cmp	 TxPendingCnt, 0
 2665  74 04		      C 	 je	 rx_int
			      C 
			      C ;;++, 990830, htho
 2667  FB		      C 	sti
			      C ;;++
 2668  E8 E8F5		      C 	call	XmtMain
			      C 
 266B			      C rx_int:
			      C ;;++, 990830, htho
 266B  FA		      C 	cli
			      C ;;++
 266C  66| F7 06 2571 R	      C 	test   CR5_image, CR7_M_RXCIE
       00000040
 2675  74 08		      C 	jz     im_exit
			      C ;;;;++, 2000.4.6, htho
 2677  FF 06 02AC R	      C 	inc	interval_rx_cnt
			      C ;;;;++
			      C 
			      C ;;++, 990830, htho
 267B  FB		      C 	sti
			      C ;;++
 267C  E8 EAE0		      C 	call RcvMain
			      C 
 267F			      C im_exit:
			      C 
			      C 	RESTORE_DOS_STACK
 267F  2E: 8E 16 2575 R	     1C         mov  ss, cs:[save_int_ss]               
 2684  2E: 8B 26 2577 R	     1C         mov  sp, cs:[save_int_sp]
			      C 
 2689			      C im_exit_after:
			      C ;
			      C ; Momentarily disable system interrupts, and re-enable hardware interrupts
			      C ; at the ESIC chip. Interrupts will be re-enabled on return from the ISR, since
			      C ; the processor flags are restored on return from interrupt
			      C ;
			      C 
 2689  FA		      C 	cli
			      C 
 268A  C6 06 2570 R 00	      C 	mov InterruptSemaphore, 0
			      C 
			      C 	ENABLE_ADAPTER_INTERRUPT
 268F  66| 50		     1C         push   eax
 2691  52		     1C         push   dx
 2692  8B 16 246B R	     1C         mov    dx, p_CR7
 2696  66| B8 00018041	     1C         mov    eax, CR7_K_DEFAULT_ON
 269C  66| EF		     1C         out    dx, eax
 269E  5A		     1C         pop    dx
 269F  66| 58		     1C         pop    eax
			      C 
 26A1			      C im_isrdone:
			      C 	EXIT_ISR
 26A1  07		     1C         pop  es                 
 26A2  1F		     1C         pop  ds                 
 26A3  66| 61		     1C         popad                   
 26A5  CF		     1C         iret
			      C 
 26A6			      C InterruptMain	ENDP
			      C  
			      C 
			      C ;;++, 2000.1.31, hu-tiong
			      C ;IFDEF	 DEBUGDOS
			      C ;include debug.asm
			      C ;ENDIF	 ;-- DEBUGDOS
			      C ;;++
			      C ;;-----------------------
			      C ;any code after this will not be kept after initialization. Buffers
			      C ;used by the program, if any, are allocated from the memory between
			      C ;end_resident and end_free_mem.
			      C 	public end_resident,end_free_mem
			      C 
			      C ;;-+
			      C ;;	ALIGN 4
			      C 	ALIGN 16
			      C ;;-+
 26B0			      C end_resident	label	byte
 26B0			      C end_free_mem	label	byte
			      C 
 26B0  8000 [		      C Filler DB 32768 DUP (?)     ; This over allocates the data segment for driver
        00
       ]
			      C 			    ; init. The InitAllocatePhysicalBlock
			      C 			    ; routine grabs what ever it needs, and returns
			      C 			    ; the rest to the OS on return from driver init.
			      C 			    ; If the space isn't LINKED into the driver, then
			      C 			    ; it isn't ours to split up, and give back to the
			      C 			    ; OS.
			      C 
			      C ;standard EN0_DCFG contents:
 A6B0 48		      C endcfg	db	048h			; Set burst mode, 8 deep FIFO
			      C include etopen.asm
			      C ;*****************************************************************************
			      C ;* Name : ETOPEN.ASM
			      C ;*
			      C ;* All rights reserved by DAVICOM, 1996
			      C ;*
			      C ;* Description :
			      C ;*	. Allocate descriptors & buffers memory.
			      C ;*	. Setup interrupt vector.
			      C ;*	. Initializes transmit.
			      C ;*	. Initializes receive.
			      C ;*	. Initializes card.
			      C ;*
			      C ;* Functions :
			      C ;*
			      C ;* Author : Spenser Tsai
			      C ;*
			      C ;* Date : 05/17/96'
			      C ;*
			      C ;* Change Notes :
			      C ;* Date - Modifier
			      C ;*     Cause :
			      C ;*  Modified :
			      C ;*    Result :
			      C ;*
			      C ;*****************************************************************************
			      C ;
			      C ; These functions are hardware initialize.
			      C ;
			      C extrn	AllocatePhysicalBlock : NEAR
			      C EXTRN	set_recv_isr : NEAR
			      C 
			      C .386
			      C ; Called once to initialize the card
			      C 
			      C 	public	etopen
 A6B1			      C etopen: 			; Initialize interface
			      C 
 A6B1  66| 50		      C 	push	eax
			      C 
 A6B3  E8 0000 E	      C 	call	AllocatePhysicalBlock	    ;; allocate data buffer. (INITPCI.ASM)
			      C 
 A6B6  66| FF 36 2457 R	      C 	push   p_PhysBlockPhys	    ; Call XmtInit
 A6BB  FF 36 2455 R	      C 	push   p_PhysBlockVirt
 A6BF  E8 6586		      C 	call   XmtInit			;; (XMT.ASM)
 A6C2  83 C4 06		      C 	add    sp, 6
			      C 
			      C 	;; Adjust pointer to Receive's buffer
 A6C5  01 06 2455 R	      C 	add    p_PhysBlockVirt, AX	; Adjust the virtual and physical block
 A6C9  66| 25 0000FFFF	      C 	and    eax, 0FFFFh		; pointers based on the number of bytes
 A6CF  66| 01 06 2457 R	      C 	add    p_PhysBlockPhys, EAX	; used
			      C 
 A6D4  66| FF 36 2457 R	      C 	push   p_PhysBlockPhys		; Call RcvInit
 A6D9  FF 36 2455 R	      C 	push   p_PhysBlockVirt
 A6DD  E8 694A		      C 	call   RcvInit			;; (RCV.ASM)
 A6E0  83 C4 06		      C 	add    sp, 6
			      C 
 A6E3  E8 76BA		      C 	call	PortInit		 ; Init adapter port interface
 A6E6  72 14		      C 	jc	etopen_exit
			      C 
 A6E8  E8 0000 E	      C 	call	set_recv_isr		;; Setup receive ISR
 A6EB  A0 0000 R	      C 	mov	al, int_no		; Get board's interrupt vector
 A6EE  04 08		      C 	add	al, 8
 A6F0  3C 10		      C 	cmp	al, 8+8 		; Is it a slave 8259 interrupt?
 A6F2  72 02		      C 	jb	set_int_num		; No.
 A6F4  04 60		      C 	add	al, 70h - 8 - 8 	; Map it to the real interrupt.
 A6F6			      C 	set_int_num:
 A6F6  32 E4		      C 	xor	ah, ah			; Clear high byte
 A6F8  A3 0022 R	      C 	mov	int_num, ax		; Set parameter_list int num.
			      C 
 A6FB  F8		      C 	clc
 A6FC			      C etopen_exit:
 A6FC  66| 58		      C 	pop	eax
			      C 
 A6FE  C3		      C 	ret
			      C  
			      C 
			      C 
			      C  
			      C 

				;;--- Loading time messages
					public	copyright_msg
 A6FF 50 61 63 6B 65 74		copyright_msg	db	"Packet driver for DAVICOM DM9PCI Series Ethernet Adapter, version "
       20 64 72 69 76 65
       72 20 66 6F 72 20
       44 41 56 49 43 4F
       4D 20 44 4D 39 50
       43 49 20 53 65 72
       69 65 73 20 45 74
       68 65 72 6E 65 74
       20 41 64 61 70 74
       65 72 2C 20 76 65
       72 73 69 6F 6E 20
 A741  31 2E 34 2E 30 0D			db	'0'+majver,".",'0'+version,".",'0'+dm9100_version,CR,LF,'$'
       0A 24

					public	branding_msg
 A749 24			branding_msg	db	'$'

					public	usage_msg
				;; -+, 980303, Hu-Tiong
				;;usage_msg	  db	  "usage: DM9PCIPD [options] <packet_int_no> [<int_level> <io_addr>]",CR,LF,
				'$'
 A74A 75 73 61 67 65 3A		usage_msg	db	"usage: DM9PCIPD [options] <packet_int_no>",CR,LF,'$'
       20 44 4D 39 50 43
       49 50 44 20 5B 6F
       70 74 69 6F 6E 73
       5D 20 3C 70 61 63
       6B 65 74 5F 69 6E
       74 5F 6E 6F 3E 0D
       0A 24
				;;-+

 A776 49 6E 74 65 72 72		int_no_name	db	"Interrupt number ",'$'
       75 70 74 20 6E 75
       6D 62 65 72 20 24
 A788 49 2F 4F 20 70 6F		io_addr_name	db	"I/O port ",'$'
       72 74 20 24

					extrn	set_recv_isr: near

				;enter with si -> argument string, di -> word to store.
				;if there is no number, don't change the number.
					extrn	get_number: near

				;enter with dx -> name of word, di -> dword to print.
					extrn	print_number: near

				;-------------------------------------------------------------
				; parse_args
				;	Save the number of interrupt to "int_no" &
				;	save the base of I/O address to "io_addr".
				;-------------------------------------------------------------
					public	parse_args
 A792				parse_args:
				;exit with nc if all went well, cy otherwise.
 A792  BF 0000 R			mov	di,offset int_no
 A795  E8 0000 E			call	get_number		;; Return DI
 A798  BF 0004 R			mov	di,offset io_addr
 A79B  E8 0000 E			call	get_number
 A79E  F8				clc
 A79F  C3				ret

					extrn	etopen_diagn: byte

					public	print_parameters
 A7A0				print_parameters:
				;echo our command-line parameters
 A7A0  BF 0000 R			mov	di,offset int_no
 A7A3  BA A776 R			mov	dx,offset int_no_name
 A7A6  E8 0000 E			call	print_number
 A7A9  BF 0004 R			mov	di,offset io_addr
 A7AC  BA A788 R			mov	dx,offset io_addr_name
 A7AF  E8 0000 E			call	print_number
 A7B2  C3				ret

 A7B3				code	ends

					end
 
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:38
SROM  --  UMC Internal Use Only				     Symbols 22 - 1




Macros:

                N a m e                 Type

ACK_PIC_INTERRUPT  . . . . . . .	Proc
BRUSH_BYTE . . . . . . . . . . .	Proc
BRUSH_CHAR . . . . . . . . . . .	Proc
DISABLE_ADAPTER_INTERRUPT  . . .	Proc
DISP_BYTE  . . . . . . . . . . .	Proc
DISP_CHAR  . . . . . . . . . . .	Proc
DSSI_TO_PHYSICAL . . . . . . . .	Proc
ENABLE_ADAPTER_INTERRUPT . . . .	Proc
ENTER_ISR  . . . . . . . . . . .	Proc
EXIT_ISR . . . . . . . . . . . .	Proc
POP_REGISTERS  . . . . . . . . .	Proc
RESTORE_DOS_STACK  . . . . . . .	Proc
SAVE_DOS_STACK . . . . . . . . .	Proc
add2 . . . . . . . . . . . . . .	Proc
longpause  . . . . . . . . . . .	Proc
movseg . . . . . . . . . . . . .	Proc
pause_ . . . . . . . . . . . . .	Proc
ps . . . . . . . . . . . . . . .	Proc
repmov . . . . . . . . . . . . .	Proc
reset_8390 . . . . . . . . . . .	Proc
send_peekqueue . . . . . . . . .	Proc
send_queueempty  . . . . . . . .	Proc
terminate_board  . . . . . . . .	Proc
to_scrn  . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

RCV_DESCRIPTOR . . . . . . . . .	 0020
  RDES0  . . . . . . . . . . . .	 0000	     DWord
  RDES1  . . . . . . . . . . . .	 0004	     DWord
  RDES2  . . . . . . . . . . . .	 0008	     DWord
  RDES3  . . . . . . . . . . . .	 000C	     DWord
  p_RcvBuffer  . . . . . . . . .	 0010	     Word
  p_RcvNext  . . . . . . . . . .	 0012	     Word
  p_Dummy1 . . . . . . . . . . .	 0014	     DWord
  p_Dummy2 . . . . . . . . . . .	 0018	     DWord
  p_Dummy3 . . . . . . . . . . .	 001C	     DWord
SIA_CONFIG . . . . . . . . . . .	 000C
  CR13 . . . . . . . . . . . . .	 0000	     DWord
  CR14 . . . . . . . . . . . . .	 0004	     DWord
  CR15 . . . . . . . . . . . . .	 0008	     DWord
SROM_MotolorA_Contents . . . . .	 006D
  MA_SS_Vendor_ID  . . . . . . .	 0000	     Word
  MA_SS_ID . . . . . . . . . . .	 0002	     Word
  MA_Cardbus_Low . . . . . . . .	 0004	     Word
  MA_Cardbus_High  . . . . . . .	 0006	     Word
  MA_ID_Reserved1  . . . . . . .	 0008	     Byte
  MA_ID_Bk_Crc . . . . . . . . .	 0010	     Byte
  MA_ID_Reserved2  . . . . . . .	 0011	     Byte
  MA_SROM_version  . . . . . . .	 0012	     Byte
  MA_Controller_cnt  . . . . . .	 0013	     Byte
  MA_Ether_Addr  . . . . . . . .	 0014	     Byte
  MA_Dev_Number  . . . . . . . .	 001A	     Byte
  MA_IL_Offset . . . . . . . . .	 001B	     Word
  MA_Inf_Reserved3 . . . . . . .	 001D	     Byte
  MA_Sel_Conn_type . . . . . . .	 001E	     Word
  MA_Gen_Pur_Ctrl  . . . . . . .	 0020	     Byte
  MA_Blk_cnt . . . . . . . . . .	 0021	     Byte
  MA_F1_Length_2 . . . . . . . .	 0022	     Byte
  MA_Type3 . . . . . . . . . . .	 0023	     Byte
  MA_10BaseT_Code  . . . . . . .	 0024	     Byte
  MA_GprData10 . . . . . . . . .	 0025	     Byte
  MA_Comm10  . . . . . . . . . .	 0026	     Word
  MA_F1_Length_3 . . . . . . . .	 0028	     Byte
  MA_Type4 . . . . . . . . . . .	 0029	     Byte
  MA_100BaseT_Code . . . . . . .	 002A	     Byte
  MA_GprData100  . . . . . . . .	 002B	     Byte
  MA_Comm100 . . . . . . . . . .	 002C	     Word
  MA_F1_Length_4 . . . . . . . .	 002E	     Byte
  MA_Type5 . . . . . . . . . . .	 002F	     Byte
  MA_10BaseFD_Code . . . . . . .	 0030	     Byte
  MA_GprData10FD . . . . . . . .	 0031	     Byte
  MA_Comm10FD  . . . . . . . . .	 0032	     Word
  MA_F1_Length_5 . . . . . . . .	 0034	     Byte
  MA_Type6 . . . . . . . . . . .	 0035	     Byte
  MA_100BaseFD . . . . . . . . .	 0036	     Byte
  MA_GprData100FD  . . . . . . .	 0037	     Byte
  MA_Comm100FD . . . . . . . . .	 0038	     Word
  MA_Reserved4 . . . . . . . . .	 003A	     Byte
  MA_SROM_CRC  . . . . . . . . .	 006B	     Byte
SROM_NS_Contents . . . . . . . .	 0082
  NS_SS_Vendor_ID  . . . . . . .	 0000	     Word
  NS_SS_ID . . . . . . . . . . .	 0002	     Word
  NS_Cardbus_Low . . . . . . . .	 0004	     Word
  NS_Cardbus_High  . . . . . . .	 0006	     Word
  NS_ID_Reserved1  . . . . . . .	 0008	     Byte
  NS_ID_Bk_Crc . . . . . . . . .	 0010	     Byte
  NS_ID_Reserved2  . . . . . . .	 0011	     Byte
  NS_SROM_version  . . . . . . .	 0012	     Byte
  NS_Controller_cnt  . . . . . .	 0013	     Byte
  NS_Ether_Addr  . . . . . . . .	 0014	     Byte
  NS_Dev_Number  . . . . . . . .	 001A	     Byte
  NS_IL_Offset . . . . . . . . .	 001B	     Word
  NS_Inf_Reserved3 . . . . . . .	 001D	     Byte
  NS_Sel_Conn_type . . . . . . .	 001E	     Word
  NS_Gen_Pur_Ctrl  . . . . . . .	 0020	     Byte
  NS_Blk_cnt . . . . . . . . . .	 0021	     Byte
  NS_F1_Length_0 . . . . . . . .	 0022	     Byte
  NS_Type1 . . . . . . . . . . .	 0023	     Byte
  NS_PHY_Number  . . . . . . . .	 0024	     Byte
  NS_GPR_Seq_Len . . . . . . . .	 0025	     Byte
  NS_RST_Seq_Len . . . . . . . .	 0026	     Byte
  NS_RST_Seq_0 . . . . . . . . .	 0027	     Byte
  NS_RST_Seq_1 . . . . . . . . .	 0028	     Byte
  NS_Media_Cap . . . . . . . . .	 0029	     Word
  NS_Nway_Adv  . . . . . . . . .	 002B	     Word
  NS_FDX_Map . . . . . . . . . .	 002D	     Word
  NS_TTM_Map . . . . . . . . . .	 002F	     Word
  NS_F1_Length_1 . . . . . . . .	 0031	     Byte
  NS_Type2 . . . . . . . . . . .	 0032	     Byte
  NS_Delay_Seq_0 . . . . . . . .	 0033	     Word
  NS_Delay_seq_1 . . . . . . . .	 0035	     Word
  NS_F1_Length_2 . . . . . . . .	 0037	     Byte
  NS_Type3 . . . . . . . . . . .	 0038	     Byte
  NS_10BaseT_Code  . . . . . . .	 0039	     Byte
  NS_GprData10 . . . . . . . . .	 003A	     Byte
  NS_Comm10  . . . . . . . . . .	 003B	     Word
  NS_F1_Length_3 . . . . . . . .	 003D	     Byte
  NS_Type4 . . . . . . . . . . .	 003E	     Byte
  NS_100BaseT_Code . . . . . . .	 003F	     Byte
  NS_GprData100  . . . . . . . .	 0040	     Byte
  NS_Comm100 . . . . . . . . . .	 0041	     Word
  NS_F1_Length_4 . . . . . . . .	 0043	     Byte
  NS_Type5 . . . . . . . . . . .	 0044	     Byte
  NS_10BaseFD_Code . . . . . . .	 0045	     Byte
  NS_GprData10FD . . . . . . . .	 0046	     Byte
  NS_Comm10FD  . . . . . . . . .	 0047	     Word
  NS_F1_Length_5 . . . . . . . .	 0049	     Byte
  NS_Type6 . . . . . . . . . . .	 004A	     Byte
  NS_100BaseFD . . . . . . . . .	 004B	     Byte
  NS_GprData100FD  . . . . . . .	 004C	     Byte
  NS_Comm100FD . . . . . . . . .	 004D	     Word
  NS_Reserved4 . . . . . . . . .	 004F	     Byte
  NS_SROM_CRC  . . . . . . . . .	 0080	     Byte
XMT_DESCRIPTOR . . . . . . . . .	 0020
  TDES0  . . . . . . . . . . . .	 0000	     DWord
  TDES1  . . . . . . . . . . . .	 0004	     DWord
  TDES2  . . . . . . . . . . . .	 0008	     DWord
  TDES3  . . . . . . . . . . . .	 000C	     DWord
  p_XmtBuffer  . . . . . . . . .	 0010	     Word
  p_XmtNext  . . . . . . . . . .	 0012	     Word
  p_Dummy1 . . . . . . . . . . .	 0014	     DWord
  p_Dummy2 . . . . . . . . . . .	 0018	     DWord
  p_Dummy3 . . . . . . . . . . .	 001C	     DWord
iocb . . . . . . . . . . . . . .	 0014
  buffer . . . . . . . . . . . .	 0000	     DWord
  len  . . . . . . . . . . . . .	 0004	     Word
  flags  . . . . . . . . . . . .	 0006	     Byte
  ret_code . . . . . . . . . . .	 0007	     Byte
  upcall . . . . . . . . . . . .	 0008	     DWord
  next . . . . . . . . . . . . .	 000C	     DWord
  resv . . . . . . . . . . . . .	 0010	     Byte
segmoffs . . . . . . . . . . . .	 0004
  offs . . . . . . . . . . . . .	 0000	     Word
  segm . . . . . . . . . . . . .	 0002	     Word
table_multicast  . . . . . . . .	 0005
  table_maxnum . . . . . . . . .	 0000	     Word
  table_current  . . . . . . . .	 0002	     Word
  table_multiaddr  . . . . . . .	 0004	     Byte


Types:

                N a m e                  Size     Attr

SIA_CONFIG_PTR . . . . . . . . .	 0002	  PTR SIA_CONFIG 


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_TEXT  . . . . . . . . . . . . .	16 Bit	 0000	  Word	  Public  'CODE'	
_DATA  . . . . . . . . . . . . .	16 Bit	 0000	  Word	  Public  'DATA'	
code . . . . . . . . . . . . . .	16 Bit	 A7B3	  Para	  Public  


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

AddMulticastAddress  . . . . . .	P Near	 0F93	  code	Length= 0047 Public
AutoDetectMediaType  . . . . . .	P Near	 1A70	  code	Length= 01D4 Public
CalcCRC  . . . . . . . . . . . .	P Near	 16A0	  code	Length= 0024 Private
Delay10us  . . . . . . . . . . .	P Near	 17FF	  code	Length= 0010 Private
Delay1us . . . . . . . . . . . .	P Near	 17F5	  code	Length= 000A Private
Delay419ns . . . . . . . . . . .	P Near	 17D6	  code	Length= 001F Private
DynamicAutoDetect  . . . . . . .	P Near	 1C44	  code	Length= 015A Public
InterruptMain  . . . . . . . . .	P Far	 2579	  code	Length= 012D Public
MulticastTableSearch . . . . . .	P Near	 0FDA	  code	Length= 003D Public
PNA_Set_CR16 . . . . . . . . . .	P Near	 2182	  code	Length= 0019 Public
PortCR6Write . . . . . . . . . .	P Near	 211C	  code	Length= 0018 Public
PortInit . . . . . . . . . . . .	P Near	 1DA0	  code	Length= 020B Public
PortPrintMessage . . . . . . . .	P Near	 20FE	  code	Length= 001B Public
PortReadTickCounter  . . . . . .	P Near	 1FAB	  code	Length= 000D Public
PortResetDelay . . . . . . . . .	P Near	 20EA	  code	Length= 0014 Private
PortReset  . . . . . . . . . . .	P Near	 2030	  code	Length= 00BA Public
PortUpdateReceiveFilter  . . . .	P Near	 1FB8	  code	Length= 0078 Public
Port_Hardware_Reset_PHY  . . . .	P Near	 2134	  code	Length= 001D Public
Printcur . . . . . . . . . . . .	P Near	 0049	  code	Length= 003F Public
Printdig . . . . . . . . . . . .	P Near	 00B4	  code	Length= 0040 Public
Printwdig  . . . . . . . . . . .	P Near	 010D	  code	Length= 0032 Public
RcvDisable . . . . . . . . . . .	P Near	 1133	  code	Length= 002C Public
RcvEnable  . . . . . . . . . . .	P Near	 124A	  code	Length= 0055 Public
RcvInit  . . . . . . . . . . . .	P Near	 102A	  code	Length= 00E1 Public
RcvMain  . . . . . . . . . . . .	P Near	 115F	  code	Length= 05D4 Public
RcvPostFreeDescriptor  . . . . .	P Near	 1235	  code	Length= 0015 Public
RcvReset . . . . . . . . . . . .	P Near	 110B	  code	Length= 0028 Public
ReadSROMWord . . . . . . . . . .	P Near	 16E2	  code	Length= 00F2 Private
ReadSROM . . . . . . . . . . . .	P Near	 1810	  code	Length= 003F Public
Reset_MAC_PHY  . . . . . . . . .	P Near	 2151	  code	Length= 0031 Public
SROMDelay  . . . . . . . . . . .	P Near	 16CA	  code	Length= 0018 Public
SetCR6 . . . . . . . . . . . . .	P Near	 1A13	  code	Length= 005D Public
Setup_HOMERUN_PHY  . . . . . . .	P Near	 21BC	  code	Length= 0101 Private
Setup_LONGRUN_PHY  . . . . . . .	P Near	 22BD	  code	Length= 00B2 Private
Write_PNA_CR16 . . . . . . . . .	P Near	 219B	  code	Length= 0021 Private
XmtDisable . . . . . . . . . . .	P Near	 0D70	  code	Length= 0021 Public
XmtEnable  . . . . . . . . . . .	P Near	 0D94	  code	Length= 0022 Public
XmtGetSetupBuffer  . . . . . . .	P Near	 0DB8	  code	Length= 000E Public
XmtInit  . . . . . . . . . . . .	P Near	 0C48	  code	Length= 00F0 Public
XmtMain  . . . . . . . . . . . .	P Near	 0F60	  code	Length= 0033 Public
XmtReset . . . . . . . . . . . .	P Near	 0D38	  code	Length= 0035 Public
XmtSendDummyFrame  . . . . . . .	P Near	 0E40	  code	Length= 004E Public
XmtSendSetupFrame  . . . . . . .	P Near	 0DC8	  code	Length= 0073 Public
charoutX . . . . . . . . . . . .	P Near	 0088	  code	Length= 001F Private
charout  . . . . . . . . . . . .	P Near	 00F4	  code	Length= 000C Public
check_dm9009 . . . . . . . . . .	P Near	 23C4	  code	Length= 0035 Private
check_dm9102a_e3 . . . . . . . .	P Near	 2439	  code	Length= 001B Private
check_switching_adapter  . . . .	P Near	 236F	  code	Length= 0055 Private
config_cr15  . . . . . . . . . .	P Near	 23F9	  code	Length= 0040 Private
printcrlfX . . . . . . . . . . .	P Near	 00A7	  code	Length= 000D Private
printcrlf  . . . . . . . . . . .	P Near	 0100	  code	Length= 000D Private
send_pkt . . . . . . . . . . . .	P Near	 0E90	  code	Length= 00CF Public


Symbols:

                N a m e                 Type     Value    Attr

??0000 . . . . . . . . . . . . .	L Near	 2603	  code	
??0001 . . . . . . . . . . . . .	L Near	 2634	  code	
@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . .	Number	 0001h	 
@code  . . . . . . . . . . . . .	Text   	 DGROUP
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP
ANAR_10_FDX  . . . . . . . . . .	Number	 0040h	 
ANAR_10_HDX  . . . . . . . . . .	Number	 0020h	 
ANAR_CAP_ALL . . . . . . . . . .	Number	 01E0h	 
ANAR_CAP_MASK  . . . . . . . . .	Number	 03E0h	 
ANAR_CSMACD  . . . . . . . . . .	Number	 0001h	 
ANAR_DEFAULT_VAL . . . . . . . .	Number	 05E1h	 
ANAR_FCS . . . . . . . . . . . .	Number	 0400h	 
ANAR_RF  . . . . . . . . . . . .	Number	 0200h	 
ANAR_T4  . . . . . . . . . . . .	Number	 0200h	 
ANAR_TX_FDX  . . . . . . . . . .	Number	 0100h	 
ANAR_TX_HDX  . . . . . . . . . .	Number	 0080h	 
ANC_loop . . . . . . . . . . . .	L Near	 1F8C	  code	
ANER_M_LAA . . . . . . . . . . .	Number	 0001h	 
ARCADDR_LEN  . . . . . . . . . .	Number	 0001h	 
AUI_SIAConfig  . . . . . . . . .	Number	 0003h	 
AUTOSENSE_ALARM  . . . . . . . .	Number	 0006h	 
AUTO_STATE_IDLE  . . . . . . . .	Number	 0000h	 
AUTO_STATE_START . . . . . . . .	Number	 0001h	 
A_OPTION . . . . . . . . . . . .	Number	 0200h	 
AdapterNum . . . . . . . . . . .	Byte	 1891	  code	
AllocatePhysicalBlock  . . . . .	L Near	 0000	  code	External
AutoCompleteTimeOut  . . . . . .	Word	 1A11	  code	
AutoCount  . . . . . . . . . . .	Byte	 02EA	  code	
AutoState  . . . . . . . . . . .	Word	 02EE	  code	
Auto_Negotiate . . . . . . . . .	L Near	 1F08	  code	
BAD_ADDRESS  . . . . . . . . . .	Number	 000Eh	 
BAD_COMMAND  . . . . . . . . . .	Number	 000Bh	 
BAD_HANDLE . . . . . . . . . . .	Number	 0001h	 
BAD_IOCB . . . . . . . . . . . .	Number	 0010h	 
BAD_MODE . . . . . . . . . . . .	Number	 0008h	 
BAD_TYPE . . . . . . . . . . . .	Number	 0005h	 
BLACK  . . . . . . . . . . . . .	Number	 0000h	 
BLUEBOOK . . . . . . . . . . . .	Number	 0001h	 
BLUE . . . . . . . . . . . . . .	Number	 0001h	 
BMCR_M_ANE . . . . . . . . . . .	Number	 1000h	 
BMCR_M_CT  . . . . . . . . . . .	Number	 0080h	 
BMCR_M_DM  . . . . . . . . . . .	Number	 0100h	 
BMCR_M_IS  . . . . . . . . . . .	Number	 0400h	 
BMCR_M_LB  . . . . . . . . . . .	Number	 4000h	 
BMCR_M_RAN . . . . . . . . . . .	Number	 0200h	 
BMCR_M_RST . . . . . . . . . . .	Number	 8000h	 
BMCR_M_SL  . . . . . . . . . . .	Number	 2000h	 
BMSR_M_AN  . . . . . . . . . . .	Number	 0020h	 
BMSR_M_LS  . . . . . . . . . . .	Number	 0004h	 
BNC_SIAConfig  . . . . . . . . .	Number	 0002h	 
BOARD_DATA_SIZE  . . . . . . . .	Number	 0020h	 
BROWN  . . . . . . . . . . . . .	Number	 0006h	 
B_OPTION . . . . . . . . . . . .	Number	 0200h	 
BlueBookPacket . . . . . . . . .	L Near	 1206	  code	
CALLED_ETOPEN  . . . . . . . . .	Number	 0001h	 
CALLME . . . . . . . . . . . . .	Number	 0002h	 
CANT_RESET . . . . . . . . . . .	Number	 000Fh	 
CANT_SEND  . . . . . . . . . . .	Number	 000Ch	 
CANT_SET . . . . . . . . . . . .	Number	 000Dh	 
CANT_TERMINATE . . . . . . . . .	Number	 0007h	 
CR0_K_BL_0LW . . . . . . . . . .	Number	 0000h	 
CR0_K_BL_16LW  . . . . . . . . .	Number	 0010h	 
CR0_K_BL_1LW . . . . . . . . . .	Number	 0001h	 
CR0_K_BL_2LW . . . . . . . . . .	Number	 0002h	 
CR0_K_BL_32LW  . . . . . . . . .	Number	 0020h	 
CR0_K_BL_4LW . . . . . . . . . .	Number	 0004h	 
CR0_K_BL_8LW . . . . . . . . . .	Number	 0008h	 
CR0_K_CA_0LW . . . . . . . . . .	Number	 0000h	 
CR0_K_CA_16LW  . . . . . . . . .	Number	 0002h	 
CR0_K_CA_32LW  . . . . . . . . .	Number	 0003h	 
CR0_K_CA_8LW . . . . . . . . . .	Number	 0001h	 
CR0_K_DGW_0LW  . . . . . . . . .	Number	 0000h	 
CR0_K_DGW_1LW  . . . . . . . . .	Number	 0001h	 
CR0_K_DGW_2LW  . . . . . . . . .	Number	 0002h	 
CR0_K_DGW_3LW  . . . . . . . . .	Number	 0003h	 
CR0_K_DGW_4LW  . . . . . . . . .	Number	 0004h	 
CR0_K_TXAP_128_USEC  . . . . . .	Number	 0004h	 
CR0_K_TXAP_1600_USEC . . . . . .	Number	 0003h	 
CR0_K_TXAP_200_USEC  . . . . . .	Number	 0001h	 
CR0_K_TXAP_800_USEC  . . . . . .	Number	 0002h	 
CR0_K_TXAP_NONE  . . . . . . . .	Number	 0000h	 
CR0_M_BA . . . . . . . . . . . .	Number	 0002h	 
CR0_M_BL . . . . . . . . . . . .	Number	 3F00h	 
CR0_M_CA . . . . . . . . . . . .	Number	 C000h	 
CR0_M_DAS  . . . . . . . . . . .	Number	 00010000h   
CR0_M_DGW  . . . . . . . . . . .	Number	 007Ch	 
CR0_M_RESERVED07 . . . . . . . .	Number	 0080h	 
CR0_M_RESERVED . . . . . . . . .	Number	 FFF80000h   
CR0_M_SR . . . . . . . . . . . .	Number	 0001h	 
CR0_M_TXAP . . . . . . . . . . .	Number	 00060000h   
CR0_V_BA . . . . . . . . . . . .	Number	 0001h	 
CR0_V_BL . . . . . . . . . . . .	Number	 0008h	 
CR0_V_CA . . . . . . . . . . . .	Number	 000Eh	 
CR0_V_DAS  . . . . . . . . . . .	Number	 0010h	 
CR0_V_DGW  . . . . . . . . . . .	Number	 0002h	 
CR0_V_RESERVED07 . . . . . . . .	Number	 0007h	 
CR0_V_RESERVED . . . . . . . . .	Number	 0013h	 
CR0_V_SR . . . . . . . . . . . .	Number	 0000h	 
CR0_V_TXAP . . . . . . . . . . .	Number	 0011h	 
CR11_M_FDX_AUTO_CONFIG . . . . .	Number	 FFFFh	 
CR11_M_RESERVED  . . . . . . . .	Number	 FFFF0000h   
CR11_V_FDX_AUTO_CONFIG . . . . .	Number	 0000h	 
CR11_V_RESERVED  . . . . . . . .	Number	 0010h	 
CR12_K_INBOARD_LOOPBACK  . . . .	Number	 000Ah	 
CR12_K_INIT_VAL  . . . . . . . .	Number	 013Fh	 
CR12_K_NORMAL_MODE . . . . . . .	Number	 000Bh	 
CR12_K_ONBOARD_LOOPBACK  . . . .	Number	 0008h	 
CR12_M_GPC . . . . . . . . . . .	Number	 0100h	 
CR12_M_LNK . . . . . . . . . . .	Number	 0004h	 
CR12_M_MD  . . . . . . . . . . .	Number	 00FFh	 
CR12_M_NCR . . . . . . . . . . .	Number	 0002h	 
CR12_M_RESERVED  . . . . . . . .	Number	 FFFFFE00h   
CR12_V_GPC . . . . . . . . . . .	Number	 0008h	 
CR12_V_MD  . . . . . . . . . . .	Number	 0000h	 
CR12_V_RESERVED  . . . . . . . .	Number	 0009h	 
CR13_M_ASE . . . . . . . . . . .	Number	 0080h	 
CR13_M_AUI . . . . . . . . . . .	Number	 0008h	 
CR13_M_CAC . . . . . . . . . . .	Number	 0004h	 
CR13_M_EDP . . . . . . . . . . .	Number	 0010h	 
CR13_M_ENI . . . . . . . . . . .	Number	 0020h	 
CR13_M_IE  . . . . . . . . . . .	Number	 1000h	 
CR13_M_OE13  . . . . . . . . . .	Number	 2000h	 
CR13_M_OE24  . . . . . . . . . .	Number	 4000h	 
CR13_M_OE57  . . . . . . . . . .	Number	 8000h	 
CR13_M_PS  . . . . . . . . . . .	Number	 0002h	 
CR13_M_RESERVED  . . . . . . . .	Number	 FFFF0000h   
CR13_M_SEL . . . . . . . . . . .	Number	 0F00h	 
CR13_M_SIM . . . . . . . . . . .	Number	 0040h	 
CR13_M_SRL . . . . . . . . . . .	Number	 0001h	 
CR13_V_ASE . . . . . . . . . . .	Number	 0007h	 
CR13_V_AUI . . . . . . . . . . .	Number	 0003h	 
CR13_V_CAC . . . . . . . . . . .	Number	 0002h	 
CR13_V_EDP . . . . . . . . . . .	Number	 0004h	 
CR13_V_ENI . . . . . . . . . . .	Number	 0005h	 
CR13_V_IE  . . . . . . . . . . .	Number	 000Ch	 
CR13_V_OE13  . . . . . . . . . .	Number	 000Dh	 
CR13_V_OE24  . . . . . . . . . .	Number	 000Eh	 
CR13_V_OE57  . . . . . . . . . .	Number	 000Fh	 
CR13_V_PS  . . . . . . . . . . .	Number	 0001h	 
CR13_V_RESERVED  . . . . . . . .	Number	 0010h	 
CR13_V_SEL . . . . . . . . . . .	Number	 0008h	 
CR13_V_SIM . . . . . . . . . . .	Number	 0006h	 
CR13_V_SRL . . . . . . . . . . .	Number	 0000h	 
CR1_M_RESERVED . . . . . . . . .	Number	 FFFFFFFEh   
CR1_M_TPD  . . . . . . . . . . .	Number	 0001h	 
CR1_V_RESERVED . . . . . . . . .	Number	 0001h	 
CR1_V_TPD  . . . . . . . . . . .	Number	 0000h	 
CR2_M_RESERVED . . . . . . . . .	Number	 FFFFFFFEh   
CR2_M_RPD  . . . . . . . . . . .	Number	 0001h	 
CR2_V_RESERVED . . . . . . . . .	Number	 0001h	 
CR2_V_RPD  . . . . . . . . . . .	Number	 0000h	 
CR5_K_RXS_PURGE  . . . . . . . .	Number	 0007h	 
CR5_K_RXS_RUN_DESC_ACCESS  . . .	Number	 0001h	 
CR5_K_RXS_RUN_MOVE_DATA  . . . .	Number	 0003h	 
CR5_K_RXS_RUN_WAIT . . . . . . .	Number	 0002h	 
CR5_K_RXS_RUN_WRITE_OWNER  . . .	Number	 0004h	 
CR5_K_RXS_RUN_WRITE_STATUS . . .	Number	 0005h	 
CR5_K_RXS_STOPPED  . . . . . . .	Number	 0000h	 
CR5_K_RXS_SUSPEND  . . . . . . .	Number	 0006h	 
CR5_K_SBEB_MASTER_ABORT  . . . .	Number	 0001h	 
CR5_K_SBEB_PARITY_ERROR  . . . .	Number	 0000h	 
CR5_K_SBEB_TARGET_ABORT  . . . .	Number	 0002h	 
CR5_K_TXS_RUN_DESC_ACCESS  . . .	Number	 0001h	 
CR5_K_TXS_RUN_MOVE_DATA  . . . .	Number	 0003h	 
CR5_K_TXS_RUN_SETUP_MOVE . . . .	Number	 0002h	 
CR5_K_TXS_RUN_WAIT . . . . . . .	Number	 0005h	 
CR5_K_TXS_RUN_WRITE_OWNER  . . .	Number	 0004h	 
CR5_K_TXS_RUN_WRITE_STATUS . . .	Number	 0006h	 
CR5_K_TXS_STOPPED  . . . . . . .	Number	 0000h	 
CR5_K_TXS_SUSPEND  . . . . . . .	Number	 0007h	 
CR5_M_AIS  . . . . . . . . . . .	Number	 8000h	 
CR5_M_ETI  . . . . . . . . . . .	Number	 0400h	 
CR5_M_GPT  . . . . . . . . . . .	Number	 0800h	 
CR5_M_NIS  . . . . . . . . . . .	Number	 00010000h   
CR5_M_RESERVED_2 . . . . . . . .	Number	 4000h	 
CR5_M_RESERVED_3 . . . . . . . .	Number	 0010h	 
CR5_M_RESERVED . . . . . . . . .	Number	 FC000000h   
CR5_M_RXCI . . . . . . . . . . .	Number	 0040h	 
CR5_M_RXDU . . . . . . . . . . .	Number	 0080h	 
CR5_M_RXPS . . . . . . . . . . .	Number	 0100h	 
CR5_M_RXS  . . . . . . . . . . .	Number	 000E0000h   
CR5_M_RXWT . . . . . . . . . . .	Number	 0200h	 
CR5_M_SBEB . . . . . . . . . . .	Number	 03800000h   
CR5_M_SBE  . . . . . . . . . . .	Number	 2000h	 
CR5_M_TXCI . . . . . . . . . . .	Number	 0001h	 
CR5_M_TXDU . . . . . . . . . . .	Number	 0004h	 
CR5_M_TXFU . . . . . . . . . . .	Number	 0020h	 
CR5_M_TXJT . . . . . . . . . . .	Number	 0008h	 
CR5_M_TXPS . . . . . . . . . . .	Number	 0002h	 
CR5_M_TXS  . . . . . . . . . . .	Number	 00700000h   
CR5_V_AIS  . . . . . . . . . . .	Number	 000Fh	 
CR5_V_ETI  . . . . . . . . . . .	Number	 000Ah	 
CR5_V_GPT  . . . . . . . . . . .	Number	 000Bh	 
CR5_V_NIS  . . . . . . . . . . .	Number	 0010h	 
CR5_V_RESERVED_2 . . . . . . . .	Number	 000Eh	 
CR5_V_RESERVED_3 . . . . . . . .	Number	 0004h	 
CR5_V_RESERVED . . . . . . . . .	Number	 001Ah	 
CR5_V_RXCI . . . . . . . . . . .	Number	 0006h	 
CR5_V_RXDU . . . . . . . . . . .	Number	 0007h	 
CR5_V_RXPS . . . . . . . . . . .	Number	 0008h	 
CR5_V_RXS  . . . . . . . . . . .	Number	 0011h	 
CR5_V_RXWT . . . . . . . . . . .	Number	 0009h	 
CR5_V_SBEB . . . . . . . . . . .	Number	 0017h	 
CR5_V_SBE  . . . . . . . . . . .	Number	 000Dh	 
CR5_V_TXCI . . . . . . . . . . .	Number	 0000h	 
CR5_V_TXDU . . . . . . . . . . .	Number	 0002h	 
CR5_V_TXFU . . . . . . . . . . .	Number	 0005h	 
CR5_V_TXJT . . . . . . . . . . .	Number	 0003h	 
CR5_V_TXPS . . . . . . . . . . .	Number	 0001h	 
CR5_V_TXS  . . . . . . . . . . .	Number	 0014h	 
CR5_image  . . . . . . . . . . .	DWord	 2571	  code	
CR6_DEFAULT  . . . . . . . . . .	Number	 02040000h   
CR6_DM9009_INIT  . . . . . . . .	Number	 02080082h   
CR6_K_100MB_INIT . . . . . . . .	Number	 00280000h   
CR6_K_100MB_TSB_1024_BYTES . . .	Number	 0003h	 
CR6_K_100MB_TSB_128_BYTES  . . .	Number	 0000h	 
CR6_K_100MB_TSB_256_BYTES  . . .	Number	 0001h	 
CR6_K_100MB_TSB_512_BYTES  . . .	Number	 0002h	 
CR6_K_10MB_TSB_128_BYTES . . . .	Number	 0002h	 
CR6_K_10MB_TSB_160_BYTES . . . .	Number	 0003h	 
CR6_K_10MB_TSB_72_BYTES  . . . .	Number	 0000h	 
CR6_K_10MB_TSB_96_BYTES  . . . .	Number	 0001h	 
CR6_K_10MB_TSB_DEFAULT . . . . .	Text   	 CR6_K_10MB_TSB_72_BYTES
CR6_M_DM9009_ALWAYS  . . . . . .	Number	 02000000h   
CR6_M_FCM  . . . . . . . . . . .	Number	 1000h	 
CR6_M_FDM  . . . . . . . . . . .	Number	 0200h	 
CR6_M_HBD  . . . . . . . . . . .	Number	 00080000h   
CR6_M_HOFM . . . . . . . . . . .	Number	 0004h	 
CR6_M_HPFM . . . . . . . . . . .	Number	 0001h	 
CR6_M_IAFM . . . . . . . . . . .	Number	 0010h	 
CR6_M_ISRW . . . . . . . . . . .	Number	 0100h	 
CR6_M_LBM  . . . . . . . . . . .	Number	 0C00h	 
CR6_M_MSF  . . . . . . . . . . .	Number	 00800000h   
CR6_M_MSPS . . . . . . . . . . .	Number	 00040000h   
CR6_M_PAM  . . . . . . . . . . .	Number	 0080h	 
CR6_M_PBF  . . . . . . . . . . .	Number	 0008h	 
CR6_M_PM . . . . . . . . . . . .	Number	 0040h	 
CR6_M_RESERVED1_1  . . . . . . .	Number	 -80000000h   
CR6_M_RESERVED2_1  . . . . . . .	Number	 20000000h   
CR6_M_RESERVED3_0  . . . . . . .	Number	 38000000h   
CR6_M_RESERVED4_1  . . . . . . .	Number	 04000000h   
CR6_M_RESERVED5_0  . . . . . . .	Number	 00020000h   
CR6_M_RESERVED6_0  . . . . . . .	Number	 00010000h   
CR6_M_RESERVED8_0  . . . . . . .	Number	 0020h	 
CR6_M_RXA  . . . . . . . . . . .	Number	 40000000h   
CR6_M_RXSC . . . . . . . . . . .	Number	 0002h	 
CR6_M_SCM  . . . . . . . . . . .	Number	 01000000h   
CR6_M_SFT  . . . . . . . . . . .	Number	 00200000h   
CR6_M_STT  . . . . . . . . . . .	Number	 00100000h   
CR6_M_TSB  . . . . . . . . . . .	Number	 C000h	 
CR6_M_TXSC . . . . . . . . . . .	Number	 2000h	 
CR6_M_TXTM . . . . . . . . . . .	Number	 00400000h   
CR6_V_FCM  . . . . . . . . . . .	Number	 000Ch	 
CR6_V_FDM  . . . . . . . . . . .	Number	 0009h	 
CR6_V_HBD  . . . . . . . . . . .	Number	 0013h	 
CR6_V_HOFM . . . . . . . . . . .	Number	 0002h	 
CR6_V_HPFM . . . . . . . . . . .	Number	 0000h	 
CR6_V_IAFM . . . . . . . . . . .	Number	 0004h	 
CR6_V_LBM  . . . . . . . . . . .	Number	 000Ah	 
CR6_V_MSF  . . . . . . . . . . .	Number	 0017h	 
CR6_V_MSPS . . . . . . . . . . .	Number	 0012h	 
CR6_V_PAM  . . . . . . . . . . .	Number	 0007h	 
CR6_V_PBF  . . . . . . . . . . .	Number	 0003h	 
CR6_V_PM . . . . . . . . . . . .	Number	 0006h	 
CR6_V_RXSC . . . . . . . . . . .	Number	 0001h	 
CR6_V_SCM  . . . . . . . . . . .	Number	 0018h	 
CR6_V_SFT  . . . . . . . . . . .	Number	 0015h	 
CR6_V_STT  . . . . . . . . . . .	Number	 0014h	 
CR6_V_TSB  . . . . . . . . . . .	Number	 000Eh	 
CR6_V_TXSC . . . . . . . . . . .	Number	 000Dh	 
CR6_V_TXTM . . . . . . . . . . .	Number	 0016h	 
CR6_image  . . . . . . . . . . .	DWord	 189C	  code	Public
CR7_K_DEFAULT_OFF  . . . . . . .	Number	 0000h	 
CR7_K_DEFAULT_ON . . . . . . . .	Number	 00018041h   
CR7_M_AISE . . . . . . . . . . .	Number	 8000h	 
CR7_M_ETIE . . . . . . . . . . .	Number	 0400h	 
CR7_M_GPTE . . . . . . . . . . .	Number	 0800h	 
CR7_M_NISE . . . . . . . . . . .	Number	 00010000h   
CR7_M_RESERVED1  . . . . . . . .	Number	 FFFE0000h   
CR7_M_RESERVED2  . . . . . . . .	Number	 4000h	 
CR7_M_RESERVED3  . . . . . . . .	Number	 1000h	 
CR7_M_RESERVED4  . . . . . . . .	Number	 0010h	 
CR7_M_RXCIE  . . . . . . . . . .	Number	 0040h	 
CR7_M_RXDUE  . . . . . . . . . .	Number	 0080h	 
CR7_M_RXPSE  . . . . . . . . . .	Number	 0100h	 
CR7_M_RXWTE  . . . . . . . . . .	Number	 0200h	 
CR7_M_SBEE . . . . . . . . . . .	Number	 2000h	 
CR7_M_TXCIE  . . . . . . . . . .	Number	 0001h	 
CR7_M_TXDUE  . . . . . . . . . .	Number	 0004h	 
CR7_M_TXFUE  . . . . . . . . . .	Number	 0020h	 
CR7_M_TXJTE  . . . . . . . . . .	Number	 0008h	 
CR7_M_TXPSE  . . . . . . . . . .	Number	 0002h	 
CR7_V_AISE . . . . . . . . . . .	Number	 000Fh	 
CR7_V_ETIE . . . . . . . . . . .	Number	 000Ah	 
CR7_V_GPTE . . . . . . . . . . .	Number	 000Bh	 
CR7_V_NISE . . . . . . . . . . .	Number	 0010h	 
CR7_V_RESERVED1  . . . . . . . .	Number	 0011h	 
CR7_V_RESERVED2  . . . . . . . .	Number	 000Eh	 
CR7_V_RESERVED4  . . . . . . . .	Number	 0004h	 
CR7_V_RXCIE  . . . . . . . . . .	Number	 0006h	 
CR7_V_RXDUE  . . . . . . . . . .	Number	 0007h	 
CR7_V_RXPSE  . . . . . . . . . .	Number	 0008h	 
CR7_V_RXWTE  . . . . . . . . . .	Number	 0009h	 
CR7_V_SBEE . . . . . . . . . . .	Number	 000Dh	 
CR7_V_TXCIE  . . . . . . . . . .	Number	 0000h	 
CR7_V_TXDUE  . . . . . . . . . .	Number	 0002h	 
CR7_V_TXFUE  . . . . . . . . . .	Number	 0005h	 
CR7_V_TXJTE  . . . . . . . . . .	Number	 0003h	 
CR7_V_TXPSE  . . . . . . . . . .	Number	 0001h	 
CR8_M_MIDDED_FRAME_COUNT . . . .	Number	 FFFFh	 
CR8_M_MISSED_FRAME_OVERFLOW  . .	Number	 00010000h   
CR8_M_RESERVED . . . . . . . . .	Number	 FFFE0000h   
CR8_V_MIDDED_FRAME_COUNT . . . .	Number	 0000h	 
CR8_V_MISSED_FRAME_OVERFLOW  . .	Number	 0010h	 
CR8_V_RESERVED . . . . . . . . .	Number	 0011h	 
CR9_BRS  . . . . . . . . . . . .	Number	 1000h	 
CR9_CRCLK  . . . . . . . . . . .	Number	 0002h	 
CR9_CRCS . . . . . . . . . . . .	Number	 0001h	 
CR9_CRDIN  . . . . . . . . . . .	Number	 0004h	 
CR9_CRDOUT . . . . . . . . . . .	Number	 0008h	 
CR9_ERS  . . . . . . . . . . . .	Number	 0800h	 
CR9_MDCLKH . . . . . . . . . . .	Number	 00010000h   
CR9_MDCLKL . . . . . . . . . . .	Number	 0000h	 
CR9_MDIN . . . . . . . . . . . .	Number	 00080000h   
CR9_MDOUTH . . . . . . . . . . .	Number	 00020000h   
CR9_MDOUTL . . . . . . . . . . .	Number	 0000h	 
CR9_MRC  . . . . . . . . . . . .	Number	 4000h	 
CR9_MREAD  . . . . . . . . . . .	Number	 00040000h   
CR9_MWC  . . . . . . . . . . . .	Number	 2000h	 
CR9_MWRITE . . . . . . . . . . .	Number	 0000h	 
CR9_M_MDI  . . . . . . . . . . .	Number	 00080000h   
CR9_S_MDI  . . . . . . . . . . .	Number	 0013h	 
CRCTableSize . . . . . . . . . .	Number	 0400h	 
CRCTable . . . . . . . . . . . .	DWord	 12A0	  code	
CR . . . . . . . . . . . . . . .	Number	 000Dh	 
CT_GetNextByte . . . . . . . . .	L Near	 16AC	  code	
CYAN . . . . . . . . . . . . . .	Number	 0003h	 
CY . . . . . . . . . . . . . . .	Number	 0001h	 
CheckAutoCompleteCnt . . . . . .	Word	 1A0F	  code	
CheckAutoComplete  . . . . . . .	L Near	 1A82	  code	
CheckRxHangCounter . . . . . . .	L Near	 0BD3	  code	
CheckTxHangCounter . . . . . . .	L Near	 0B73	  code	
Check_Hang . . . . . . . . . . .	L Near	 0BA0	  code	
Check_Link_Partner . . . . . . .	L Near	 1A79	  code	
ChipType . . . . . . . . . . . .	Byte	 2454	  code	Public
DAN_AutoComplete . . . . . . . .	L Near	 1D1C	  code	
DAN_done . . . . . . . . . . . .	L Near	 1D96	  code	
DAN_loop . . . . . . . . . . . .	L Near	 1CF7	  code	
DAN_set_cr6  . . . . . . . . . .	L Near	 1D7B	  code	
DAN_set_full_duplex  . . . . . .	L Near	 1D8E	  code	
DAN_set_half_duplex  . . . . . .	L Near	 1D86	  code	
DARKGRAY . . . . . . . . . . . .	Number	 0007h	 
DC21X4_CHIP  . . . . . . . . . .	Number	 000Ah	 
DM9009_CHIP  . . . . . . . . . .	Number	 0001h	 
DM9009_CR12_image  . . . . . . .	DWord	 1898	  code	
DM9100_CHIP  . . . . . . . . . .	Number	 0000h	 
DM9102_CHIP  . . . . . . . . . .	Number	 0002h	 
DONE . . . . . . . . . . . . . .	Number	 0001h	 
DSIPHY . . . . . . . . . . . . .	Number	 0000h	 
D_OPTION . . . . . . . . . . . .	Number	 0002h	 
Debug_eaddr_msg  . . . . . . . .	Byte	 184F	  code	
DelayTickCount . . . . . . . . .	Word	 17D4	  code	
EADDR_LEN  . . . . . . . . . . .	Number	 0006h	 
EI . . . . . . . . . . . . . . .	Number	 0200h	 
EN_OFF . . . . . . . . . . . . .	Number	 0000h	 
FNET_COMM_MASK . . . . . . . . .	Number	 0071h	 
FNET_COMM_OFF  . . . . . . . . .	Number	 0012h	 
FNET_MEDIA_BLK_SIZE  . . . . . .	Number	 0003h	 
FRAME_MTU  . . . . . . . . . . .	Number	 05EAh	 
F_OPTION . . . . . . . . . . . .	Number	 0040h	 
Fill_FF_Multicast  . . . . . . .	L Near	 023A	  code	
Fill_multicasttable  . . . . . .	L Near	 026A	  code	
Fill_myaddress_multicast . . . .	L Near	 0252	  code	
Filler . . . . . . . . . . . . .	Byte	 26B0	  code	
Full_Duplex_msg_len  . . . . . .	Number	 0017h	 
Full_Duplex_msg  . . . . . . . .	Byte	 18B1	  code	
GEN_VER  . . . . . . . . . . . .	Text   	 0
GIANT  . . . . . . . . . . . . .	Number	 05EAh	 
GREEN  . . . . . . . . . . . . .	Number	 0002h	 
GenerateRWSequenceSignals  . . .	L Near	 16FD	  code	
HOMEPNA  . . . . . . . . . . . .	Text   	 
HOMERUN  . . . . . . . . . . . .	Number	 0000h	 
HT . . . . . . . . . . . . . . .	Number	 0009h	 
HW_K_REG_CR0 . . . . . . . . . .	Number	 0000h	 
HW_K_REG_CR10  . . . . . . . . .	Number	 0050h	 
HW_K_REG_CR11  . . . . . . . . .	Number	 0058h	 
HW_K_REG_CR12  . . . . . . . . .	Number	 0060h	 
HW_K_REG_CR13  . . . . . . . . .	Number	 0068h	 
HW_K_REG_CR14  . . . . . . . . .	Number	 0070h	 
HW_K_REG_CR15  . . . . . . . . .	Number	 0078h	 
HW_K_REG_CR1 . . . . . . . . . .	Number	 0008h	 
HW_K_REG_CR2 . . . . . . . . . .	Number	 0010h	 
HW_K_REG_CR3 . . . . . . . . . .	Number	 0018h	 
HW_K_REG_CR4 . . . . . . . . . .	Number	 0020h	 
HW_K_REG_CR5 . . . . . . . . . .	Number	 0028h	 
HW_K_REG_CR6 . . . . . . . . . .	Number	 0030h	 
HW_K_REG_CR7 . . . . . . . . . .	Number	 0038h	 
HW_K_REG_CR8 . . . . . . . . . .	Number	 0040h	 
HW_K_REG_CR9 . . . . . . . . . .	Number	 0048h	 
HW_K_REG_PCICS . . . . . . . . .	Number	 0004h	 
HW_K_REG_PCIID . . . . . . . . .	Number	 0000h	 
HW_K_REG_PCIINT  . . . . . . . .	Number	 003Ch	 
HW_K_REG_PCIIO . . . . . . . . .	Number	 0010h	 
HW_K_REG_PCILT . . . . . . . . .	Number	 000Ch	 
HW_K_REG_PCIRV . . . . . . . . .	Number	 0008h	 
HW_K_REG_PCIUSR  . . . . . . . .	Number	 0040h	 
HW_K_SETUP_FRAME_SIZE  . . . . .	Number	 00C0h	 
H_OPTION . . . . . . . . . . . .	Number	 0020h	 
Half_Duplex_msg_len  . . . . . .	Number	 0017h	 
Half_Duplex_msg  . . . . . . . .	Byte	 18C8	  code	
HomeRunFound . . . . . . . . . .	L Near	 1E5C	  code	
IEEE8023 . . . . . . . . . . . .	Number	 000Bh	 
InitConfigRegRead  . . . . . . .	L Near	 0000	  code	External
InitPIDataRate . . . . . . . . .	Word	 1893	  code	Public
InterruptSemaphore . . . . . . .	Byte	 2570	  code	Public
LF . . . . . . . . . . . . . . .	Number	 000Ah	 
LIGHTBLUE  . . . . . . . . . . .	Number	 0009h	 
LIGHTCYAN  . . . . . . . . . . .	Number	 000Bh	 
LIGHTGRAY  . . . . . . . . . . .	Number	 0008h	 
LIGHTGREEN . . . . . . . . . . .	Number	 000Ah	 
LIGHTMAGENTA . . . . . . . . . .	Number	 000Dh	 
LIGHTRED . . . . . . . . . . . .	Number	 000Ch	 
LINK_FAIL  . . . . . . . . . . .	Number	 0001h	 
LINK_PASS  . . . . . . . . . . .	Number	 0000h	 
LONGRUN  . . . . . . . . . . . .	Number	 0001h	 
LSpeedNum  . . . . . . . . . . .	Word	 1885	  code	Public
Link_Established . . . . . . . .	L Near	 1ADC	  code	
Link_Fail  . . . . . . . . . . .	L Near	 1AA2	  code	
Link_Status_Pass . . . . . . . .	L Near	 1CCB	  code	
MAGENTA  . . . . . . . . . . . .	Number	 0005h	 
MAJ_VER  . . . . . . . . . . . .	Text   	 1
MAX_ADDR_LEN . . . . . . . . . .	Number	 0010h	 
MAX_HANDLE . . . . . . . . . . .	Number	 000Ah	 
MAX_MULTICAST  . . . . . . . . .	Number	 000Eh	 
MAX_P_LEN  . . . . . . . . . . .	Number	 0008h	 
MIN_VER  . . . . . . . . . . . .	Text   	 4
MulticastTable . . . . . . . . .	Byte	 248C	  code	Public
NE_DATAPORT  . . . . . . . . . .	Number	 0010h	 
NE_RESET . . . . . . . . . . . .	Number	 001Fh	 
NO_CLASS . . . . . . . . . . . .	Number	 0002h	 
NO_ERROR . . . . . . . . . . . .	Number	 0000h	 
NO_MULTICAST . . . . . . . . . .	Number	 0006h	 
NO_NUMBER  . . . . . . . . . . .	Number	 0004h	 
NO_SPACE . . . . . . . . . . . .	Number	 0009h	 
NO_TYPE  . . . . . . . . . . . .	Number	 0003h	 
NSPHY  . . . . . . . . . . . . .	Number	 0001h	 
NS_OUI_LSB . . . . . . . . . . .	Number	 5C00h	 
NS_OUI_MSB . . . . . . . . . . .	Number	 2000h	 
N_OPTION . . . . . . . . . . . .	Number	 0004h	 
NextTxPollPtr  . . . . . . . . .	Word	 0C26	  code	Public
No_Match_ability_msg . . . . . .	Byte	 19B2	  code	
Not_100FD  . . . . . . . . . . .	L Near	 1E95	  code	
Not_100HD  . . . . . . . . . . .	L Near	 1EB0	  code	
Not_10FD . . . . . . . . . . . .	L Near	 1ECB	  code	
Not_10HD . . . . . . . . . . . .	L Near	 1EE6	  code	
Not_1PNA . . . . . . . . . . . .	L Near	 1F02	  code	
Operation  . . . . . . . . . . .	L Near	 1E69	  code	
PCICS_M_BACK_TO_BACK . . . . . .	Number	 00800000h   
PCICS_M_BUS_MASTER . . . . . . .	Number	 0004h	 
PCICS_M_DATA_PARITY  . . . . . .	Number	 01000000h   
PCICS_M_DEVSEL . . . . . . . . .	Number	 06000000h   
PCICS_M_IO_ACCESS  . . . . . . .	Number	 0001h	 
PCICS_M_MASTER_ABORT . . . . . .	Number	 20000000h   
PCICS_M_MEMORY_ACCESS  . . . . .	Number	 0002h	 
PCICS_M_PARITY_ERROR_DETECTED  .	Number	 0040h	 
PCICS_M_PARITY_ERROR . . . . . .	Number	 -80000000h   
PCICS_M_RESERVED_2 . . . . . . .	Number	 007FFC00h   
PCICS_M_RESERVED_3 . . . . . . .	Number	 0180h	 
PCICS_M_RESERVED_4 . . . . . . .	Number	 0038h	 
PCICS_M_RESERVED . . . . . . . .	Number	 08000000h   
PCICS_M_SERR_ENABLE  . . . . . .	Number	 0200h	 
PCICS_M_SYSTEM_ERROR . . . . . .	Number	 40000000h   
PCICS_M_TARGET_ABORT . . . . . .	Number	 10000000h   
PCICS_V_BACK_TO_BACK . . . . . .	Number	 0017h	 
PCICS_V_BUS_MASTER . . . . . . .	Number	 0002h	 
PCICS_V_DATA_PARITY  . . . . . .	Number	 0018h	 
PCICS_V_DEVSEL . . . . . . . . .	Number	 0019h	 
PCICS_V_IO_ACCESS  . . . . . . .	Number	 0000h	 
PCICS_V_MASTER_ABORT . . . . . .	Number	 001Dh	 
PCICS_V_MEMORY_ACCESS  . . . . .	Number	 0001h	 
PCICS_V_PARITY_ERROR_DETECTED  .	Number	 0006h	 
PCICS_V_PARITY_ERROR . . . . . .	Number	 001Fh	 
PCICS_V_RESERVED_2 . . . . . . .	Number	 000Ah	 
PCICS_V_RESERVED_3 . . . . . . .	Number	 0007h	 
PCICS_V_RESERVED_4 . . . . . . .	Number	 0003h	 
PCICS_V_RESERVED . . . . . . . .	Number	 001Bh	 
PCICS_V_SERR_ENABLE  . . . . . .	Number	 0009h	 
PCICS_V_SYSTEM_ERROR . . . . . .	Number	 001Eh	 
PCICS_V_TARGET_ABORT . . . . . .	Number	 001Ch	 
PCIID_DM9009_DEVICE_ID . . . . .	Number	 9009h	 
PCIID_DM9100_DEVICE_ID . . . . .	Number	 9100h	 
PCIID_DM9102_DEVICE_ID . . . . .	Number	 9102h	 
PCIID_M_DEVICE_ID  . . . . . . .	Number	 FFFF0000h   
PCIID_M_VENDOR_IO  . . . . . . .	Number	 FFFFh	 
PCIID_VENDOR_ID  . . . . . . . .	Number	 1282h	 
PCIID_V_DEVICE_ID  . . . . . . .	Number	 0010h	 
PCIID_V_VENDOR_IO  . . . . . . .	Number	 0000h	 
PCIINT_M_INTERRUPT_LINE  . . . .	Number	 00FFh	 
PCIINT_M_INTERRUPT_PIN . . . . .	Number	 FF00h	 
PCIINT_M_RESERVED  . . . . . . .	Number	 FFFF0000h   
PCIINT_V_INTERRUPT_LINE  . . . .	Number	 0000h	 
PCIINT_V_INTERRUPT_PIN . . . . .	Number	 0008h	 
PCIINT_V_RESERVED  . . . . . . .	Number	 0010h	 
PCIIO_M_MEMORY_IO  . . . . . . .	Number	 0001h	 
PCIIO_M_PCI_IO_BASE_ADDRESS  . .	Number	 FFFFFF80h   
PCIIO_M_RESERVED . . . . . . . .	Number	 007Eh	 
PCIIO_V_MEMORY_IO  . . . . . . .	Number	 0000h	 
PCIIO_V_PCI_IO_BASE_ADDRESS  . .	Number	 0007h	 
PCIIO_V_RESERVED . . . . . . . .	Number	 0001h	 
PCILT_M_LATENCY_TIMER  . . . . .	Number	 FF00h	 
PCILT_M_RESERVED_2 . . . . . . .	Number	 00FFh	 
PCILT_M_RESERVED . . . . . . . .	Number	 FFFF0000h   
PCILT_V_LATENCY_TIMER  . . . . .	Number	 0008h	 
PCILT_V_RESERVED_2 . . . . . . .	Number	 0000h	 
PCILT_V_RESERVED . . . . . . . .	Number	 0010h	 
PCIMEM_M_MEMORY_SPACE  . . . . .	Number	 0001h	 
PCIMEM_M_PCI_MEM_BASE_ADDRESS  .	Number	 FFFFFF80h   
PCIMEM_M_RESERVED  . . . . . . .	Number	 007Eh	 
PCIMEM_V_MEMORY_SPACE  . . . . .	Number	 0000h	 
PCIMEM_V_PCI_MEM_BASE_ADDRESS  .	Number	 0007h	 
PCIMEM_V_RESERVED  . . . . . . .	Number	 0001h	 
PCIRV_M_BASE_CLASS . . . . . . .	Number	 FF000000h   
PCIRV_M_RESERVED . . . . . . . .	Number	 FF00h	 
PCIRV_M_Revision_Major_Number  .	Number	 00F0h	 
PCIRV_M_Revision_Minor_Number  .	Number	 000Fh	 
PCIRV_M_SUB_CLASS  . . . . . . .	Number	 00FF0000h   
PCIRV_V_BASE_CLASS . . . . . . .	Number	 0018h	 
PCIRV_V_RESERVED . . . . . . . .	Number	 0008h	 
PCIRV_V_Revision_Major_Number  .	Number	 0004h	 
PCIRV_V_Revision_Minor_Number  .	Number	 0000h	 
PCIRV_V_SUB_CLASS  . . . . . . .	Number	 0010h	 
PCIUSR_M_RESERVED_2  . . . . . .	Number	 00FFh	 
PCIUSR_M_RESERVED  . . . . . . .	Number	 FFFF0000h   
PCIUSR_M_USER_SPECIAL_USE  . . .	Number	 FF00h	 
PCIUSR_V_RESERVED_2  . . . . . .	Number	 0000h	 
PCIUSR_V_RESERVED  . . . . . . .	Number	 0010h	 
PCIUSR_V_USER_SPECIAL_USE  . . .	Number	 0008h	 
PHY100_msg_len . . . . . . . . .	Number	 0015h	 
PHY100_msg . . . . . . . . . . .	Byte	 18F3	  code	
PHY10_msg_len  . . . . . . . . .	Number	 0014h	 
PHY10_msg  . . . . . . . . . . .	Byte	 18DF	  code	
PHYTYPE  . . . . . . . . . . . .	Byte	 1896	  code	Public
PHY_100MB  . . . . . . . . . . .	L Near	 1B97	  code	
PHY_10BTCR . . . . . . . . . . .	Number	 001Ch	 
PHY_10BTCSR  . . . . . . . . . .	Number	 0012h	 
PHY_10BTSR . . . . . . . . . . .	Number	 001Bh	 
PHY_10MB . . . . . . . . . . . .	L Near	 1B9F	  code	
PHY_ANAR . . . . . . . . . . . .	Number	 0004h	 
PHY_ANER . . . . . . . . . . . .	Number	 0006h	 
PHY_ANLPAR . . . . . . . . . . .	Number	 0005h	 
PHY_BMCR . . . . . . . . . . . .	Number	 0000h	 
PHY_BMSR . . . . . . . . . . . .	Number	 0001h	 
PHY_DCR  . . . . . . . . . . . .	Number	 0012h	 
PHY_DECR . . . . . . . . . . . .	Number	 0015h	 
PHY_DSCSR  . . . . . . . . . . .	Number	 0011h	 
PHY_FCSCR  . . . . . . . . . . .	Number	 0013h	 
PHY_LBREMR . . . . . . . . . . .	Number	 0018h	 
PHY_Number . . . . . . . . . . .	Byte	 1895	  code	Public
PHY_PAR  . . . . . . . . . . . .	Number	 0019h	 
PHY_PCR  . . . . . . . . . . . .	Number	 0017h	 
PHY_PHYIDR1  . . . . . . . . . .	Number	 0002h	 
PHY_PHYIDR2  . . . . . . . . . .	Number	 0003h	 
PHY_SRR  . . . . . . . . . . . .	Number	 0016h	 
PHY_clkH_Read  . . . . . . . . .	Number	 00050000h   
PHY_clkH_Write_0 . . . . . . . .	Number	 00010000h   
PHY_clkH_Write_1 . . . . . . . .	Number	 00030000h   
PHY_clkL_Read  . . . . . . . . .	Number	 00040000h   
PHY_clkL_Write_0 . . . . . . . .	Number	 0000h	 
PHY_clkL_Write_1 . . . . . . . .	Number	 00020000h   
PICAckSlave  . . . . . . . . . .	Byte	 248B	  code	Public
PICIntMask . . . . . . . . . . .	Word	 2489	  code	Public
PICIntOff  . . . . . . . . . . .	Byte	 2487	  code	Public
PICIntOn . . . . . . . . . . . .	Byte	 2488	  code	Public
PNAPHY . . . . . . . . . . . . .	Number	 0002h	 
PNATYPE  . . . . . . . . . . . .	Byte	 1897	  code	Public
PerformAutoSenseMsg  . . . . . .	Byte	 19EA	  code	
PhysBlockSize  . . . . . . . . .	Word	 245B	  code	Public
Poll1st  . . . . . . . . . . . .	Byte	 0C44	  code	Public
PortConfigCR0  . . . . . . . . .	DWord	 1874	  code	Public
PortConfigCR15 . . . . . . . . .	DWord	 187C	  code	
PortConfigCR6  . . . . . . . . .	DWord	 1878	  code	Public
Prd_loop . . . . . . . . . . . .	L Near	 20F0	  code	
PreTxPollPtr . . . . . . . . . .	Word	 0C42	  code	Public
PreviousLinkStatus . . . . . . .	Word	 02EC	  code	
QuitDynamicAutoDetect  . . . . .	L Near	 1D9D	  code	
RCV_BUFFER_SIZE  . . . . . . . .	Number	 0620h	 
RCV_HDR_SIZE . . . . . . . . . .	Number	 001Ah	 
RDES0_K_FT_802 . . . . . . . . .	Number	 0000h	 
RDES0_K_FT_DIX . . . . . . . . .	Number	 0001h	 
RDES0_K_LBOM_EXTERNAL  . . . . .	Number	 0002h	 
RDES0_K_LBOM_INTERNAL  . . . . .	Number	 0001h	 
RDES0_K_LBOM_NORMAL  . . . . . .	Number	 0000h	 
RDES0_K_LBOM_RESERVED  . . . . .	Number	 0003h	 
RDES0_M_AE . . . . . . . . . . .	Number	 0004h	 
RDES0_M_BD . . . . . . . . . . .	Number	 0200h	 
RDES0_M_CE . . . . . . . . . . .	Number	 0002h	 
RDES0_M_DUE  . . . . . . . . . .	Number	 4000h	 
RDES0_M_ED . . . . . . . . . . .	Number	 0100h	 
RDES0_M_EFL  . . . . . . . . . .	Number	 0080h	 
RDES0_M_ES . . . . . . . . . . .	Number	 8000h	 
RDES0_M_FOE  . . . . . . . . . .	Number	 0001h	 
RDES0_M_FT . . . . . . . . . . .	Number	 0020h	 
RDES0_M_LBOM . . . . . . . . . .	Number	 3000h	 
RDES0_M_LCS  . . . . . . . . . .	Number	 0040h	 
RDES0_M_LENGTH . . . . . . . . .	Number	 7FFF0000h   
RDES0_M_MF . . . . . . . . . . .	Number	 0400h	 
RDES0_M_OWN  . . . . . . . . . .	Number	 -80000000h   
RDES0_M_PLE  . . . . . . . . . .	Number	 0008h	 
RDES0_M_RF . . . . . . . . . . .	Number	 0800h	 
RDES0_M_RXWT . . . . . . . . . .	Number	 0010h	 
RDES0_V_AE . . . . . . . . . . .	Number	 0002h	 
RDES0_V_BD . . . . . . . . . . .	Number	 0009h	 
RDES0_V_CE . . . . . . . . . . .	Number	 0001h	 
RDES0_V_DUE  . . . . . . . . . .	Number	 000Eh	 
RDES0_V_ED . . . . . . . . . . .	Number	 0008h	 
RDES0_V_EFL  . . . . . . . . . .	Number	 0007h	 
RDES0_V_ES . . . . . . . . . . .	Number	 000Fh	 
RDES0_V_FOE  . . . . . . . . . .	Number	 0000h	 
RDES0_V_FT . . . . . . . . . . .	Number	 0005h	 
RDES0_V_LBOM . . . . . . . . . .	Number	 000Ch	 
RDES0_V_LCS  . . . . . . . . . .	Number	 0006h	 
RDES0_V_LENGTH . . . . . . . . .	Number	 0010h	 
RDES0_V_MF . . . . . . . . . . .	Number	 000Ah	 
RDES0_V_OWN  . . . . . . . . . .	Number	 001Fh	 
RDES0_V_RF . . . . . . . . . . .	Number	 000Bh	 
RDES0_V_RXWT . . . . . . . . . .	Number	 0004h	 
RDES1_M_BL1  . . . . . . . . . .	Number	 07FFh	 
RDES1_M_BL2  . . . . . . . . . .	Number	 003FF800h   
RDES1_M_CE . . . . . . . . . . .	Number	 01000000h   
RDES1_M_EOR  . . . . . . . . . .	Number	 02000000h   
RDES1_V_BL1  . . . . . . . . . .	Number	 0000h	 
RDES1_V_BL2  . . . . . . . . . .	Number	 000Bh	 
RDES1_V_CE . . . . . . . . . . .	Number	 0018h	 
RDES1_V_EOR  . . . . . . . . . .	Number	 0019h	 
RED  . . . . . . . . . . . . . .	Number	 0004h	 
RSW_ReadBitx . . . . . . . . . .	L Near	 1793	  code	
RSW_ReadFailedx  . . . . . . . .	L Near	 17CC	  code	
RSW_WriteAddressBitx . . . . . .	L Near	 1759	  code	
RUNT . . . . . . . . . . . . . .	Number	 003Ch	 
RX_HANG_VALUE  . . . . . . . . .	Number	 0012h	 
RcvCurrentDescriptor . . . . . .	Word	 1028	  code	Public
RcvNumBuffers  . . . . . . . . .	Word	 1017	  code	Public
RcvSemaphore . . . . . . . . . .	Byte	 1027	  code	Public
RcvState . . . . . . . . . . . .	Word	 1025	  code	Public
Read_Register_PHY  . . . . . . .	L Near	 0000	  code	External
RxHangCheck  . . . . . . . . . .	L Near	 0BB7	  code	
RxHangCounter  . . . . . . . . .	Word	 02B0	  code	
RxNumOfHangs . . . . . . . . . .	Word	 02B4	  code	
SIA_Config_AutoFD  . . . . . . .	Number	 0004h	 
SIA_Config_Autodetect  . . . . .	Number	 0005h	 
SINGLE_PORT  . . . . . . . . . .	Text   	 
SM_RSTART_PG . . . . . . . . . .	Number	 0046h	 
SM_RSTOP_PG  . . . . . . . . . .	Number	 0080h	 
SM_TSTART_PG . . . . . . . . . .	Number	 0040h	 
SROMImage  . . . . . . . . . . .	Word	 188F	  code	
SROMPortFlag . . . . . . . . . .	Byte	 1892	  code	Public
SROM_93LC46B_LAST_ADDRESS_BIT  .	Number	 0006h	 
SROM_93LC46B_LAST_ADDRESS  . . .	Number	 003Fh	 
SROM_93LC46B_LEN . . . . . . . .	Number	 0040h	 
SROM_93LC46B_MAX_CYCLES  . . . .	Number	 0019h	 
SROM_ADAPTER0_OFF  . . . . . . .	Number	 001Ah	 
SROM_ADAPTER_COUNT_OFF . . . . .	Number	 0013h	 
SROM_ADDRESS_BIT_NUM . . . . . .	Number	 0006h	 
SROM_CHECKSUM_OFF  . . . . . . .	Number	 007Eh	 
SROM_CLK . . . . . . . . . . . .	Number	 0002h	 
SROM_COMM100 . . . . . . . . . .	Byte	 18AB	  code	
SROM_COMM10  . . . . . . . . . .	Byte	 18AA	  code	
SROM_COMMFD100 . . . . . . . . .	Byte	 18AD	  code	
SROM_COMMFD10  . . . . . . . . .	Byte	 18AC	  code	
SROM_CR9_READ  . . . . . . . . .	Number	 4000h	 
SROM_CR9_WRITE . . . . . . . . .	Number	 2000h	 
SROM_CS  . . . . . . . . . . . .	Number	 0001h	 
SROM_Corrupted_msg . . . . . . .	Byte	 1939	  code	
SROM_Count_not_One_msg . . . . .	Byte	 1986	  code	
SROM_DATA_0  . . . . . . . . . .	Number	 0000h	 
SROM_DATA_1  . . . . . . . . . .	Number	 0004h	 
SROM_Data_Read . . . . . . . . .	DWord	 16C6	  code	
SROM_FORMAT_OFF  . . . . . . . .	Number	 0012h	 
SROM_IEEE_OFF  . . . . . . . . .	Number	 0014h	 
SROM_MAX_DELAY . . . . . . . . .	Number	 0019h	 
SROM_M_Output_Data . . . . . . .	Number	 0008h	 
SROM_SEL_SROM  . . . . . . . . .	Number	 0800h	 
SROM_Version_not_msg . . . . . .	Byte	 1958	  code	
SROM_Word_Address  . . . . . . .	Word	 16C4	  code	
SW_CRC_MIN . . . . . . . . . . .	Number	 0090h	 
SW_ONE_PKT . . . . . . . . . . .	Text   	 
SYS_MCA  . . . . . . . . . . . .	Number	 0002h	 
Set_HOMERUN_LSpeed_1400  . . . .	L Near	 2267	  code	
Set_HOMERUN_LSpeed_1600  . . . .	L Near	 2283	  code	
Set_HOMERUN_LSpeed_500 . . . . .	L Near	 224B	  code	
Set_HOMERUN_LSpeed . . . . . . .	L Near	 2295	  code	
Set_LONGRUN_LSpeed_1400  . . . .	L Near	 2319	  code	
Set_LONGRUN_LSpeed_1600  . . . .	L Near	 2335	  code	
Set_LONGRUN_LSpeed_500 . . . . .	L Near	 22FD	  code	
Set_LONGRUN_LSpeed . . . . . . .	L Near	 2347	  code	
SetupFrame_fail_msg_len  . . . .	Number	 0031h	 
SetupFrame_fail_msg  . . . . . .	Byte	 1908	  code	
Srom_loop  . . . . . . . . . . .	L Near	 16D2	  code	
Syn_PHY  . . . . . . . . . . . .	L Near	 0000	  code	External
TDES0_M_CC . . . . . . . . . . .	Number	 0078h	 
TDES0_M_DE . . . . . . . . . . .	Number	 0001h	 
TDES0_M_EC . . . . . . . . . . .	Number	 0100h	 
TDES0_M_ES . . . . . . . . . . .	Number	 8000h	 
TDES0_M_FUE  . . . . . . . . . .	Number	 0002h	 
TDES0_M_HF . . . . . . . . . . .	Number	 0080h	 
TDES0_M_LC . . . . . . . . . . .	Number	 0200h	 
TDES0_M_LF . . . . . . . . . . .	Number	 0004h	 
TDES0_M_LOC  . . . . . . . . . .	Number	 0800h	 
TDES0_M_NC . . . . . . . . . . .	Number	 0400h	 
TDES0_M_OWN  . . . . . . . . . .	Number	 -80000000h   
TDES0_M_TXJT . . . . . . . . . .	Number	 4000h	 
TDES0_V_CC . . . . . . . . . . .	Number	 0003h	 
TDES0_V_DE . . . . . . . . . . .	Number	 0000h	 
TDES0_V_EC . . . . . . . . . . .	Number	 0008h	 
TDES0_V_ES . . . . . . . . . . .	Number	 000Fh	 
TDES0_V_FUE  . . . . . . . . . .	Number	 0001h	 
TDES0_V_HF . . . . . . . . . . .	Number	 0007h	 
TDES0_V_LC . . . . . . . . . . .	Number	 0009h	 
TDES0_V_LF . . . . . . . . . . .	Number	 0002h	 
TDES0_V_LOC  . . . . . . . . . .	Number	 000Bh	 
TDES0_V_NC . . . . . . . . . . .	Number	 000Ah	 
TDES0_V_OWN  . . . . . . . . . .	Number	 001Fh	 
TDES0_V_TXJT . . . . . . . . . .	Number	 000Eh	 
TDES1_M_BD . . . . . . . . . . .	Number	 20000000h   
TDES1_M_BL1  . . . . . . . . . .	Number	 07FFh	 
TDES1_M_BL2  . . . . . . . . . .	Number	 003FF800h   
TDES1_M_CAD  . . . . . . . . . .	Number	 04000000h   
TDES1_M_CE . . . . . . . . . . .	Number	 01000000h   
TDES1_M_CI . . . . . . . . . . .	Number	 -80000000h   
TDES1_M_DUMMY  . . . . . . . . .	Number	 01000000h   
TDES1_M_ED . . . . . . . . . . .	Number	 40000000h   
TDES1_M_EOR  . . . . . . . . . .	Number	 02000000h   
TDES1_M_FMB0 . . . . . . . . . .	Number	 00400000h   
TDES1_M_FMB1 . . . . . . . . . .	Number	 10000000h   
TDES1_M_PD . . . . . . . . . . .	Number	 00800000h   
TDES1_M_SETF . . . . . . . . . .	Number	 08000000h   
TDES1_V_BD . . . . . . . . . . .	Number	 001Dh	 
TDES1_V_BL1  . . . . . . . . . .	Number	 0000h	 
TDES1_V_BL2  . . . . . . . . . .	Number	 000Bh	 
TDES1_V_CAD  . . . . . . . . . .	Number	 001Ah	 
TDES1_V_CE . . . . . . . . . . .	Number	 0018h	 
TDES1_V_CI . . . . . . . . . . .	Number	 001Fh	 
TDES1_V_ED . . . . . . . . . . .	Number	 001Eh	 
TDES1_V_EOR  . . . . . . . . . .	Number	 0019h	 
TDES1_V_FMB0 . . . . . . . . . .	Number	 0016h	 
TDES1_V_FMB1 . . . . . . . . . .	Number	 001Ch	 
TDES1_V_PD . . . . . . . . . . .	Number	 0017h	 
TDES1_V_SETF . . . . . . . . . .	Number	 001Bh	 
TPFD_SIAConfig . . . . . . . . .	Number	 0000h	 
TP_SIAConfig . . . . . . . . . .	Number	 0001h	 
TWO_8259 . . . . . . . . . . . .	Number	 0040h	 
TX_HANG_VALUE  . . . . . . . . .	Number	 0012h	 
TYPE_INUSE . . . . . . . . . . .	Number	 000Ah	 
T_OPTION . . . . . . . . . . . .	Number	 0400h	 
TimerSemaphore . . . . . . . . .	Byte	 02EB	  code	
Timer_Exit . . . . . . . . . . .	L Near	 0C0F	  code	
TulipIntPosted . . . . . . . . .	Word	 18AE	  code	Public
TxHangCounter  . . . . . . . . .	Word	 02AE	  code	
TxNumOfHangs . . . . . . . . . .	Word	 02B2	  code	
TxPendingCnt . . . . . . . . . .	Word	 0C28	  code	Public
TxPollPtr  . . . . . . . . . . .	Word	 0C40	  code	Public
UM9100_GprCtrl . . . . . . . . .	Word	 18A0	  code	
UM9100_GprData100  . . . . . . .	Word	 18A4	  code	
UM9100_GprData10 . . . . . . . .	Word	 18A2	  code	
UM9100_GprDataFD100  . . . . . .	Word	 18A8	  code	
UM9100_GprDataFD10 . . . . . . .	Word	 18A6	  code	
UM9100_SROM_V0_1 . . . . . . . .	Number	 0001h	 
UM9100_SROM_V0_3 . . . . . . . .	Number	 0003h	 
U_OPTION . . . . . . . . . . . .	Number	 0010h	 
Update_ok  . . . . . . . . . . .	L Near	 1FA0	  code	
WHITE  . . . . . . . . . . . . .	Number	 000Fh	 
W_OPTION . . . . . . . . . . . .	Number	 0008h	 
WaitDelay10usLoop  . . . . . . .	L Near	 1807	  code	
WaitDelay419nsLoop . . . . . . .	L Near	 17E1	  code	
Write_Register_PHY . . . . . . .	L Near	 0000	  code	External
XF_OPTION  . . . . . . . . . . .	Number	 0100h	 
XH_OPTION  . . . . . . . . . . .	Number	 0080h	 
XMT_BUFFER_SIZE  . . . . . . . .	Number	 05F0h	 
XmtCRCThreshold  . . . . . . . .	Word	 0C30	  code	Public
XmtCurrentDescriptor . . . . . .	Word	 0C3E	  code	Public
XmtFrameSize . . . . . . . . . .	Word	 0C2E	  code	Public
XmtNumBuffers  . . . . . . . . .	Word	 0C2A	  code	Public
XmtState . . . . . . . . . . . .	Word	 0C2C	  code	Public
Xmt_block_reset_len  . . . . . .	Number	 0034h	 
Xmt_block_reset  . . . . . . . .	Byte	 02B6	  code	
YELLOW . . . . . . . . . . . . .	Number	 000Eh	 
abc_loop . . . . . . . . . . . .	L Near	 1C00	  code	
ability_100baset4  . . . . . . .	L Near	 1B25	  code	
ability_100basetx_FD . . . . . .	L Near	 1B0C	  code	
ability_100basetx  . . . . . . .	L Near	 1B3E	  code	
ability_10basefd . . . . . . . .	L Near	 1B57	  code	
ability_10base . . . . . . . . .	L Near	 1B70	  code	
ama_exit . . . . . . . . . . . .	L Near	 0FD6	  code	
ama_not_found  . . . . . . . . .	L Near	 0FB6	  code	
ama_success  . . . . . . . . . .	L Near	 0FD5	  code	
ama_vacancy  . . . . . . . . . .	L Near	 0FA8	  code	
anar . . . . . . . . . . . . . .	Word	 188D	  code	
anc_not_100m_full  . . . . . . .	L Near	 1D70	  code	
anc_not_100m_half  . . . . . . .	L Near	 1D5E	  code	
anc_not_10m_full . . . . . . . .	L Near	 1D4C	  code	
anc_not_10m_half . . . . . . . .	L Near	 1D3A	  code	
as_send_pkt  . . . . . . . . . .	L Near	 0196	  code	Public
auto_fail_default  . . . . . . .	L Near	 1AB9	  code	
bad_command_intercept  . . . . .	L Near	 0192	  code	Public
block_input  . . . . . . . . . .	L Near	 0024	  code	Public
blockin_exit . . . . . . . . . .	L Near	 0042	  code	
blockin_ext_loop . . . . . . . .	L Near	 003F	  code	
blockin_loop . . . . . . . . . .	L Near	 0031	  code	
board_data . . . . . . . . . . .	Byte	 0172	  code	Public
boutX  . . . . . . . . . . . . .	L Near	 0067	  code	
bout . . . . . . . . . . . . . .	L Near	 00D8	  code	Public
branding_msg . . . . . . . . . .	Byte	 A749	  code	Public
bytes_out  . . . . . . . . . . .	DWord	 0000	  code	External
capability_mismatch  . . . . . .	L Near	 1B89	  code	
cfg_cr15_exit  . . . . . . . . .	L Near	 2438	  code	
cfg_rx_flow_control  . . . . . .	L Near	 240C	  code	
cfg_tx_flow_control  . . . . . .	L Near	 2422	  code	
check_exit . . . . . . . . . . .	L Near	 1C7F	  code	
check_tx_pending . . . . . . . .	L Near	 0F66	  code	
chk_dm9009_exit  . . . . . . . .	L Near	 23F8	  code	
chk_sromportflag . . . . . . . .	L Near	 1A49	  code	
chk_sw_exit  . . . . . . . . . .	L Near	 23C3	  code	
copyright_msg  . . . . . . . . .	Byte	 A6FF	  code	Public
digitoutX  . . . . . . . . . . .	L Near	 0076	  code	
digitout_1X  . . . . . . . . . .	L Near	 0087	  code	
digitout_1 . . . . . . . . . . .	L Near	 00F3	  code	
digitout . . . . . . . . . . . .	L Near	 00E2	  code	Public
dm9009_chip_msg  . . . . . . . .	Byte	 0000	  code	External
dm9009_warning_msg . . . . . . .	Byte	 0000	  code	External
dm9100_version . . . . . . . . .	Number	 0000h	 
dm9102a_e3 . . . . . . . . . . .	Byte	 1884	  code	
do_anc . . . . . . . . . . . . .	L Near	 1F86	  code	
driver_class . . . . . . . . . .	Byte	 0008	  code	Public
driver_function  . . . . . . . .	Byte	 0015	  code	Public
driver_name  . . . . . . . . . .	Byte	 000D	  code	Public
driver_type  . . . . . . . . . .	Word	 000B	  code	Public
drop_pkt . . . . . . . . . . . .	L Near	 0197	  code	Public
dsi_phy  . . . . . . . . . . . .	L Near	 1BB4	  code	
dwoutX . . . . . . . . . . . . .	L Near	 0052	  code	
dwout  . . . . . . . . . . . . .	L Near	 00C3	  code	Public
end_free_mem . . . . . . . . . .	Byte	 26B0	  code	Public
end_resident . . . . . . . . . .	Byte	 26B0	  code	Public
endcfg . . . . . . . . . . . . .	Byte	 A6B0	  code	
errors_in  . . . . . . . . . . .	DWord	 0000	  code	External
errors_out . . . . . . . . . . .	DWord	 0000	  code	External
espna  . . . . . . . . . . . . .	L Near	 1C37	  code	
etopen_diagn . . . . . . . . . .	Byte	 0000	  code	External
etopen_exit  . . . . . . . . . .	L Near	 A6FC	  code	
etopen . . . . . . . . . . . . .	L Near	 A6B1	  code	Public
execute_autosense  . . . . . . .	L Near	 0B6A	  code	
fcrx . . . . . . . . . . . . . .	Byte	 1881	  code	Public
fctx . . . . . . . . . . . . . .	Byte	 1882	  code	Public
find_partner_speed . . . . . . .	L Near	 1BB4	  code	
flagword . . . . . . . . . . . .	Word	 0000	  code	External
fnet_not_1m_home_pna . . . . . .	L Near	 1A2E	  code	
fnet_pci_enet_rom_read . . . . .	L Near	 1DB9	  code	
fnet_set_full_duplex . . . . . .	L Near	 1A5B	  code	
fnet_set_half_duplex . . . . . .	L Near	 1A50	  code	
fnet_verify_version  . . . . . .	L Near	 1DD6	  code	
force_duplex . . . . . . . . . .	L Near	 1BDF	  code	
force_media_type . . . . . . . .	L Near	 1BD2	  code	
full_sw_adapt  . . . . . . . . .	L Near	 23AC	  code	
get_number . . . . . . . . . . .	L Near	 0000	  code	External
good_pkt_1 . . . . . . . . . . .	L Near	 119E	  code	
gosetcr16  . . . . . . . . . . .	L Near	 21D1	  code	
half_sw_adapt  . . . . . . . . .	L Near	 239A	  code	
hr_set_speed . . . . . . . . . .	L Near	 222F	  code	
ieee_byte_loop . . . . . . . . .	L Near	 1DEB	  code	
im_chain . . . . . . . . . . . .	L Near	 258D	  code	
im_clear . . . . . . . . . . . .	L Near	 2596	  code	
im_exit_after  . . . . . . . . .	L Near	 2689	  code	
im_exit  . . . . . . . . . . . .	L Near	 267F	  code	
im_isrdone . . . . . . . . . . .	L Near	 26A1	  code	
im_our_int . . . . . . . . . . .	L Near	 2611	  code	
im_posted_int  . . . . . . . . .	L Near	 25DA	  code	
int_no_name  . . . . . . . . . .	Byte	 A776	  code	
int_no . . . . . . . . . . . . .	Byte	 0000	  code	Public
int_num  . . . . . . . . . . . .	Word	 0022	  code	
interval_rx_cnt  . . . . . . . .	Word	 02AC	  code	Public
io_addr_name . . . . . . . . . .	Byte	 A788	  code	
io_addr  . . . . . . . . . . . .	Word	 0004	  code	Public
is_186 . . . . . . . . . . . . .	Byte	 0000	  code	External
its_dm9009 . . . . . . . . . . .	L Near	 23DE	  code	
legacy . . . . . . . . . . . . .	Byte	 18B0	  code	
linereturnX  . . . . . . . . . .	L Near	 00A7	  code	
linereturn . . . . . . . . . . .	L Near	 0100	  code	
majver . . . . . . . . . . . . .	Number	 0001h	 
mcast_all_flag . . . . . . . . .	Byte	 0147	  code	Public
mcast_list_bits  . . . . . . . .	Byte	 013F	  code	Public
my_address . . . . . . . . . . .	Byte	 0000	  code	External
not_sw_adapt . . . . . . . . . .	L Near	 23BE	  code	
only_loop  . . . . . . . . . . .	L Near	 01B8	  code	
our_stack  . . . . . . . . . . .	Byte	 0000	  code	External
out_of_resource_exit . . . . . .	L Near	 0F58	  code	
pCR6_exit  . . . . . . . . . . .	L Near	 212B	  code	
pCR6_write_CR6 . . . . . . . . .	L Near	 2125	  code	
p_CR0  . . . . . . . . . . . . .	Word	 245D	  code	Public
p_CR10 . . . . . . . . . . . . .	Word	 2471	  code	Public
p_CR11 . . . . . . . . . . . . .	Word	 2473	  code	Public
p_CR12 . . . . . . . . . . . . .	Word	 2475	  code	Public
p_CR13 . . . . . . . . . . . . .	Word	 2477	  code	Public
p_CR14 . . . . . . . . . . . . .	Word	 2479	  code	Public
p_CR15 . . . . . . . . . . . . .	Word	 247B	  code	Public
p_CR1  . . . . . . . . . . . . .	Word	 245F	  code	Public
p_CR2  . . . . . . . . . . . . .	Word	 2461	  code	Public
p_CR3  . . . . . . . . . . . . .	Word	 2463	  code	Public
p_CR4  . . . . . . . . . . . . .	Word	 2465	  code	Public
p_CR5  . . . . . . . . . . . . .	Word	 2467	  code	Public
p_CR6  . . . . . . . . . . . . .	Word	 2469	  code	Public
p_CR7  . . . . . . . . . . . . .	Word	 246B	  code	Public
p_CR8  . . . . . . . . . . . . .	Word	 246D	  code	Public
p_CR9  . . . . . . . . . . . . .	Word	 246F	  code	Public
p_PCICS  . . . . . . . . . . . .	Word	 247F	  code	Public
p_PCIID  . . . . . . . . . . . .	Word	 247D	  code	Public
p_PCIIO  . . . . . . . . . . . .	Word	 2485	  code	Public
p_PCILT  . . . . . . . . . . . .	Word	 2483	  code	Public
p_PCIRV  . . . . . . . . . . . .	Word	 2481	  code	Public
p_PHY24  . . . . . . . . . . . .	Word	 1869	  code	Public
p_PhysBlockPhys  . . . . . . . .	DWord	 2457	  code	Public
p_PhysBlockVirt  . . . . . . . .	Word	 2455	  code	Public
p_RcvBlockPhys . . . . . . . . .	DWord	 101B	  code	Public
p_RcvBlockVirt . . . . . . . . .	Word	 1019	  code	Public
p_RcvRingPhys  . . . . . . . . .	DWord	 1021	  code	Public
p_RcvRingVirt  . . . . . . . . .	Word	 101F	  code	Public
p_XmtBlockPhys . . . . . . . . .	DWord	 0C36	  code	Public
p_XmtBlockVirt . . . . . . . . .	Word	 0C32	  code	Public
p_XmtRingPhys  . . . . . . . . .	DWord	 0C3A	  code	Public
p_XmtRingVirt  . . . . . . . . .	Word	 0C34	  code	Public
packets_out  . . . . . . . . . .	DWord	 0000	  code	External
pad_loop . . . . . . . . . . . .	L Near	 029B	  code	
parallel_detect_PHY_100MB  . . .	L Near	 1BC2	  code	
parallel_detect_PHY_10MB . . . .	L Near	 1BCA	  code	
parameter_list . . . . . . . . .	Byte	 0016	  code	Public
parse_args . . . . . . . . . . .	L Near	 A792	  code	Public
partner_NWAY_capable . . . . . .	L Near	 1AF8	  code	
partner_NWAY_incapable . . . . .	L Near	 1BA7	  code	
pcol . . . . . . . . . . . . . .	Byte	 0048	  code	Public
pcursor  . . . . . . . . . . . .	Byte	 0047	  code	Public
pd_loop  . . . . . . . . . . . .	L Near	 1F64	  code	
pesf_done  . . . . . . . . . . .	L Near	 200D	  code	
pesf_exit  . . . . . . . . . . .	L Near	 2028	  code	
pesf_loop  . . . . . . . . . . .	L Near	 1FF9	  code	
pi_copy_IEEE_address . . . . . .	L Near	 1DF7	  code	
pi_done  . . . . . . . . . . . .	L Near	 1A66	  code	
pi_init_current_addr . . . . . .	L Near	 1DF1	  code	
pi_port_reset  . . . . . . . . .	L Near	 1F99	  code	
pi_ret . . . . . . . . . . . . .	L Near	 1FA1	  code	
pi_set_CR6 . . . . . . . . . . .	L Near	 1F96	  code	
pm_exit  . . . . . . . . . . . .	L Near	 2113	  code	
pm_loop  . . . . . . . . . . . .	L Near	 210C	  code	
pna_cr16 . . . . . . . . . . . .	Word	 1867	  code	Public
pna_cr29 . . . . . . . . . . . .	Word	 1887	  code	
pna_cr30 . . . . . . . . . . . .	Word	 1889	  code	
pna_cr31 . . . . . . . . . . . .	Word	 188B	  code	
pna_power_cmd  . . . . . . . . .	Word	 186C	  code	Public
pna_speed_cmd  . . . . . . . . .	Word	 186E	  code	Public
pnaphy_rev . . . . . . . . . . .	Byte	 1883	  code	
pr_CR12_data . . . . . . . . . .	L Near	 20D0	  code	
pr_fnet_100  . . . . . . . . . .	L Near	 20C3	  code	
pr_loop  . . . . . . . . . . . .	L Near	 2056	  code	
pr_skip_configs  . . . . . . . .	L Near	 206C	  code	
pr_write_CR6 . . . . . . . . . .	L Near	 1292	  code	
pr_xmt_rcv_reset . . . . . . . .	L Near	 20DE	  code	
print_number . . . . . . . . . .	L Near	 0000	  code	External
print_parameters . . . . . . . .	L Near	 A7A0	  code	Public
printmsg . . . . . . . . . . . .	L Near	 0000	  code	External
purf_done  . . . . . . . . . . .	L Near	 0291	  code	
purf_exit  . . . . . . . . . . .	L Near	 02A9	  code	
purf_loop  . . . . . . . . . . .	L Near	 027C	  code	
rcv_copy_deferred  . . . . . . .	L Near	 1227	  code	
rcv_copy_ok  . . . . . . . . . .	L Near	 121F	  code	
rcv_hdr  . . . . . . . . . . . .	Byte	 0158	  code	
rcv_mode_1 . . . . . . . . . . .	L Near	 0199	  code	Public
rcv_mode_2 . . . . . . . . . . .	L Near	 01AD	  code	Public
rcv_mode_3 . . . . . . . . . . .	L Near	 01CD	  code	Public
rcv_mode_4 . . . . . . . . . . .	L Near	 01F2	  code	
rcv_mode_5 . . . . . . . . . . .	L Near	 0207	  code	
rcv_mode_6 . . . . . . . . . . .	L Near	 022C	  code	
rcv_mode_num . . . . . . . . . .	Word	 0000	  code	External
rcv_modes  . . . . . . . . . . .	Word	 0148	  code	Public
rcv_no_copy  . . . . . . . . . .	L Near	 1225	  code	
re_nopr  . . . . . . . . . . . .	L Near	 128E	  code	
read_loop  . . . . . . . . . . .	L Near	 1818	  code	
recv_copy  . . . . . . . . . . .	L Near	 0000	  code	External
recv_exiting_exit  . . . . . . .	L Near	 0000	  code	External
recv_find  . . . . . . . . . . .	L Near	 0000	  code	External
resend_remote_cmd_cnt  . . . . .	Byte	 1870	  code	Public
resend_remote_cmd_timer  . . . .	Word	 1871	  code	Public
restore_cr6  . . . . . . . . . .	L Near	 1E61	  code	
rinit_loop . . . . . . . . . . .	L Near	 1092	  code	
rinit_return_bytes_used  . . . .	L Near	 10F6	  code	
rm_chk_err . . . . . . . . . . .	L Near	 11B6	  code	
rm_exit  . . . . . . . . . . . .	L Near	 122E	  code	
rm_fmc_stat_ok . . . . . . . . .	L Near	 11D8	  code	
rm_loop  . . . . . . . . . . . .	L Near	 1174	  code	
rm_not_crc_err . . . . . . . . .	L Near	 11D3	  code	
rm_not_mcast . . . . . . . . . .	L Near	 11DB	  code	
rm_reentered . . . . . . . . . .	L Near	 1233	  code	
rom_address  . . . . . . . . . .	Byte	 0000	  code	External
rreset_loop  . . . . . . . . . .	L Near	 111A	  code	
rs_exit  . . . . . . . . . . . .	L Near	 184B	  code	
rx_flow_control_enable . . . . .	L Near	 2419	  code	
rx_int . . . . . . . . . . . . .	L Near	 266B	  code	
save_int_sp  . . . . . . . . . .	Word	 2577	  code	Public
save_int_ss  . . . . . . . . . .	Word	 2575	  code	Public
schedule_exiting . . . . . . . .	L Near	 0000	  code	External
send_pkt_toobig  . . . . . . . .	L Near	 0F58	  code	
send_remote_cmd  . . . . . . . .	Byte	 186B	  code	Public
sendsetup_ok . . . . . . . . . .	L Near	 201D	  code	
set_BMCR . . . . . . . . . . . .	L Near	 1BEA	  code	
set_CR6  . . . . . . . . . . . .	L Near	 1C11	  code	
set_int_num  . . . . . . . . . .	L Near	 A6F6	  code	
set_recv_isr . . . . . . . . . .	L Near	 0000	  code	External
slr  . . . . . . . . . . . . . .	L Near	 1C34	  code	
snm_check_next . . . . . . . . .	L Near	 1008	  code	
snm_exit . . . . . . . . . . . .	L Near	 1013	  code	
snm_loop . . . . . . . . . . . .	L Near	 0FED	  code	
snm_not_found_exit . . . . . . .	L Near	 1010	  code	
srom_ieee  . . . . . . . . . . .	L Near	 1DD6	  code	
srom_v300_chk_sw . . . . . . . .	L Near	 2385	  code	
srom_v401_chk_sw . . . . . . . .	L Near	 2377	  code	
stack_buf  . . . . . . . . . . .	Word	 02F0	  code	
stack_top  . . . . . . . . . . .	Word	 0AF0	  code	
switch_adapter . . . . . . . . .	Byte	 1873	  code	Public
swreset_ok . . . . . . . . . . .	L Near	 2066	  code	
tc_begin . . . . . . . . . . . .	L Near	 0E93	  code	
tc_buffer_available  . . . . . .	L Near	 0EB3	  code	
tc_copy  . . . . . . . . . . . .	L Near	 0ECC	  code	
tc_owner_check . . . . . . . . .	L Near	 0EA6	  code	
tc_post_frame  . . . . . . . . .	L Near	 0EF2	  code	
terminate  . . . . . . . . . . .	L Near	 02AB	  code	Public
their_isr  . . . . . . . . . . .	DWord	 0000	  code	External
their_stack  . . . . . . . . . .	DWord	 0AF0	  code	
their_timer  . . . . . . . . . .	DWord	 0000	  code	External
timer_isr_main . . . . . . . . .	L Near	 0B1A	  code	
timer_isr  . . . . . . . . . . .	L Near	 0AF4	  code	Public
tx_flow_control_enable . . . . .	L Near	 242F	  code	
tx_int . . . . . . . . . . . . .	L Near	 2637	  code	
usage_msg  . . . . . . . . . . .	Byte	 A74A	  code	Public
use_internal_phy . . . . . . . .	L Near	 1A40	  code	
version  . . . . . . . . . . . .	Number	 0004h	 
vlan_enable  . . . . . . . . . .	L Near	 2406	  code	
vlan . . . . . . . . . . . . . .	Byte	 1880	  code	Public
wbout  . . . . . . . . . . . . .	L Near	 0114	  code	
wdigitout_1  . . . . . . . . . .	L Near	 013E	  code	
wdigitout  . . . . . . . . . . .	L Near	 011E	  code	
woutX  . . . . . . . . . . . . .	L Near	 0060	  code	
wout . . . . . . . . . . . . . .	L Near	 00D1	  code	Public
xi_continue  . . . . . . . . . .	L Near	 0C68	  code	
xi_dont_gen_crc  . . . . . . . .	L Near	 0C61	  code	
xinit_loop . . . . . . . . . . .	L Near	 0CBF	  code	
xinit_return_bytes_used  . . . .	L Near	 0D23	  code	
xm_exit  . . . . . . . . . . . .	L Near	 0F8C	  code	
xmit . . . . . . . . . . . . . .	L Near	 0198	  code	Public
xmt_done . . . . . . . . . . . .	L Near	 0F4C	  code	
xmt_fail . . . . . . . . . . . .	L Near	 0F51	  code	Public
xmt_no_err . . . . . . . . . . .	L Near	 0EC1	  code	
xmt_post . . . . . . . . . . . .	L Near	 0F35	  code	
xreset_loop  . . . . . . . . . .	L Near	 0D5D	  code	
xsdf_loop_done . . . . . . . . .	L Near	 0E86	  code	
xsdf_wait  . . . . . . . . . . .	L Near	 0E7A	  code	
xssf_loop_done . . . . . . . . .	L Near	 0E33	  code	
xssf_wait  . . . . . . . . . . .	L Near	 0E27	  code	

	   0 Warnings
	   0 Errors
