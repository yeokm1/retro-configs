Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:39
.\tail.asm						     Page 1 - 1


				;*****************************************************************************
				;* Name : TAIL.ASM
				;*
				;* All rights reserved by DAVICOM, 1996
				;*
				;* Description : Process DOS & hardware interface, include:
				;*	. Hardware resource decide.(IRQ, I/O)
				;*	. Initializes DM9100 ethernet card.
				;*	. Parsing parameters & options.
				;*	. Setup interrupt vector.
				;*	. Resident code in the memory.
				;*
				;* Functions :
				;*
				;* Author : Spenser Tsai
				;*
				;* Date : 05/17/96'
				;*
				;* Change Notes :
				;* Date - Modifier
				;*     Cause :
				;*  Modified :
				;*    Result :
				;*
				; Maintainers:
				;
				; John H.T. Ho		htho
				;
				;
				; Revision History:
				;
				; Date	     Modfier.	Modification Descriptions
				; ---------- ---------- ------------------------------------------
				; 2000.6.21	htho	set speed/power for HOMEPNA
				;
				; 2000.6.27	htho	set ignore/send remote command for HOMEPNA
				;
				; 2000.8.24	htho	support DM9009(DM9102 without 100M PHY capability)
				;			support VLAN & Tx/Rx flow control
				;
				; 2001.3.30	htho	support HPNA speed setting
				;
				; 2001.6.12	htho	command line option bug -x
				;
				; 2001.6.21	htho	revise phy duplex mode display while force mode
				;
				;*****************************************************************************
				.model	tiny
				.386
					include defs.asm
			      C ;;*******************************************************
			      C ;* Program name : DEFS.ASM
			      C ;* Modified By : Spenser Tsai
			      C ;* Date : 10/04/97' (DAVICOM)
			      C ;********************************************************
 = 0001			      C majver		equ	MAJ_VER 	;version number of the infrastructure.
			      C 
 = 0004			      C version 	equ	MIN_VER 	;Major Version number of the program
			      C 
 = 0000			      C dm9100_version	equ	GEN_VER 	;version number of the generic 9100 driver.
			      C 
 = 0010			      C MAX_ADDR_LEN	equ	16		;maximum number of bytes in our address.
			      C 
 = 000A			      C MAX_HANDLE	equ	10		;maximum number of handles.
			      C 
 = 0008			      C MAX_P_LEN	equ	8		;maximum type length
			      C 
			      C ;;MAX_MULTICAST   equ	  8		  ;maximum number of multicast addresses.
 = 000E			      C MAX_MULTICAST	equ	14		 ;maximum number of multicast addresses.
			      C 
			      C ;  Copyright, 1988-1992, Russell Nelson, Crynwr Software
			      C 
			      C ;   This program is free software; you can redistribute it and/or modify
			      C ;   it under the terms of the GNU General Public License as published by
			      C ;   the Free Software Foundation, version 1.
			      C ;
			      C ;   This program is distributed in the hope that it will be useful,
			      C ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
			      C ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
			      C ;   GNU General Public License for more details.
			      C ;
			      C ;   You should have received a copy of the GNU General Public License
			      C ;   along with this program; if not, write to the Free Software
			      C ;   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
			      C 
 = 0009			      C HT	equ	09h
 = 000D			      C CR	equ	0dh
 = 000A			      C LF	equ	0ah
			      C 
			      C ;
			      C ;  Packet Driver Error numbers
 = 0000			      C NO_ERROR	equ	0		;no error at all.
			      C   ifndef SMCINC
 = 0001			      C BAD_HANDLE	equ	1		;invalid handle number
			      C   endif
 = 0002			      C NO_CLASS	equ	2		;no interfaces of specified class found
 = 0003			      C NO_TYPE 	equ	3		;no interfaces of specified type found
 = 0004			      C NO_NUMBER	equ	4		;no interfaces of specified number found
			      C   ifndef SMCINC
 = 0005			      C BAD_TYPE	equ	5		;bad packet type specified
			      C   endif
 = 0006			      C NO_MULTICAST	equ	6		;this interface does not support
			      C 					;multicast
 = 0007			      C CANT_TERMINATE	equ	7		;this packet driver cannot terminate
 = 0008			      C BAD_MODE	equ	8		;an invalid receiver mode was specified
 = 0009			      C NO_SPACE	equ	9		;operation failed because of
			      C 					;insufficient space
 = 000A			      C TYPE_INUSE	equ	10		;the type had previously been accessed,
			      C 					;and not released.
 = 000B			      C BAD_COMMAND	equ	11		;the command was out of range, or not
			      C 					;implemented
 = 000C			      C CANT_SEND	equ	12		;the packet couldn't be sent (usually
			      C 					;hardware error)
 = 000D			      C CANT_SET	equ	13		;hardware address couldn't be changed
			      C 					;(more than 1 handle open)
 = 000E			      C BAD_ADDRESS	equ	14		;hardware address has bad length or
			      C 					;format
 = 000F			      C CANT_RESET	equ	15		;Couldn't reset interface (more than
			      C 					;1 handle open).
 = 0010			      C BAD_IOCB	equ	16		;an invalid iocb was specified
			      C 
			      C ;a few useful Ethernet definitions.
 = 003C			      C RUNT		equ	60		;smallest legal size packet, no fcs
 = 05EA			      C GIANT		equ	1514		;largest legal size packet, no fcs
 = 0006			      C EADDR_LEN	equ	6		;Ethernet address length.
 = 0001			      C ARCADDR_LEN	equ	1
			      C 
 = 0001			      C BLUEBOOK	equ	1
 = 000B			      C IEEE8023	equ	11
			      C 
			      C 
			      C ;this macro does a "rep movsb" with a static count.
			      C repmov	macro	count
			      C 	rept	(count) / 2
			      C 	movsw
			      C 	endm
			      C 	rept	(count) MOD 2
			      C 	movsb
			      C 	endm
			      C 	endm
			      C 
			      C ;moves a segment register into another segment register.
			      C movseg	macro	to, from
			      C 	push	from
			      C 	pop	to
			      C 	endm
			      C 
			      C ;add a word to a dword.
			      C add2	macro	n,a			; inc a 32 bit integer
			      C 	add	n.offs,a		;increment the low word
			      C 	adc	n.segm,0		;increment the high word
			      C 	endm
			      C 
			      C ;this macro writes the given character to the given row and column on
			      C ;  an CGA.
			      C to_scrn macro	r, c, ch
			      C 	local	again
			      C 	push	bx
			      C 	push	es
			      C 	mov	bx,0b800h
			      C 	mov	es,bx
			      C 	mov	bx,es:[r*160+c*2]
			      C again:
			      C 	inc	bh
			      C 	and	bh,07h
			      C 	je	again			;; don't use black.
			      C 	mov	bl,ch
			      C 	mov	es:[r*160+c*2],bx
			      C 	pop	es
			      C 	pop	bx
			      C 	endm
			      C 
			      C 
			      C 
 0004			      C segmoffs	struc			; defines offs as 0, segm as 2
 0000  0000		      C offs		dw	?
 0002  0000		      C segm		dw	?
			      C segmoffs	ends
			      C 
 = 0001			      C CY	equ	0001h
 = 0200			      C EI	equ	0200h
			      C 
 0014			      C iocb		struc			; as_send_pkt structure
 0000  00000000		      C   buffer	  dd	  ?		  ; Pointer to the buffer
 0004  0000		      C   len		  dw	  ?		  ; Its length
 0006  00		      C   flags 	  db	  ?		  ; Some flags
 0007  00		      C   ret_code	  db	  ?		  ; Completion code
 0008  00000000		      C   upcall	  dd	  ?		  ; I/O completion upcall
 000C  00000000		      C   next		  dd	  ?		  ; Private next pointer (queue)
 0010  0004 [		      C   resv		  db	  4 dup (?)	  ; Unused private data
        00
       ]
			      C iocb		ends
			      C 
 = 0001			      C DONE	equ	1		; I/O complete flag
 = 0002			      C CALLME	equ	2		; Please upcall me flag
			      C 
			      C 
			      C send_queueempty macro
			      C ; Check if send queue is empty.
			      C ; Enter with interrupts disabled.
			      C ; Exit with zr (zero) if empty, nz (not zero) if not.
			      C ; Destroys ax.
			      C 	mov ax, word ptr send_head	; Queue empty?
			      C 	or ax,	word ptr send_head+2
			      C 	endm
			      C 
			      C send_peekqueue	macro
			      C ; Peek into the queue and get the next entry.
			      C ; Enter with interrupts disabled.
			      C ; Exit with es:di -> iocb.
			      C 	les di, send_head	; Get head segment:offset
			      C 	endm
			      C 
			      C ; Bits in sys_features
 = 0002			      C SYS_MCA equ	02		; a micro channel computer
 = 0040			      C TWO_8259	equ	40h		; 2nd 8259 exists
			      C 
			      C ; Bits in flagbyte
 = 0001			      C CALLED_ETOPEN	equ	1		; have called etopen
 = 0002			      C D_OPTION	equ	2		; delayed initialization
 = 0004			      C N_OPTION	equ	4		; Novell protocol conversion
 = 0008			      C W_OPTION	equ	8		; Windows upcall checking.
 = 0010			      C U_OPTION	equ	10h		; Terminate the driver.
			      C ;;-+
			      C ;;S_OPTION	  EQU	  20h		  ; 10Mb Speed
			      C ;;F_OPTION	  EQU	  40h		  ; Full Duplex
			      C ;;SF_OPTION	  EQU	  60h		  ; Selected speed & mode
			      C ;;XS_OPTION	  EQU	  80h		  ; 100Mb Speed
			      C ;;A_OPTION	  EQU	  100h		  ; Auto-Negotination & Full-Duplex
			      C ;;AF_OPTION	  EQU	  140h		  ; Full Duplex
 = 0020			      C H_OPTION	EQU	20h		; 10Mb Half Duplex
 = 0040			      C F_OPTION	EQU	40h		; 10Mb Full Duplex
 = 0080			      C XH_OPTION	EQU	80h		; 100Mb Half Duplex
 = 0100			      C XF_OPTION	EQU	100h		; 100Mb Full Duplex
 = 0200			      C A_OPTION	EQU	200h		; Auto-Negotiation
 = 0400			      C T_OPTION	EQU	400h		; HomePNA
			      C ;;-+
 = 0200			      C B_OPTION	EQU	200h		; BNC
			      C 
 0005			      C table_multicast       struc
 0000  0000		      C   table_maxnum	    dw	    0	    ; max number of multicast addresses
 0002  0000		      C   table_current     dw	    0	    ; current number of multicast addresses
 0004  00		      C   table_multiaddr   db	    0	    ; 16 byte sets of multicast addresses
			      C table_multicast       ends
			      C  
			      C 
 0000				code	segment para public
					assume	cs:code, ds:code

				;;++
				;;++, 2000.1.31, hu-tiong
				;IFDEF	 DEBUGDOS
				;extrn	 init_debug: near
				include debug.inc
			      C IFDEF	DEBUGDOS
			      C ENDIF
			      C 
			      C ;-- Cloor Attribute Definitions
			      C ;------------------------------------------------------------------------
 = 0000			      C BLACK		EQU	0		; dark colors
 = 0001			      C BLUE		EQU	1
 = 0002			      C GREEN		EQU	2
 = 0003			      C CYAN		EQU	3
 = 0004			      C RED		EQU	4
 = 0005			      C MAGENTA 	EQU	5
 = 0006			      C BROWN		EQU	6
 = 0007			      C DARKGRAY	EQU	7
 = 0008			      C LIGHTGRAY	EQU	8		; light colors
 = 0009			      C LIGHTBLUE	EQU	9
 = 000A			      C LIGHTGREEN	EQU	10
 = 000B			      C LIGHTCYAN	EQU	11
 = 000C			      C LIGHTRED	EQU	12
 = 000D			      C LIGHTMAGENTA	EQU	13
 = 000E			      C YELLOW		EQU	14
 = 000F			      C WHITE		EQU	15
			      C 
			      C ;-- Macro Definitions
			      C ;------------------------------------------------------------------------
			      C BRUSH_CHAR	macro	ch
			      C IFDEF	DEBUGDOS
			      C 	push	ax
			      C 	mov	al, ch
			      C 	call	b_char
			      C 	pop	ax
			      C ENDIF
			      C 	endm
			      C 
			      C BRUSH_BYTE	macro	bdata
			      C IFDEF	DEBUGDOS
			      C 	push	ax
			      C 	mov	al, bdata
			      C 	call	b_byte
			      C 	pop	ax
			      C ENDIF
			      C 	endm
			      C 
			      C DISP_CHAR	macro	ch, attr, x, y
			      C IFDEF	DEBUGDOS
			      C 	push	ax
			      C 	push	bx
			      C 	push	dx
			      C 
			      C 	mov	dl, x
			      C 	mov	dh, y
			      C 	mov	bh, attr
			      C 	mov	al, ch
			      C 	call	d_char
			      C 
			      C 	pop	dx
			      C 	pop	bx
			      C 	pop	ax
			      C ENDIF
			      C 	endm
			      C 
			      C DISP_BYTE	macro	bdata, attr, x, y
			      C IFDEF	DEBUGDOS
			      C 	push	ax
			      C 	push	bx
			      C 	push	dx
			      C 
			      C 	mov	dl, x
			      C 	mov	dh, y
			      C 	mov	bh, attr
			      C 	mov	al, bdata
			      C 	call	d_byte
			      C 
			      C 	pop	dx
			      C 	pop	bx
			      C 	pop	ax
			      C ENDIF
			      C 	endm
			      C 
			      C  
			      C 
				;ENDIF
				;;++
				extrn	initpci: near
				extrn	io_addr: word
				EXTRN	InitPIDataRate : WORD
				EXTRN	SROMPortFlag : BYTE
				EXTRN	p_CR0 : WORD
					extrn	int_no: byte		;the board's interrupt level.
					extrn	driver_class: byte	;the class of this driver, per the spec.
					extrn	rcv_modes: word 	;count of modes followed by mode handles.
					EXTRN	rcv_mode_num : WORD

				;-> last byte of static memory used by driver-dependent code.
					extrn	end_resident: byte
					extrn	end_free_mem: byte

				;-> the fixed address of the card.
					extrn	rom_address: byte

				;-> the current address of the card.
					extrn	my_address: byte

					extrn	phd_dioa: byte
					extrn	phd_environ: word
					extrn	flagword: WORD
				;;++, 2000.6.21, htho, set speed/power for HOMEPNA
				ifdef HOMEPNA
					extrn	pna_cr16: word
				endif
				;;++
				;;;;++, 2000.6.27, htho, support tx remote command
					extrn	pna_power_cmd: word
					extrn	pna_speed_cmd: word
				;;;;++
				;;;;++, 2000.8.24, htho, support VLAN & Tx/Rx flow control
					extrn	vlan: byte
					extrn	fctx: byte
					extrn	fcrx: byte
				;;;;++

				;;++, 2001.3.30, htho, support HPNA speed setting
					extrn	LSpeedNum: word
				;;++

					PUBLIC	free_mem
 0000 0000 E			free_mem	dw	end_resident	;allocate memory from here.
				;also see memory_to_keep.

					include pktutil.asm		;; Parsing & print parameters
			      C 
			      C ;--------------------------------------------------------------------+
			      C ; Name : skip_blanks
			      C ;
			      C ; Description: Pointer to 1st that it is not space charater.
			      C ;
			      C ; Enter :
			      C ;       DS:SI -> point to string.
			      C ;
			      C ; Return :
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C         public  skip_blanks
 0002			      C skip_blanks:
 0002  AC		      C         lodsb                           ;skip blanks.
 0003  3C 20		      C         cmp     al,' '
 0005  74 FB		      C         je      skip_blanks
 0007  3C 09		      C         cmp     al, 09h                 ;; HT = 09h(TAB)
 0009  74 F7		      C         je      skip_blanks
 000B  4E		      C         dec     si
 000C  C3		      C         ret
			      C 
			      C ;--------------------------------------------------------------------+
			      C ; Name : get_number
			      C ;
			      C ; Description: Get a hex number, skipping leading blanks.
			      C ;
			      C ; Enter :
			      C ;       SI -> string of digits.
			      C ;       DI -> DWORD to store th number in.
			      C ;
			      C ; Return :
			      C ;       Carray flag set : There are no digits, [di] in not modified.
			      C ;       Carray flag reset : BX:CX = number, and store BX:CX at [di].
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C         public  get_number
 000D			      C get_number:
 000D  BD 000A		      C         mov     bp,10                   ;we default to 10.
 0010  EB 03		      C         jmp     short get_number_0
			      C 
			      C         public  get_hex
 0012			      C get_hex:
 0012  BD 0010		      C         mov     bp,16
			      C 
 0015			      C get_number_0:
 0015  E8 FFEA		      C         call    skip_blanks
 0018  E8 005F		      C         call    get_digit               ;is there really a number here?
			      C                                         ;; Return AL with hex.
 001B  72 4C		      C         jc      get_number_3            ;; Not digital
 001D  32 E4		      C         xor     ah,ah
 001F  3B C5		      C         cmp     ax,bp                   ;larger than our base?
 0021  73 46		      C         jae     get_number_3            ;yes.
 0023  0A C0		      C         or      al,al                   ;Does the number begin with zero?
 0025  75 03		      C         jne     get_number_4            ;no.
 0027  BD 0008		      C         mov     bp,8                    ;yes - they want octal.
 002A			      C get_number_4:
 002A  33 C9		      C         xor     cx,cx                   ;get a hex number.
 002C  33 DB		      C         xor     bx,bx
 002E			      C get_number_1:
 002E  AC		      C         lodsb
 002F  3C 78		      C         cmp     al,'x'                  ;did they really want hex?
 0031  74 28		      C         je      get_number_5            ;yes.
 0033  3C 58		      C         cmp     al,'X'                  ;did they really want hex?
 0035  74 24		      C         je      get_number_5            ;yes.
 0037  E8 0040		      C         call    get_digit               ;convert a character into an int.
 003A  72 24		      C         jc      get_number_2            ;not a digit (neither hex nor dec).
 003C  32 E4		      C         xor     ah,ah
 003E  3B C5		      C         cmp     ax,bp                   ;larger than our base?
 0040  73 1E		      C         jae     get_number_2            ;yes.
			      C 
 0042  50		      C         push    ax                      ;save the new digit.
			      C 
 0043  8B C5		      C         mov     ax,bp                   ;multiply the low word by ten.
 0045  F7 E1		      C         mul     cx
 0047  8B C8		      C         mov     cx,ax                   ;keep the low word.
			      C 
 0049  52		      C         push    dx                      ;save the high word for later.
			      C 
 004A  8B C5		      C         mov     ax,bp
 004C  F7 E3		      C         mul     bx
 004E  8B D8		      C         mov     bx,ax                   ;we keep only the low word (which is our high word)
			      C 
 0050  5A		      C         pop     dx
			      C 
 0051  03 DA		      C         add     bx,dx                   ;add the high result from earlier.
			      C 
 0053  58		      C         pop     ax                      ;get the new digit back.
			      C 
 0054  03 C8		      C         add     cx,ax                   ;add the new digit in.
 0056  83 D3 00		      C         adc     bx,0
 0059  EB D3		      C         jmp     get_number_1
 005B			      C get_number_5:
 005B  BD 0010		      C         mov     bp,16                   ;change the base to hex.
 005E  EB CE		      C         jmp     get_number_1
 0060			      C get_number_2:           ;; Store number to DI
 0060  4E		      C         dec     si
 0061  89 0D		      C         mov     [di],cx                 ;store the parsed number.
 0063  89 5D 02		      C         mov     [di+2],bx
 0066  F8		      C         clc
 0067  EB 10		      C         jmp     short get_number_6
 0069			      C get_number_3:
 0069  3C 3F		      C         cmp     al,'?'                  ;did they ask for the default?
 006B  F9		      C         stc
 006C  75 0B		      C         jne     get_number_6            ;no, return cy.
 006E  83 C6 02		      C         add     si,2                    ;skip past the question mark.
 0071  B9 FFFF		      C         mov     cx,-1
 0074  BB FFFF		      C         mov     bx,-1
 0077  EB E7		      C         jmp     get_number_2            ;and return the -1.
 0079			      C get_number_6:
 0079  C3		      C         ret
			      C 
			      C ;--------------------------------------------------------------------+
			      C ; Name : get_digit
			      C ;
			      C ; Description: Decide digit number.
			      C ;
			      C ; Enter :
			      C ;       carray flag reset : AL = digit.
			      C ;       carray flag set   : Not a digit.
			      C ;
			      C ; Return :
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C         public  get_digit
			      C 
 007A			      C get_digit:
 007A  3C 30		      C         cmp     al,'0'                  ;decimal digit?
 007C  72 20		      C         jb      get_digit_1             ;no.
 007E  3C 39		      C         cmp     al,'9'                  ;. .?
 0080  77 04		      C         ja      get_digit_2             ;no.
 0082  2C 30		      C         sub     al,'0'
 0084  F8		      C         clc
 0085  C3		      C         ret
			      C 
 0086			      C get_digit_2:                            ;; > 9
 0086  3C 61		      C         cmp     al,'a'                  ;hex digit?
 0088  72 08		      C         jb      get_digit_3
 008A  3C 66		      C         cmp     al,'f'                  ;hex digit?
 008C  77 04		      C         ja      get_digit_3
 008E  2C 57		      C         sub     al,'a'-10
 0090  F8		      C         clc
 0091  C3		      C         ret
			      C 
 0092			      C get_digit_3:
 0092  3C 41		      C         cmp     al,'A'                  ;hex digit?
 0094  72 08		      C         jb      get_digit_1
 0096  3C 46		      C         cmp     al,'F'                  ;hex digit?
 0098  77 04		      C         ja      get_digit_1
 009A  2C 37		      C         sub     al,'A'-10
 009C  F8		      C         clc
 009D  C3		      C         ret
			      C 
 009E			      C get_digit_1:                            ;; Not decimal digit
 009E  F9		      C         stc
 009F  C3		      C         ret
			      C 
			      C ;--------------------------------------------------------------------+
			      C ; Name : print_number
			      C ;
			      C ; Description: Print the name and the decimal number.
			      C ;
			      C ; Enter :
			      C ;       DX -> dollar terminated name of number.
			      C ;       DI -> printed number (DWORD).
			      C ;
			      C ; Return : The cursor advanced to next line.
			      C ;
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C         public  print_number
 00A0			      C print_number:
 00A0  B4 09		      C         mov     ah,9                    ;print the name of the number.
 00A2  CD 21		      C         int     21h
 00A4  B0 30		      C         mov     al,'0'
 00A6  E8 0028		      C         call    chrout
 00A9  B0 78		      C         mov     al,'x'
 00AB  E8 0023		      C         call    chrout
 00AE  8B 05		      C         mov     ax,[di]                 ;print the number in hex.
 00B0  8B 55 02		      C         mov     dx,[di+2]
 00B3  E8 0026		      C         call    dwordout
 00B6  B0 20		      C         mov     al,' '
 00B8  E8 0016		      C         call    chrout
 00BB  B0 28		      C         mov     al,'('
 00BD  E8 0011		      C         call    chrout
 00C0  8B 05		      C         mov     ax,[di]                 ;print the number in decimal.
 00C2  8B 55 02		      C         mov     dx,[di+2]
 00C5  E8 0042		      C         call    decout
 00C8  B0 29		      C         mov     al,')'
 00CA  E8 0004		      C         call    chrout
 00CD  E8 007B		      C         call    crlf
 00D0  C3		      C         ret
			      C 
			      C ;--------------------------------------------------------------------+
			      C ; Name : chrout
			      C ;
			      C ; Description: Print a character to screen.
			      C ;
			      C ; Enter :
			      C ;       INT 21h, AH = 02h
			      C ;
			      C ; Return :
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C 
			      C         public  chrout
			      C 
 00D1			      C chrout:
 00D1  50		      C         push    ax                      ;print the char in al.
 00D2  52		      C         push    dx
 00D3  8A D0		      C         mov     dl,al
 00D5  B4 02		      C         mov     ah,2
 00D7  CD 21		      C         int     21h
 00D9  5A		      C         pop     dx
 00DA  58		      C         pop     ax
 00DB  C3		      C         ret
			      C 
			      C ;--------------------------------------------------------------------+
			      C ; Name : dwordout, wordout, byteout, digout
			      C ;
			      C ; Description:
			      C ;       dwordout - DWORD length digit characters print.
			      C ;        wordout - WORD length digit characters print.
			      C ;        byteout - BYTE length digit character print.
			      C ;         digout - Translate byte length to ASCII code.
			      C ;
			      C ; Enter :
			      C ;       DWORD -> DX:AX.
			      C ;        WORD -> AX.
			      C ;        BYTE -> AL.
			      C ;
			      C ; Return :
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C         public  dwordout, wordout, byteout, digout
 00DC			      C dwordout:
 00DC  B1 30		      C         mov     cl,'0'                  ;prepare to eliminate leading zeroes.
 00DE  92		      C         xchg    ax,dx                   ;just output 32 bits in hex.
 00DF  E8 0001		      C         call    wordout                 ;output dx.
 00E2  92		      C         xchg    ax,dx
			      C 
 00E3			      C wordout:
 00E3  50		      C         push    ax
 00E4  8A C4		      C         mov     al,ah
 00E6  E8 0001		      C         call    byteout
 00E9  58		      C         pop     ax
			      C 
 00EA			      C byteout:
 00EA  8A E0		      C         mov     ah,al
 00EC  D0 E8		      C         shr     al,1
 00EE  D0 E8		      C         shr     al,1
 00F0  D0 E8		      C         shr     al,1
 00F2  D0 E8		      C         shr     al,1
 00F4  E8 0002		      C         call    digout
 00F7  8A C4		      C         mov     al,ah
			      C 
 00F9			      C digout:
 00F9  24 0F		      C         and     al,0fh
 00FB  04 90		      C         add     al,90h  ;binary digit to ascii hex digit.
 00FD  27		      C         daa
 00FE  14 40		      C         adc     al,40h
 0100  27		      C         daa
 0101  38 C8		      C         cmp     al,cl                   ;leading zero?
 0103  74 04		      C         je      digout_1
 0105  B1 FF		      C         mov     cl,-1                   ;no more leading zeros.
 0107  EB C8		      C         jmp     chrout
			      C 
 0109			      C digout_1:
			      C 
 0109  C3		      C         ret
			      C 
			      C ;--------------------------------------------------------------------+
			      C ; Name : decout
			      C ;
			      C ; Description: Print DWORD decimal number.
			      C ;
			      C ; Enter :
			      C ;       DX:AX -> number to print.
			      C ;
			      C ; Return :
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C         public  decout
 010A			      C decout:
 010A  8B F0		      C         mov     si,ax                   ;get the number where we want it.
 010C  8B FA		      C         mov     di,dx
 010E  0B C2		      C         or      ax,dx                   ;is the number zero?
 0110  75 04		      C         jne     decout_nonzero
 0112  B0 30		      C         mov     al,'0'                  ;yes - easier to just print it, than
 0114  EB BB		      C         jmp     chrout                  ;  to eliminate all but the last zero.
			      C 
 0116			      C decout_nonzero:
 0116  33 C0		      C         xor     ax,ax                   ;start with all zeroes in al,bx,bp
 0118  8B D8		      C         mov     bx,ax
 011A  8B E8		      C         mov     bp,ax
 011C  B9 0020		      C         mov     cx,32                   ;32 bits in two 16 bit registers.
			      C 
 011F			      C decout_1:
 011F  D1 E6		      C         shl     si,1
 0121  D1 D7		      C         rcl     di,1
 0123  95		      C         xchg    bp,ax
 0124  E8 0019		      C         call    addbit
 0127  95		      C         xchg    bp,ax
 0128  93		      C         xchg    bx,ax
 0129  E8 0014		      C         call    addbit
 012C  93		      C         xchg    bx,ax
 012D  12 C0		      C         adc     al,al
 012F  27		      C         daa
 0130  E2 ED		      C         loop    decout_1
 0132  B1 30		      C         mov     cl,'0'                  ;prepare to eliminate leading zeroes.
 0134  E8 FFB3		      C         call    byteout                 ;output the first two.
 0137  8B C3		      C         mov     ax,bx                   ;output the next four
 0139  E8 FFA7		      C         call    wordout                 ;output the next four
 013C  8B C5		      C         mov     ax,bp
 013E  EB A3		      C         jmp     wordout
			      C 
 0140  12 C0		      C addbit: adc     al,al
 0142  27		      C         daa
 0143  86 C4		      C         xchg    al,ah
 0145  12 C0		      C         adc     al,al
 0147  27		      C         daa
 0148  86 C4		      C         xchg    al,ah
 014A  C3		      C         ret
			      C 
			      C ;--------------------------------------------------------------------+
			      C ; Name : crlf
			      C ;
			      C ; Description: Print carray-return & line_feed
			      C ;
			      C ; Enter :
			      C ;
			      C ; Return :
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C         public  crlf
 014B			      C crlf:
 014B  50		      C         push    ax
 014C  52		      C         push    dx
 014D  B2 0D		      C         mov     dl,13
 014F  B4 02		      C         mov     ah,2
 0151  CD 21		      C         int     21h
 0153  B2 0A		      C         mov     dl,10
 0155  B4 02		      C         mov     ah,2
 0157  CD 21		      C         int     21h
 0159  5A		      C         pop     dx
 015A  58		      C         pop     ax
 015B  C3		      C         ret
			      C 
			      C ;--------------------------------------------------------------------+
			      C ; Name : printmsg
			      C ;
			      C ; Description: Print message with carray-return & line_feed.
			      C ;
			      C ; Enter :
			      C ;       DX : message address.
			      C ;
			      C ; Return :
			      C ; Destroied registers :
			      C ;
			      C ;---------------------------------------------------------------------+
			      C         public printmsg
 015C			      C printmsg:
 015C  B4 09		      C         mov     ah, 9
 015E  CD 21		      C         int     21h
 0160  E8 FFE8		      C         call    crlf
 0163  C3		      C         ret
			      C 
			      C 

					public	malloc
 0164				malloc:
				;enter with dx = amount of memory desired.
				;exit with nc, dx -> that memory, or cy if there isn't enough memory.
 0164  03 16 0000 R			add	dx,free_mem		;make a pointer after that much memory.
 0168  81 FA 0000 E			cmp	dx,offset end_free_mem	;is it still in the free area?
 016C  77 06				ja	malloc_1		;no, we're in trouble.
 016E  87 16 0000 R			xchg	dx,free_mem		;get the pointer back, store ptr->end.
 0172  F8				clc
 0173  C3				ret
 0174				malloc_1:
 0174  F9				stc
 0175  C3				ret


 0176				end_tail_1	label	byte		; end of the delayed init driver

				;usage_msg is of the form "usage: driver [options] <packet_int_no> <args>"
					extrn	usage_msg: byte

 0176				options_i_msg	label	byte
				;;--, 980303, Hu-Tiong
				;;db"   -i -- Force driver to report itself as IEEE 802.3 instead of Ethernet II.",CR,LF
				;;--

 0176				options_msg	label	byte
 0176  20 20 2D 64 20 20	db"  -d           -- Delayed initialization.  Used for diskless booting",CR,LF
       20 20 20 20 20 20
       20 20 20 2D 2D 20
       44 65 6C 61 79 65
       64 20 69 6E 69 74
       69 61 6C 69 7A 61
       74 69 6F 6E 2E 20
       20 55 73 65 64 20
       66 6F 72 20 64 69
       73 6B 6C 65 73 73
       20 62 6F 6F 74 69
       6E 67 0D 0A
 01BC  20 20 2D 6E 20 20	db"  -n           -- NetWare conversion. Converts 802.3 packets into 8137 packets",CR,LF
       20 20 20 20 20 20
       20 20 20 2D 2D 20
       4E 65 74 57 61 72
       65 20 63 6F 6E 76
       65 72 73 69 6F 6E
       2E 20 43 6F 6E 76
       65 72 74 73 20 38
       30 32 2E 33 20 70
       61 63 6B 65 74 73
       20 69 6E 74 6F 20
       38 31 33 37 20 70
       61 63 6B 65 74 73
       0D 0A
 020C  20 20 2D 77 20 20	db"  -w           -- Windows hack, obsoleted by winpkt",CR,LF
       20 20 20 20 20 20
       20 20 20 2D 2D 20
       57 69 6E 64 6F 77
       73 20 68 61 63 6B
       2C 20 6F 62 73 6F
       6C 65 74 65 64 20
       62 79 20 77 69 6E
       70 6B 74 0D 0A
				;;--, 980303, Hu-Tiong
				;;db"   -p -- Promiscuous mode disable",CR,LF
				;;--
 0241  20 20 2D 75 20 20	db"  -u           -- Uninstall",CR,LF
       20 20 20 20 20 20
       20 20 20 2D 2D 20
       55 6E 69 6E 73 74
       61 6C 6C 0D 0A
				;;-+, 980303, Hu-Tiong
				;;db"   -a -- Auto-Negotiation Full-Duplex",CR,LF
				;;db"   -s -- Force to 10 Mb Speed (default: Half-Duplex)",CR,LF
				;;db"   -x -- Force to 100 Mb Speed (default: Half-Duplex)",CR,LF
				;;db"   -f -- Force to Full Duplex (default: Half-Duplex)",CR,LF
				;;db"   -b -- Force to BNC media", CR, LF
				;;db"   PKT9100 is auto-negotiation and half-duplex if there are not options",CR,LF
				;;db"   PKT9100 auto-search I/O and IRQ if they are not specified.",CR,LF
 025E  20 20 2D 61 20 20	db"  -a           -- Auto-Negotiation for both speed and duplex mode",CR,LF
       20 20 20 20 20 20
       20 20 20 2D 2D 20
       41 75 74 6F 2D 4E
       65 67 6F 74 69 61
       74 69 6F 6E 20 66
       6F 72 20 62 6F 74
       68 20 73 70 65 65
       64 20 61 6E 64 20
       64 75 70 6C 65 78
       20 6D 6F 64 65 0D
       0A
 02A1  20 20 2D 78 66 20	db"  -xf          -- Forced 100Mb/s Full Duplex mode",CR,LF
       20 20 20 20 20 20
       20 20 20 2D 2D 20
       46 6F 72 63 65 64
       20 31 30 30 4D 62
       2F 73 20 46 75 6C
       6C 20 44 75 70 6C
       65 78 20 6D 6F 64
       65 0D 0A
 02D4  20 20 2D 78 68 20	db"  -xh          -- Forced 100Mb/s Half Duplex mode",CR,LF
       20 20 20 20 20 20
       20 20 20 2D 2D 20
       46 6F 72 63 65 64
       20 31 30 30 4D 62
       2F 73 20 48 61 6C
       66 20 44 75 70 6C
       65 78 20 6D 6F 64
       65 0D 0A
 0307  20 20 2D 66 20 20	db"  -f           -- Forced 10Mb/s Full Duplex mode",CR,LF
       20 20 20 20 20 20
       20 20 20 2D 2D 20
       46 6F 72 63 65 64
       20 31 30 4D 62 2F
       73 20 46 75 6C 6C
       20 44 75 70 6C 65
       78 20 6D 6F 64 65
       0D 0A
 0339  20 20 2D 68 20 20	db"  -h           -- Forced 10Mb/s Half Duplex mode",CR,LF
       20 20 20 20 20 20
       20 20 20 2D 2D 20
       46 6F 72 63 65 64
       20 31 30 4D 62 2F
       73 20 48 61 6C 66
       20 44 75 70 6C 65
       78 20 6D 6F 64 65
       0D 0A
				ifdef HOMEPNA
 036B  20 20 2D 74 20 20	db"  -t           -- Forced 1Mb/s HomePNA",CR,LF
       20 20 20 20 20 20
       20 20 20 2D 2D 20
       46 6F 72 63 65 64
       20 31 4D 62 2F 73
       20 48 6F 6D 65 50
       4E 41 0D 0A
 0393  20 20 2D 70 58 73	db"  -pXsX        -- set power/speed for HOMEPNA to high/low, X = h or l",CR,LF
       58 20 20 20 20 20
       20 20 20 2D 2D 20
       73 65 74 20 70 6F
       77 65 72 2F 73 70
       65 65 64 20 66 6F
       72 20 48 4F 4D 45
       50 4E 41 20 74 6F
       20 68 69 67 68 2F
       6C 6F 77 2C 20 58
       20 3D 20 68 20 6F
       72 20 6C 0D 0A
 03DA  20 20 2D 69 67 6E	db"  -ignore=<0~1>-- 1 = ignore remote command (default), 0 = accept",CR,LF
       6F 72 65 3D 3C 30
       7E 31 3E 2D 2D 20
       31 20 3D 20 69 67
       6E 6F 72 65 20 72
       65 6D 6F 74 65 20
       63 6F 6D 6D 61 6E
       64 20 28 64 65 66
       61 75 6C 74 29 2C
       20 30 20 3D 20 61
       63 63 65 70 74 0D
       0A
 041D  20 20 2D 72 65 6D	db"  -remcmd=<0~1>-- 0 = disable Tx remote command (default), 1 = enable",CR,LF
       63 6D 64 3D 3C 30
       7E 31 3E 2D 2D 20
       30 20 3D 20 64 69
       73 61 62 6C 65 20
       54 78 20 72 65 6D
       6F 74 65 20 63 6F
       6D 6D 61 6E 64 20
       28 64 65 66 61 75
       6C 74 29 2C 20 31
       20 3D 20 65 6E 61
       62 6C 65 0D 0A
				endif
 0464  20 20 2D 76 6C 61	db"  -vlan=<0~1>  -- 0 = disable VLAN (default), 1 = enable",CR,LF
       6E 3D 3C 30 7E 31
       3E 20 20 2D 2D 20
       30 20 3D 20 64 69
       73 61 62 6C 65 20
       56 4C 41 4E 20 28
       64 65 66 61 75 6C
       74 29 2C 20 31 20
       3D 20 65 6E 61 62
       6C 65 0D 0A
 049E  20 20 2D 66 63 72	db"  -fcrx=<0~1>  -- 0 = disable Rx flow control (default), 1 = enable",CR,LF
       78 3D 3C 30 7E 31
       3E 20 20 2D 2D 20
       30 20 3D 20 64 69
       73 61 62 6C 65 20
       52 78 20 66 6C 6F
       77 20 63 6F 6E 74
       72 6F 6C 20 28 64
       65 66 61 75 6C 74
       29 2C 20 31 20 3D
       20 65 6E 61 62 6C
       65 0D 0A
 04E3  20 20 2D 66 63 74	db"  -fctx=<0~1>  -- 0 = disable Tx flow control (default), 1 = enable",CR,LF
       78 3D 3C 30 7E 31
       3E 20 20 2D 2D 20
       30 20 3D 20 64 69
       73 61 62 6C 65 20
       54 78 20 66 6C 6F
       77 20 63 6F 6E 74
       72 6F 6C 20 28 64
       65 66 61 75 6C 74
       29 2C 20 31 20 3D
       20 65 6E 61 62 6C
       65 0D 0A
 0528  20 20 2D 6C 73 70	db"  -lspeed=<1000|500|1400|1600> -- HPNA line speed (default 1000KBps)",CR,LF
       65 65 64 3D 3C 31
       30 30 30 7C 35 30
       30 7C 31 34 30 30
       7C 31 36 30 30 3E
       20 2D 2D 20 48 50
       4E 41 20 6C 69 6E
       65 20 73 70 65 65
       64 20 28 64 65 66
       61 75 6C 74 20 31
       30 30 30 4B 42 70
       73 29 0D 0A
 056E  20 20 2D 73 6C 6F	db"  -slot=<1~15> -- Select the slot to work with",CR,LF
       74 3D 3C 31 7E 31
       35 3E 20 2D 2D 20
       53 65 6C 65 63 74
       20 74 68 65 20 73
       6C 6F 74 20 74 6F
       20 77 6F 72 6B 20
       77 69 74 68 0D 0A
				ifdef HOMEPNA
 059E  20 20 41 64 61 70	db"  Adapter is in auto mode if none of [a|xf|xh|f|h|t] option is specified",CR,LF
       74 65 72 20 69 73
       20 69 6E 20 61 75
       74 6F 20 6D 6F 64
       65 20 69 66 20 6E
       6F 6E 65 20 6F 66
       20 5B 61 7C 78 66
       7C 78 68 7C 66 7C
       68 7C 74 5D 20 6F
       70 74 69 6F 6E 20
       69 73 20 73 70 65
       63 69 66 69 65 64
       0D 0A
				else
				endif
				;;-+
 05E8  24			db '$'

				extrn	copyright_msg: byte
				extrn	branding_msg : byte

				;; Orignal source from message
 05E9				copyleft_msg	label	byte
 05E9  50 61 63 6B 65 74	 db "Packet driver skeleton copyright 1988-93, Crynwr Software.",CR,LF,'$'
       20 64 72 69 76 65
       72 20 73 6B 65 6C
       65 74 6F 6E 20 63
       6F 70 79 72 69 67
       68 74 20 31 39 38
       38 2D 39 33 2C 20
       43 72 79 6E 77 72
       20 53 6F 66 74 77
       61 72 65 2E 0D 0A
       24

				;db "This program is freely copyable; source must be available; NO WARRANTY.",CR,LF
				;db "See the file COPYING.DOC for details; send FAX to +1-315-268-9201 for a copy.",CR,LF
				; db CR,LF,'$'

 0626				no_resident_msg label	byte
 0626  0D 0A 2A 2A 2A 20	 db CR,LF,"*** Packet driver failed to initialize the board ***",CR,LF,'$'
       50 61 63 6B 65 74
       20 64 72 69 76 65
       72 20 66 61 69 6C
       65 64 20 74 6F 20
       69 6E 69 74 69 61
       6C 69 7A 65 20 74
       68 65 20 62 6F 61
       72 64 20 2A 2A 2A
       0D 0A 24

				;parse_args should parse the arguments.
				;called with ds:si -> immediately after the entry_point.
					extrn	parse_args: near

				;print_parameters should print the arguments.
					extrn	print_parameters: near

					extrn	our_isr: near, their_isr: dword
					extrn	entry_point: byte

 065F 45 49 53 41		eisa_signature	db	"EISA"

				;;++, 2000.6.27, htho, switching adapter support
 0663 4D 65 64 69 61 20		media_home_sw_msg    db      "Media Type is switching adapter", '$'
       54 79 70 65 20 69
       73 20 73 77 69 74
       63 68 69 6E 67 20
       61 64 61 70 74 65
       72 24
				;;++
				;;;;++, 2000.8.24, htho, support DM9009(DM9102 without 100M PHY capability)
					PUBLIC	dm9009_chip_msg, dm9009_warning_msg
 0683 0D 0A 41 64 61 70		dm9009_chip_msg db	CR,LF,"Adapter Type : <<<DAVICOM 10-BaseT PCI Ethernet Adapter>>>", '$'
       74 65 72 20 54 79
       70 65 20 3A 20 3C
       3C 3C 44 41 56 49
       43 4F 4D 20 31 30
       2D 42 61 73 65 54
       20 50 43 49 20 45
       74 68 65 72 6E 65
       74 20 41 64 61 70
       74 65 72 3E 3E 3E
       24
 06C0 57 41 52 4E 49 4E		dm9009_warning_msg db	"WARNING: This adapter supports only -a(auto), -f(10M full), -h(10M half)", '$'
       47 3A 20 54 68 69
       73 20 61 64 61 70
       74 65 72 20 73 75
       70 70 6F 72 74 73
       20 6F 6E 6C 79 20
       2D 61 28 61 75 74
       6F 29 2C 20 2D 66
       28 31 30 4D 20 66
       75 6C 6C 29 2C 20
       2D 68 28 31 30 4D
       20 68 61 6C 66 29
       24
				;;;;++

				;;++, 2000.1.31, hu-tiong
				ifdef HOMEPNA
 0709 4D 65 64 69 61 20		media_home_pna_msg   db      "Media Type is HOME PNA", '$'
       54 79 70 65 20 69
       73 20 48 4F 4D 45
       20 50 4E 41 24
 0720 44 61 74 61 20 52		datarate_1_msg	     db      "Data Rate is 1 Mb", '$'
       61 74 65 20 69 73
       20 31 20 4D 62 24
				endif
				;;++
 0732 4D 65 64 69 61 20		media_tp_msg	db	"Media Type is TP", '$'
       54 79 70 65 20 69
       73 20 54 50 24
 0743 44 61 74 61 20 52		datarate_10_msg db	"Data Rate is 10 Mb",'$'
       61 74 65 20 69 73
       20 31 30 20 4D 62
       24
 0756 44 61 74 61 20 52		datarate_100_msg db	 "Data Rate is 100 Mb",'$'
       61 74 65 20 69 73
       20 31 30 30 20 4D
       62 24
 076A 49 6E 74 65 72 61		half_duplex_msg db	"Interactive mode is Half-Duplex",'$'
       63 74 69 76 65 20
       6D 6F 64 65 20 69
       73 20 48 61 6C 66
       2D 44 75 70 6C 65
       78 24
 078A 49 6E 74 65 72 61		full_duplex_msg db	"Interactive mode is Full-Duplex",'$'
       63 74 69 76 65 20
       6D 6F 64 65 20 69
       73 20 46 75 6C 6C
       2D 44 75 70 6C 65
       78 24
 07AA 50 61 63 6B 65 74		entry_point_name	db	"Packet driver software interrupt is ",'$'
       20 64 72 69 76 65
       72 20 73 6F 66 74
       77 61 72 65 20 69
       6E 74 65 72 72 75
       70 74 20 69 73 20
       24
 07CF 4D 79 20 45 74 68		eaddr_msg	db	"My Ethernet address is ",'$'
       65 72 6E 65 74 20
       61 64 64 72 65 73
       73 20 69 73 20 24
 07E7 4D 79 20 41 52 43		aaddr_msg	db	"My ARCnet address is ",'$'
       6E 65 74 20 61 64
       64 72 65 73 73 20
       69 73 20 24

 07FD 0D 0A 45 72 72 6F		already_msg	db	CR,LF,"Error: there is already a packet driver (you may uninstall it using -u) at ",'$'
       72 3A 20 74 68 65
       72 65 20 69 73 20
       61 6C 72 65 61 64
       79 20 61 20 70 61
       63 6B 65 74 20 64
       72 69 76 65 72 20
       28 79 6F 75 20 6D
       61 79 20 75 6E 69
       6E 73 74 61 6C 6C
       20 69 74 20 75 73
       69 6E 67 20 2D 75
       29 20 61 74 20 24
 084B 0D 0A 45 72 72 6F		no_pkint_msg	db	CR,LF,"Error: there is no packet driver at ",'$'
       72 3A 20 74 68 65
       72 65 20 69 73 20
       6E 6F 20 70 61 63
       6B 65 74 20 64 72
       69 76 65 72 20 61
       74 20 24
 0872 0D 0A 45 72 72 6F		no_pkt_msg	db	CR,LF,"Error: no packet driver found between 0x60 and 0x80",CR,LF,'$'
       72 3A 20 6E 6F 20
       70 61 63 6B 65 74
       20 64 72 69 76 65
       72 20 66 6F 75 6E
       64 20 62 65 74 77
       65 65 6E 20 30 78
       36 30 20 61 6E 64
       20 30 78 38 30 0D
       0A 24
 08AA 0D 0A 45 72 72 6F		two_pkts_msg	db	CR,LF,"Error: there are two packets drivers (specify the desired one after -u).",CR,LF,'$'
       72 3A 20 74 68 65
       72 65 20 61 72 65
       20 74 77 6F 20 70
       61 63 6B 65 74 73
       20 64 72 69 76 65
       72 73 20 28 73 70
       65 63 69 66 79 20
       74 68 65 20 64 65
       73 69 72 65 64 20
       6F 6E 65 20 61 66
       74 65 72 20 2D 75
       29 2E 0D 0A 24
 08F7 0D 0A			int_msg 	db	CR,LF
 08F9  45 72 72 6F 72 3A			db	"Error: <hardware_irq> should be between 0 and "
       20 3C 68 61 72 64
       77 61 72 65 5F 69
       72 71 3E 20 73 68
       6F 75 6C 64 20 62
       65 20 62 65 74 77
       65 65 6E 20 30 20
       61 6E 64 20
 0927				int_msg_num	label	word
 0927  31 35 20 69 6E 63			db	"15 inclusive", '$'
       6C 75 73 69 76 65
       24
 0934 0D 0A 45 72 72 6F		io_invalid_msg	db	CR,LF, "Error : no adapter found in I/O ",'$'
       72 20 3A 20 6E 6F
       20 61 64 61 70 74
       65 72 20 66 6F 75
       6E 64 20 69 6E 20
       49 2F 4F 20 24
 0957 0D 0A 57 61 72 6E		xt_hd_warn_msg	db	CR,LF,"Warning: the hard disk on an XT usually uses IRQ 5.  Use a different interrupt",CR,LF,'$'
       69 6E 67 3A 20 74
       68 65 20 68 61 72
       64 20 64 69 73 6B
       20 6F 6E 20 61 6E
       20 58 54 20 75 73
       75 61 6C 6C 79 20
       75 73 65 73 20 49
       52 51 20 35 2E 20
       20 55 73 65 20 61
       20 64 69 66 66 65
       72 65 6E 74 20 69
       6E 74 65 72 72 75
       70 74 0D 0A 24
 09AA 0D 0A 45 72 72 6F		no_ieee_msg	db	CR,LF,"Error: this driver doesn't implement both IEEE 802.3 and Ethernet II",CR,LF,'$'
       72 3A 20 74 68 69
       73 20 64 72 69 76
       65 72 20 64 6F 65
       73 6E 27 74 20 69
       6D 70 6C 65 6D 65
       6E 74 20 62 6F 74
       68 20 49 45 45 45
       20 38 30 32 2E 33
       20 61 6E 64 20 45
       74 68 65 72 6E 65
       74 20 49 49 0D 0A
       24
 09F3 55 6E 69 6E 73 74		terminated_msg	db	"Uninstall completed",'$'
       61 6C 6C 20 63 6F
       6D 70 6C 65 74 65
       64 24

 0A07 0000			handle		dw	?

 0A09 00			entry_point_fnd db	0
 0A0A 00 00			bogus_type	db	0,0		;totally bogus type code.

				;;++, 980311, Hu-Tiong
					PUBLIC	SlotNum
 0A0C 0000			SlotNum 	dw	0
 0A0E 6C 6F 74			LotStr		db	"lot"
 0A11 = 0003			LOT_STR_LEN	EQU	$-LotStr
 0A11 0D 0A 53 6C 6F 74		SlotNumError	db	CR, LF, "Slot number must be in the range 1..15", CR, LF, '$'
       20 6E 75 6D 62 65
       72 20 6D 75 73 74
       20 62 65 20 69 6E
       20 74 68 65 20 72
       61 6E 67 65 20 31
       2E 2E 31 35 0D 0A
       24
				;;++
				;;;;++, 2000.6.27, htho
				ifdef HOMEPNA
 0A3C 67 6E 6F 72 65		IgnoreStr	db	"gnore"
 0A41 = 0005			IGNORE_STR_LEN	EQU	$-IgnoreStr

 0A41 65 6D 63 6D 64		RemoteStr	db	"emcmd"
 0A46 = 0005			REMOTE_STR_LEN	EQU	$-RemoteStr
				endif
				;;;;++
				;;;;++, 2000.8.24, htho, support VLAN & Tx/Rx flow control
 0A46 6C 61 6E			VlanStr 	db	"lan"
 0A49 = 0003			VLAN_STR_LEN	EQU	$-VlanStr
 0A49 63 74 78			FctxStr 	db	"ctx"
 0A4C = 0003			FCTX_STR_LEN	EQU	$-FctxStr
				;;;;++
				;;++, 2001.3.30, htho, support HPNA speed setting
 0A4C 73 70 65 65 64		SpeedStr	db	"speed"
 0A51 = 0005			SPEED_STR_LEN	EQU	$-SpeedStr
 0A51 0D 0A 48 50 4E 41		LSpeedNumError	db	CR, LF, "HPNA LineSpeed number must be one of {1000,500,1400,1600}", CR, LF, '$'
       20 4C 69 6E 65 53
       70 65 65 64 20 6E
       75 6D 62 65 72 20
       6D 75 73 74 20 62
       65 20 6F 6E 65 20
       6F 66 20 7B 31 30
       30 30 2C 35 30 30
       2C 31 34 30 30 2C
       31 36 30 30 7D 0D
       0A 24
				;;++

 0A8F				our_recv:
 0A8F  33 FF				xor	di,di
 0A91  8E C7				mov	es,di
 0A93  CB				retf

					public	etopen_diagn
 0A94 00			etopen_diagn	db	0		; errorlevel from etopen if set

				;etopen should initialize the device.  If it needs to give an error, it
				;can issue the error message and quit to dos.
					extrn	etopen: near

 0A95 0000 E			memory_to_keep	dw	end_resident	;keep at least this much memory.
				;also see free_mem.
				;;-------------------------------------------------------------------------

 0A97				already_error:
 0A97  BA 07FD R			mov	dx,offset already_msg
 0A9A				already_error_1:
 0A9A  BF 0000 E			mov	di,offset entry_point
 0A9D  E8 F600				call	print_number
 0AA0  B8 4C05				mov	ax,4c05h		; give errorlevel 5
 0AA3  CD 21				int	21h

 0AA5				usage_error:
				;;--- Print usage option
 0AA5  BA 0000 E			mov	dx,offset usage_msg
 0AA8  B4 09				mov	ah,9
 0AAA  CD 21				int	21h

 0AAC  BA 0176 R			mov	dx,offset options_msg
 0AAF  81 3E 0000 E 0B01		cmp	word ptr driver_class,BLUEBOOK + IEEE8023*256	;both present?
 0AB5  75 03				jne	error
 0AB7  BA 0176 R			mov	dx,offset options_i_msg

					public	error
 0ABA				error:
 0ABA  B4 09				mov	ah,9
 0ABC  CD 21				int	21h
 0ABE				error1:
 0ABE  B8 4C0A				mov	ax,4c0ah		; give errorlevel 10
 0AC1  CD 21				int	21h		;; Terminate Precess

				;;*************************************************************
				;;--- Start jump here
				;;*************************************************************
					public	start_1
 0AC3				start_1:
 0AC3  FC				cld
				;;--- Print title when loading time
 0AC4  BA 0000 E			mov	dx,offset copyright_msg 	;;Show Version
 0AC7  B4 09				mov	ah,9
 0AC9  CD 21				int	21h

 0ACB  BA 05E9 R			mov	dx,offset copyleft_msg		;;Show Crynwr Software message
 0ACE  B4 09				mov	ah,9
 0AD0  CD 21				int	21h

 0AD2  BA 0000 E			mov	dx,offset branding_msg		;;Vendor message(DAVICOM.ASM)
 0AD5  B4 09				mov	ah,9
 0AD7  CD 21				int	21h

				;;--- Parser parameters
 0AD9				processor_identified:
 0AD9  BE 0001 E			mov	si,offset phd_dioa+1	;; Point to DTA(Disk Transfer Area)
 0ADC  E8 F523				call	skip_blanks		;end of line?
 0ADF  3C 0D				cmp	al,CR
 0AE1  0F 84 01C0			je	usage_error_j_1 	;; Show usage if have not paramteters.

 0AE5				chk_options:
 0AE5  E8 F51A				call	skip_blanks
 0AE8  3C 2D				cmp	al,'-'                  ; any options?
 0AEA  0F 85 01BA			jne	no_more_opt
 0AEE  46				inc	si			; skip past option char
 0AEF  AC				lodsb				; read next char
 0AF0  0C 20				or	al,20h			; convert to lower case
				;;++, 2000.6.21, htho, set speed/power for HOMEPNA
				ifdef HOMEPNA
 0AF2  3C 70				cmp	al, 'p'
 0AF4  75 51				jne	not_p_opt
 0AF6  AC				lodsb
 0AF7  0C 20				or	al, 20h
 0AF9  3C 68				cmp	al, 'h'
 0AFB  75 0D				jne	not_ph_option

 0AFD  83 0E 0000 E 02			or	pna_cr16, 0002h 	; high power
 0B02  C7 06 0000 E 0400		mov	pna_power_cmd, 0400h
 0B08  EB 0F				jmp	check_speed_opt
 0B0A				not_ph_option:
 0B0A  3C 6C				cmp	al, 'l'
 0B0C  75 97				jne	usage_error

 0B0E  83 26 0000 E FD			and	pna_cr16, NOT 0002h	; low power
 0B13  C7 06 0000 E 0800		mov	pna_power_cmd, 0800h

 0B19				check_speed_opt:
 0B19  AC				lodsb
 0B1A  0C 20				or	al, 20h
 0B1C  3C 73				cmp	al, 's'
 0B1E  75 85				jne	usage_error

 0B20  AC				lodsb
 0B21  0C 20				or	al, 20h

 0B23  3C 68				cmp	al, 'h'
 0B25  75 0D				jne	not_sh_option

 0B27  83 0E 0000 E 04			or	pna_cr16, 0004h 	; high speed
 0B2C  C7 06 0000 E 0100		mov	pna_speed_cmd, 0100h
 0B32  EB B1				jmp	chk_options
 0B34				not_sh_option:
 0B34  3C 6C				cmp	al, 'l'
 0B36  0F 85 FF6B			jne	usage_error

 0B3A  83 26 0000 E FB			and	pna_cr16, NOT 0004h	; low speed
 0B3F  C7 06 0000 E 0200		mov	pna_speed_cmd, 0200h
 0B45  EB 9E				jmp	chk_options

 0B47				not_p_opt:
				endif
				;;++
				;;;;++, 2000.6.27, htho
				ifdef HOMEPNA
 0B47  3C 69				cmp	al, 'i'
 0B49  75 09				jne	not_ignore_opt

 0B4B  E8 036C				call	check_ignore_option
 0B4E  0F 82 FF53			jc	usage_error
 0B52  EB 91				jmp	chk_options

 0B54				not_ignore_opt:
 0B54  3C 72				cmp	al, 'r'
 0B56  75 09				jne	not_remote_opt

 0B58  E8 0395				call	check_remote_option
 0B5B  0F 82 FF46			jc	usage_error
 0B5F  EB 84				jmp	chk_options

 0B61				not_remote_opt:
				endif
				;;;;++
				;;;;++, 2000.8.24, htho, support VLAN & Tx/Rx flow control
 0B61  3C 76				cmp	al, 'v'
 0B63  75 0A				jne	not_vlan_opt

 0B65  E8 03B5				call	check_vlan_option
 0B68  0F 82 FF39			jc	usage_error
 0B6C  E9 FF76				jmp	chk_options

 0B6F				not_vlan_opt:
				;;--, 2001.6.5, confused with "-f" force full duplex
				if 0
				endif
				;;--
				;;;;++

 0B6F  3C 64				cmp	al,'d'
 0B71  75 08				jne	not_d_opt
 0B73  83 0E 0000 E 02			or	flagword,D_OPTION
 0B78  E9 FF6A				jmp	chk_options
 0B7B				not_d_opt:
 0B7B  3C 6E				cmp	al,'n'
 0B7D  75 08				jne	not_n_opt
 0B7F  83 0E 0000 E 04			or	flagword,N_OPTION
 0B84  E9 FF5E				jmp	chk_options
 0B87				not_n_opt:
 0B87  3C 77				cmp	al,'w'
 0B89  75 08				jne	not_w_opt
 0B8B  83 0E 0000 E 08			or	flagword,W_OPTION
 0B90  E9 FF52				jmp	chk_options
 0B93				not_w_opt:
				;;--, 2000.6.21, htho, set speed/power for HOMEPNA
				COMMENT %
					cmp	al,'p'
					jne	not_p_opt
					cmp	rcv_modes,6		;do they even *have* a promiscuous mode?
					jbe	chk_options		;no.
					mov	rcv_modes+2[6*2],0	;yes, nuke it.
					jmp	chk_options
				not_p_opt:
				%
				;;--
 0B93  3C 75				cmp	al,'u'
 0B95  75 08				jne	not_u_opt
 0B97  83 0E 0000 E 10			or	flagword,U_OPTION
 0B9C  E9 FF46				jmp	chk_options

 0B9F				not_u_opt:
				COMMENT %, --, 980303, Hu-Tiong
					cmp	al, 's'
					jne	not_s_opt
					or	flagword, S_OPTION
					jmp	chk_options

				not_s_opt:
				%
 0B9F  3C 78				cmp	al, 'x'
 0BA1  75 1F				jne	not_xs_opt
				;;++, 980303, Hu-Tiong
 0BA3  AC				lodsb
 0BA4  0C 20				or	al, 20h
 0BA6  3C 66				cmp	al, 'f'
 0BA8  75 09				jne	not_xf_opt
 0BAA  81 0E 0000 E 0100		or	flagword, XF_OPTION	; -xf, 100M full duplex
 0BB0  E9 FF32				jmp	chk_options

 0BB3				not_xf_opt:
 0BB3  3C 68				cmp	al, 'h'
				;;-+, 2001.6.12, htho, command line option bug -x
				;;	jne	not_xs_opt
 0BB5  0F 85 FEEC			jne	usage_error
				;;-+
 0BB9  81 0E 0000 E 0080		or	flagword, XH_OPTION	; -xh, 100M half duplex
 0BBF  E9 FF23				jmp	chk_options
				;;++
				;;--
				;;	or	flagword, XS_OPTION
				;;	jmp	chk_options
				;;--

 0BC2				not_xs_opt:
 0BC2  3C 61				cmp	al, 'a'
 0BC4  75 09				jne	not_a_opt
 0BC6  81 0E 0000 E 0200		or	flagword, A_OPTION
 0BCC  E9 FF16				jmp	chk_options

 0BCF				not_a_opt:
 0BCF  3C 66				cmp	al, 'f'                         ; -f, 10M full duplex
 0BD1  75 15				jne	not_f_opt

				;;++, 2001.6.5, confused with "-f" force full duplex
 0BD3  E8 037B				call	check_fc_option
 0BD6  0F 83 FF0B			jnc	chk_options

 0BDA  3C 20				cmp	al, ' '
 0BDC  0F 85 FEC5			jne	usage_error
				;;++
 0BE0  83 0E 0000 E 40			or	flagword, F_OPTION
 0BE5  E9 FEFD				jmp	chk_options

 0BE8				not_f_opt:
				;;++, 980303, Hu-Tiong
 0BE8  3C 68				cmp	al, 'h'
 0BEA  75 08				jne	not_h_opt
 0BEC  83 0E 0000 E 20			or	flagword, H_OPTION		; -h, 10M half duplex
 0BF1  E9 FEF1				jmp	chk_options

 0BF4				not_h_opt:
				;;++
				;;++2000.1.31, Hu-Tiong
				ifdef HOMEPNA
 0BF4  3C 74				cmp	al, 't'
 0BF6  75 09				jne	not_t_opt
 0BF8  81 0E 0000 E 0400		or	flagword, T_OPTION
 0BFE  E9 FEE4				jmp	chk_options
 0C01				not_t_opt:
				endif
				;;++
 0C01  3C 69				cmp	al,'i'
 0C03  75 16				jne	not_i_opt
 0C05  BA 09AA R			mov	dx,offset no_ieee_msg
 0C08  81 3E 0000 E 0B01		cmp	word ptr driver_class,BLUEBOOK + IEEE8023*256	;both present?
				;;	  mov	  dx,offset no_ieee_msg
 0C0E  0F 85 0093			jne	usage_error_j_1 	;no - give error
 0C12  C7 06 0000 E 010B		mov	word ptr driver_class,IEEE8023 + BLUEBOOK*256	;yes, swap them.
 0C18  E9 FECA				jmp	chk_options
 0C1B				not_i_opt:
				;;-+, 980311, Hu-Tiong
				COMMENT %
					cmp	al, 'b'
					jne	not_b_opt
					mov	flagword, B_OPTION	   ;; BNC media
					jmp	chk_options

				not_b_opt:
				%
 0C1B  3C 73				cmp	al, 's'
 0C1D  75 38				jne	not_slot_opt

 0C1F  BB 0A0E R			mov	bx, offset LotStr	; check following parameter is "lot"
 0C22  B9 0003				mov	cx, LOT_STR_LEN
 0C25				CheckNextLotChar:
 0C25  AC				lodsb				; read next parameter character
 0C26  0C 20				or	al, 20h 		; convert to lower case
 0C28  3A 07				cmp	al, [bx]		; check if it's "lot"
 0C2A  75 2B				jne	not_slot_opt
 0C2C  43				inc	bx			; advance to next char in "lot"
 0C2D  E2 F6				loop	CheckNextLotChar

 0C2F  E8 F3D0				call	skip_blanks
 0C32  3C 3D				cmp	al, '='
 0C34  75 21				jne	not_slot_opt
 0C36  46				inc	si			; skip to next char following '='

 0C37  E8 F3C8				call	skip_blanks

 0C3A  BF 0A0C R			mov	di, offset SlotNum
 0C3D  E8 F3CD				call	get_number		; get the value of slot# in [SlotNum]

 0C40  83 3E 0A0C R 01			cmp	SlotNum, 1		; check if slot# in the rage 1~15
 0C45  7C 0A				jl	error_slot_num
 0C47  83 3E 0A0C R 0F			cmp	SlotNum, 15
 0C4C  7F 03				jg	error_slot_num
 0C4E  E9 FE94				jmp	chk_options

 0C51				error_slot_num:
 0C51  BA 0A11 R			mov	dx, offset SlotNumError
 0C54  E9 FE63				jmp	error
 0C57				not_slot_opt:
				;;-+
				;;++, 2001.3.30, htho, support HPNA speed setting
 0C57  3C 6C				cmp	al, 'l'
 0C59  75 FC				jne	not_slot_opt

 0C5B  BB 0A4C R			mov	bx, offset SpeedStr	; check following parameter is "speed"
 0C5E  B9 0005				mov	cx, SPEED_STR_LEN
 0C61				CheckNextSpeedChar:
 0C61  AC				lodsb				; read next parameter character
 0C62  0C 20				or	al, 20h 		; convert to lower case
 0C64  3A 07				cmp	al, [bx]		; check if it's "lot"
 0C66  75 3D				jne	not_lspeed_opt
 0C68  43				inc	bx			; advance to next char in "lot"
 0C69  E2 F6				loop	CheckNextSpeedChar

 0C6B  E8 F394				call	skip_blanks
 0C6E  3C 3D				cmp	al, '='
 0C70  75 E5				jne	not_slot_opt
 0C72  46				inc	si			; skip to next char following '='

 0C73  E8 F38C				call	skip_blanks

 0C76  BF 0000 E			mov	di, offset LSpeedNum
 0C79  E8 F391				call	get_number		; get the value of slot# in [SlotNum]

 0C7C  81 3E 0000 E 03E8		cmp	LSpeedNum, 1000 	 ; check if speed in {1000, 500, 1400, 1600}
 0C82  74 18				je	lspeed_got
 0C84  81 3E 0000 E 01F4		cmp	LSpeedNum, 500
 0C8A  74 10				je	lspeed_got
 0C8C  81 3E 0000 E 0578		cmp	LSpeedNum, 1400
 0C92  74 08				je	lspeed_got
 0C94  81 3E 0000 E 0640		cmp	LSpeedNum, 1600
 0C9A  75 03				jne	error_lspeed_num
 0C9C				lspeed_got:
 0C9C  E9 FE46				jmp	chk_options

 0C9F				error_lspeed_num:
 0C9F  BA 0A51 R			mov	dx, offset LSpeedNumError
 0CA2  E9 FE15				jmp	error
 0CA5				not_lspeed_opt:
				;;-+
 0CA5				usage_error_j_1:
 0CA5  E9 FDFD				jmp	usage_error

 0CA8				no_more_opt:
 0CA8  BF 0000 E			mov	di,offset entry_point	;parse the packet interrupt number
 0CAB  E8 F35F				call	get_number		;  for them. Return to DI.(PKTUTIL.ASM)
 0CAE  F7 06 0000 E 0010		test	flagword,U_OPTION	;should we terminate the driver?
 0CB4  0F 84 00B4			jz	not_terminate		;; go to hardware initialize.

 0CB8				terminate:		;; U_OPTION
				;; Unload one if assign vector, otherwise unload all vector.
 0CB8  80 3E 0000 E 00			cmp	entry_point,0		;did they ask for the default?
 0CBD  75 3D				jne	terminate_int_ok	;no, run with it.
 0CBF  C6 06 0000 E 60			mov	entry_point,60h

 0CC4				terminate_check_int:
 0CC4  E8 0383				call	verify_packet_int
 0CC7  72 0F				jc	terminate_check_int_1	;; cy, INT No. is incorrect.
 0CC9  75 0D				jne	terminate_check_int_1	;; nc, nz, INT No. there is no packet driver
 0CCB  80 3E 0A09 R 00			cmp	entry_point_fnd,0	;did we already find one?
 0CD0  75 24				jne	terminate_check_int_2	;yes, it's ambiguous - give error.
 0CD2  A0 0000 E			mov	al,entry_point		;no, remember it.
 0CD5  A2 0A09 R			mov	entry_point_fnd,al
 0CD8				terminate_check_int_1:
 0CD8  FE 06 0000 E			inc	entry_point		;go look at the next one
 0CDC  80 3E 0000 E 80			cmp	entry_point,80h
 0CE1  76 E1				jbe	terminate_check_int	;keep going to the end.

 0CE3  A0 0A09 R			mov	al,entry_point_fnd	;restore the last one found.
 0CE6  A2 0000 E			mov	entry_point,al
 0CE9  80 3E 0A09 R 00			cmp	entry_point_fnd,0	;did we find one?
 0CEE  75 0C				jne	terminate_int_ok	;yes.
 0CF0  BA 0872 R			mov	dx,offset no_pkt_msg	;no packet drivers installed!
 0CF3  E9 FDC4				jmp	error
 0CF6				terminate_check_int_2:
 0CF6  BA 08AA R			mov	dx,offset two_pkts_msg	;two packet drivers - which one??
 0CF9  E9 FDBE				jmp	error

 0CFC				terminate_int_ok:
 0CFC  E8 034B				call	verify_packet_int	;is the one they specified acceptable?
 0CFF  73 03				jnc	terminate_1		;no, it's not in range.
 0D01  E9 FDB6				jmp	error
 0D04				terminate_1:
 0D04  74 06				je	terminate_2		;go if we found a signature.
 0D06  BA 084B R			mov	dx,offset no_pkint_msg	;no packet driver there.
 0D09  E9 FD8E				jmp	already_error_1

 0D0C				terminate_2:
 0D0C  89 1E 0000 E			mov	their_isr.offs,bx	;;
 0D10  8C 06 0002 E			mov	their_isr.segm,es

 0D14  B8 01FF				mov	ax,1ffh 		;driver_info
 0D17  9C				pushf
 0D18  FA				cli
 0D19  FF 1E 0000 E			call	their_isr
 0D1D  E8 0670				call	fatal_error
					movseg	ds,cs
 0D20  0E		     1		push	cs
 0D21  1F		     1		pop	ds

 0D22  B4 02				mov	ah,2			;access_type
 0D24  8A C5				mov	al,ch			;their class from driver_info().
 0D26  8B DA				mov	bx,dx			;their type from driver_info().
 0D28  8A D1				mov	dl,cl			;their number from driver_info().
 0D2A  B9 0002				mov	cx,2			;use type length 2.
 0D2D  BE 0A0A R			mov	si,offset bogus_type
					movseg	es,cs
 0D30  0E		     1		push	cs
 0D31  07		     1		pop	es
 0D32  BF 0A8F R			mov	di,offset our_recv
 0D35  9C				pushf
 0D36  FA				cli
 0D37  FF 1E 0000 E			call	their_isr
 0D3B  E8 0652				call	fatal_error
 0D3E  A3 0A07 R			mov	handle,ax

 0D41  B4 05				mov	ah,5			;terminate the driver.
 0D43  8B 1E 0A07 R			mov	bx,handle
 0D47  9C				pushf
 0D48  FA				cli
 0D49  FF 1E 0000 E			call	their_isr
 0D4D  73 11				jnc	now_close
 0D4F  E8 0646				call	print_error
 0D52  B4 03				mov	ah,3			;release_type
 0D54  8B 1E 0A07 R			mov	bx,handle
 0D58  9C				pushf
 0D59  FA				cli
 0D5A  FF 1E 0000 E			call	their_isr
 0D5E  CD 20				int	20h
 0D60				now_close:
				;;--, 980615, Hu-Tiong, System hangs while releasing packet driver
				;;    with command option -u if EMM386 installed
				COMMENT %
				;;--- Reset DM9X to avoid hang.
					mov	dx, p_CR0
					mov	eax, 1
					out	dx, eax
				%
				;;--

 0D60  BA 09F3 R			mov	dx,offset terminated_msg
 0D63  B4 09				mov	ah,9
 0D65  CD 21				int	21h
 0D67  CD 20				int	20h

 0D69				usage_error_j_2:
 0D69  E9 FD39				jmp	usage_error

 0D6C				not_terminate:
 0D6C  E8 0000 E			call	parse_args		;;Saved int_no & io_addr from arguments.
 0D6F  72 F8				jc	usage_error_j_2

 0D71  E8 F28E				call	skip_blanks		;end of line?
 0D74  3C 0D				cmp	al,CR
 0D76  75 F1				jne	usage_error_j_2

 0D78  E8 0000 E			call	initpci 		;; Get io_addr & int_no
 0D7B  83 F8 00				cmp	ax, 0
 0D7E  0F 85 FD3C			jne	error1

 0D82				pciok:
 0D82  E8 02C5				call	verify_packet_int	;;Return: nc,zr -> There is packet driver
 0D85  73 03				jnc	packet_int_ok		;;	  nc,nz -> There is no packet driver
 0D87  E9 FD30				jmp	error
 0D8A				packet_int_ok:
 0D8A  75 03				jne	packet_int_unused	;; nz
 0D8C  E9 FD08				jmp	already_error		;give an error if there's one there.

 0D8F				packet_int_unused:
 0D8F				no_mapping_needed:

				; If they chose the -d option, don't call etopen when we are loaded,
				; but when we are called for the first time
				;
				; Save part of the tail, needed by delayed etopen
 0D8F  F7 06 0000 E 0002		test	flagword,D_OPTION
 0D95  74 09				jz	open_now
 0D97  C7 06 0A95 R 0176 R		mov	memory_to_keep,offset end_tail_1	; save first part of tail
 0D9D  E9 00B1				jmp	delayed_open_1
 0DA0				open_now:
				;;++, 2000.1.31, hu-tiong
				IFDEF	DEBUGDOS
				ENDIF	;-- DEBUGDOS
				;;++
 0DA0  E8 0000 E			call	etopen			;init the driver.  If any errors,
									;this routine returns cy.

 0DA3  73 03				jnc	yes_resident
 0DA5  E9 00FD				jmp	no_resident

 0DA8				yes_resident:

 0DA8  E8 F3A0				call	crlf
				;;--- print media type for autodetect
				;;++, 2000.6.27, htho, switching adapter support
					extrn	switch_adapter: byte
 0DAB  80 3E 0000 E 00			cmp	switch_adapter, 0
 0DB0  75 03				jne	media_not_sw_adapt
 0DB2  BA 0663 R			mov	dx, OFFSET media_home_sw_msg
 0DB5				media_not_sw_adapt:
				;;++
				ifdef HOMEPNA
 0DB5  80 3E 0000 E 04			cmp	SROMPortFlag, 4
 0DBA  75 05				jne	printtp
				;;-+, 2000.1.31, hu-tiong
				;;	mov	dx, OFFSET media_bnc_msg
 0DBC  BA 0709 R			mov	dx, OFFSET media_home_pna_msg
				;;-+
 0DBF  EB 03				jmp	print_media
 0DC1				printtp:
				endif
 0DC1  BA 0732 R			mov	dx, OFFSET media_tp_msg
 0DC4				print_media:
 0DC4  E8 F395				call	printmsg		;; print msg with CR/LF

				;;--- print data rate
 0DC7				printspeed:
 0DC7  83 3E 0000 E 64			cmp	InitPIDataRate, 100
 0DCC  74 11				je	print100Mb
				;;++, 2000.1.31, hu-tiong
				ifdef HOMEPNA
 0DCE  83 3E 0000 E 0A			cmp	InitPIDataRate, 10
 0DD3  74 05				je	print10Mb
 0DD5  BA 0720 R			mov	dx, OFFSET datarate_1_msg
 0DD8  EB 08				jmp	print_datarate
 0DDA				print10Mb:
				endif
				;;++
 0DDA  BA 0743 R			mov	dx, OFFSET datarate_10_msg
 0DDD  EB 03				jmp	print_datarate
 0DDF				print100Mb:
 0DDF  BA 0756 R			mov	dx, OFFSET datarate_100_msg
 0DE2				print_datarate:
 0DE2  E8 F377				call	printmsg

				;; --- print interactive mode
				;;-+, 2001.6.21, htho, revise phy duplex mode display while force mode
 0DE5  F7 06 0000 E 0200		test	flagword, A_OPTION
 0DEB  75 0A				jnz	print_auto_result
 0DED  F7 06 0000 E 0140		test	flagword, XF_OPTION OR F_OPTION
 0DF3  75 0E				jnz	print_fd
 0DF5  EB 07				jmp	print_hd
 0DF7				print_auto_result:
 0DF7  80 3E 0000 E 01			cmp	SROMPortFlag, 1
 0DFC  74 05				je	print_fd
 0DFE				print_hd:
				;;-+
 0DFE  BA 076A R			mov	dx, OFFSET half_duplex_msg
 0E01  EB 03				jmp	print_duplex
 0E03				print_fd:
 0E03  BA 078A R			mov	dx, OFFSET full_duplex_msg
 0E06				print_duplex:
 0E06  E8 F353				call	printmsg

 0E09  BF 0000 E			mov	di,offset entry_point
 0E0C  BA 07AA R			mov	dx,offset entry_point_name
 0E0F  E8 F28E				call	print_number

 0E12  E8 0000 E			call	print_parameters	;echo our parameters.
 0E15  83 0E 0000 E 01			or	flagword,CALLED_ETOPEN	;; or 01h

 0E1A  80 3E 0000 E 01			cmp	driver_class,BLUEBOOK	;Blue Book Ethernet?
 0E1F  74 07				je	print_eaddr		;yes.
 0E21  80 3E 0000 E 0B			cmp	driver_class,IEEE8023	;IEEE 802.3 Ethernet?
 0E26  75 10				jne	print_addr_2		;no, don't print what we don't have.

 0E28				print_eaddr:
 0E28  BA 07CF R			mov	dx,offset eaddr_msg
 0E2B  B4 09				mov	ah,9
 0E2D  CD 21				int	21h

 0E2F  BE 0000 E			mov	si,offset rom_address
 0E32  E8 0255				call	print_ether_addr

 0E35  E8 F313				call	crlf

 0E38				print_addr_2:

 0E38  80 3E 0000 E 08			cmp	driver_class,8		;ARCnet?
 0E3D  75 12				jne	print_addr_3		;no, don't print what we don't have.

 0E3F  BA 07E7 R			mov	dx,offset aaddr_msg
 0E42  B4 09				mov	ah,9
 0E44  CD 21				int	21h

 0E46  A0 0000 E			mov	al,rom_address
 0E49  B1 20				mov	cl,' '                  ;Don't eliminate leading zeroes.
 0E4B  E8 F29C				call	byteout

 0E4E  E8 F2FA				call	crlf

 0E51				print_addr_3:
 0E51				delayed_open_1:
 0E51  B4 35				mov	ah,35h			;remember their packet interrupt.
 0E53  A0 0000 E			mov	al,entry_point
 0E56  CD 21				int	21h
 0E58  89 1E 0000 E			mov	their_isr.offs,bx
 0E5C  8C 06 0002 E			mov	their_isr.segm,es

 0E60  B4 25				mov	ah,25h			;install our packet interrupt
 0E62  BA 0000 E			mov	dx,offset our_isr
 0E65  CD 21				int	21h

 0E67  B4 49				mov	ah,49h			;free our environment, because
 0E69  8E 06 0000 E			mov	es,phd_environ		;  we won't need it.
 0E6D  CD 21				int	21h

 0E6F  BB 0001				mov	bx,1			;get the stdout handle.
 0E72  B4 3E				mov	ah,3eh			;close it in case they redirected it.
 0E74  CD 21				int	21h

 0E76  F7 06 0000 E 0002		test	flagword,D_OPTION
 0E7C  75 0B				jne	f_release_type_1	;no.
 0E7E  83 3E 0008 E 00			cmp	rcv_modes+2[3*2],0	;does mode 3 exist?
 0E83  74 04				je	f_release_type_1	;no.
 0E85  FF 16 0008 E			call	rcv_modes+2[3*2]	;  call it.

 0E89				f_release_type_1:
 0E89  8B 16 0A95 R			mov	dx,memory_to_keep	;keep the greater of this and
 0E8D  3B 16 0000 R			cmp	dx,free_mem		;  free_mem.
 0E91  73 04				jae	go_resident
 0E93  8B 16 0000 R			mov	dx,free_mem

 0E97				go_resident:
 0E97  83 C2 0F				add	dx,0fh			;round up to next highest paragraph.
 0E9A  B1 04				mov	cl,4
 0E9C  D3 EA				shr	dx,cl
 0E9E  B4 31				mov	ah,31h			;terminate, stay resident.
 0EA0  A0 0A94 R			mov	al,etopen_diagn 	; errorlevel (0 - 9, just diagnostics)
 0EA3  CD 21				int	21h

 0EA5				no_resident:
				;;	  mov	  ah,9			  ;print their error message.
				;;	  int	  21h

 0EA5  BA 0626 R			mov	dx,offset no_resident_msg
 0EA8  B4 09				mov	ah,9
 0EAA  CD 21				int	21h

 0EAC  B8 4C20				mov	ax,4c00h + 32		; give errorlevel 32
 0EAF  3A 06 0A94 R			cmp	al,etopen_diagn
 0EB3  77 03				ja	no_et_diagn		; etopen gave specific reason?
 0EB5  A0 0A94 R			mov	al,etopen_diagn 	; yes, use that for error level
 0EB8				no_et_diagn:
 0EB8  CD 21				int	21h

				;			Suggested errorlevels:
				;
				; _____________________  0 = normal
				;			 1 = unsuitable memory address given; corrected
				; In most cases every-	 2 = unsuitable IRQ level given; corrected
				; thing should work as	 3 = unsuitable DMA channel given; corrected
				; expected for lev 1-5	 4 = unsuitable IO addr given; corrected (only 1 card)
				; _____________________  5 = packet driver for this int # already loaded
				; External errors, when 20 = general cable failure (but pkt driver is loaded)
				; corrected normal	21 = network cable is open	       -"-
				; operation starts	22 = network cable is shorted	       -"-
				; _____________________ 23 =
				; Packet driver not	30 = usage message
				; loaded. A new load	31 = arguments out of range
				; attempt must be done	32 = unspecified device initialization error
				;			33 =
				;			34 = suggested memory already occupied
				;			35 = suggested IRQ already occupied
				;			36 = suggested DMA channel already occupied
				;			37 = could not find the network card at this IO address

				;;;;++, 2000.6.27, htho
				ifdef HOMEPNA
 0EBA				check_ignore_option proc
 0EBA  BB 0A3C R			mov	bx, offset IgnoreStr	; check following parameter is "lot"
 0EBD  B9 0005				mov	cx, IGNORE_STR_LEN
 0EC0				CheckNextIgnoreChar:
 0EC0  AC				lodsb				; read next parameter character
 0EC1  0C 20				or	al, 20h 		; convert to lower case
 0EC3  3A 07				cmp	al, [bx]		; check if it's "lot"
 0EC5  75 27				jne	err_ignore_opt
 0EC7  43				inc	bx			; advance to next char in "lot"
 0EC8  E2 F6				loop	CheckNextIgnoreChar

 0ECA  E8 F135				call	skip_blanks
 0ECD  3C 3D				cmp	al, '='
 0ECF  75 1D				jne	err_ignore_opt
 0ED1  46				inc	si			; skip to next char following '='

 0ED2  E8 F12D				call	skip_blanks
 0ED5  46				inc	si

 0ED6  3C 30				cmp	al, '0'
 0ED8  75 08				jne	chk_ignore
 0EDA  81 26 0000 E 7FFF		and	pna_cr16, NOT 8000h
 0EE0  F8				clc
 0EE1  C3				ret
 0EE2				chk_ignore:
 0EE2  3C 31				cmp	al, '1'
 0EE4  75 08				jne	err_ignore_opt
 0EE6  81 0E 0000 E 8000		or	pna_cr16, 8000h
 0EEC  F8				clc
 0EED  C3				ret

 0EEE				err_ignore_opt:
 0EEE  F9				stc
 0EEF  C3				ret
 0EF0				check_ignore_option endp

					extrn	send_remote_cmd: byte
 0EF0				check_remote_option proc
 0EF0  BB 0A41 R			mov	bx, offset RemoteStr	; check following parameter is "lot"
 0EF3  B9 0005				mov	cx, REMOTE_STR_LEN
 0EF6				CheckNextRemoteChar:
 0EF6  AC				lodsb				; read next parameter character
 0EF7  0C 20				or	al, 20h 		; convert to lower case
 0EF9  3A 07				cmp	al, [bx]		; check if it's "lot"
 0EFB  75 1E				jne	err_remote_opt
 0EFD  43				inc	bx			; advance to next char in "lot"
 0EFE  E2 F6				loop	CheckNextRemoteChar

 0F00  E8 F0FF				call	skip_blanks
 0F03  3C 3D				cmp	al, '='
 0F05  75 14				jne	err_remote_opt
 0F07  46				inc	si			; skip to next char following '='

 0F08  E8 F0F7				call	skip_blanks
 0F0B  46				inc	si

 0F0C  3C 30				cmp	al, '0'
 0F0E  72 0B				jb	err_remote_opt
 0F10  3C 31				cmp	al, '1'
 0F12  77 07				ja	err_remote_opt

 0F14  2C 30				sub	al, '0'
 0F16  A2 0000 E			mov	send_remote_cmd, al
 0F19  F8				clc
 0F1A  C3				ret

 0F1B				err_remote_opt:
 0F1B  F9				stc
 0F1C  C3				ret
 0F1D				check_remote_option endp
				endif
				;;;;++
				;;;;++, 2000.8.24, htho, support VLAN & Tx/Rx flow control
 0F1D				check_vlan_option proc
 0F1D  BB 0A46 R			mov	bx, offset VlanStr	; check following parameter is "lan"
 0F20  B9 0003				mov	cx, VLAN_STR_LEN
 0F23				CheckNextVlanChar:
 0F23  AC				lodsb				; read next parameter character
 0F24  0C 20				or	al, 20h 		; convert to lower case
 0F26  3A 07				cmp	al, [bx]		; check if it's "lan"
 0F28  75 25				jne	err_vlan_opt
 0F2A  43				inc	bx			; advance to next char in "lot"
 0F2B  E2 F6				loop	CheckNextVlanChar

 0F2D  E8 F0D2				call	skip_blanks
 0F30  3C 3D				cmp	al, '='
 0F32  75 BA				jne	err_ignore_opt
 0F34  46				inc	si			; skip to next char following '='

 0F35  E8 F0CA				call	skip_blanks
 0F38  46				inc	si

 0F39  3C 30				cmp	al, '0'
 0F3B  75 07				jne	chk_vlan
 0F3D  C6 06 0000 E 00			mov	vlan, 0 		; disable VLAN
 0F42  F8				clc
 0F43  C3				ret
 0F44				chk_vlan:
 0F44  3C 31				cmp	al, '1'
 0F46  75 07				jne	err_vlan_opt
 0F48  C6 06 0000 E 01			mov	vlan, 1 		; enable VLAN
 0F4D  F8				clc
 0F4E  C3				ret

 0F4F				err_vlan_opt:
 0F4F  F9				stc
 0F50  C3				ret
 0F51				check_vlan_option endp

 0F51				check_fc_option proc
 0F51  32 E4				xor	ah, ah			; ah = 0 (assume its tx flow control)
 0F53  BB 0A49 R			mov	bx, offset FctxStr	; check following parameter is "ctx"
 0F56  B9 0003				mov	cx, FCTX_STR_LEN
 0F59				CheckNextFctxChar:
 0F59  AC				lodsb				; read next parameter character
 0F5A  0C 20				or	al, 20h 		; convert to lower case
 0F5C  3A 07				cmp	al, [bx]		; check if it's "lan"
 0F5E  74 06				je	@F
 0F60  3C 72				cmp	al, 'r'
 0F62  75 41				jne	err_fc_opt
 0F64  B4 01				mov	ah, 1
 0F66				@@:
 0F66  43				inc	bx			; advance to next char in "lot"
 0F67  E2 F0				loop	CheckNextFctxChar

 0F69				get_fc_value:
 0F69  E8 F096				call	skip_blanks
 0F6C  3C 3D				cmp	al, '='
 0F6E  0F 85 FF7C			jne	err_ignore_opt
 0F72  46				inc	si			; skip to next char following '='

 0F73  E8 F08C				call	skip_blanks
 0F76  46				inc	si

 0F77  3C 30				cmp	al, '0'
 0F79  75 13				jne	chk_fc
 0F7B  80 FC 00				cmp	ah, 0
 0F7E  75 07				jne	disable_fcrx
 0F80				disable_fctx:
 0F80  C6 06 0000 E 00			mov	fctx, 0
 0F85  EB 05				jmp	@F
 0F87				disable_fcrx:
 0F87  C6 06 0000 E 00			mov	fcrx, 0
 0F8C				@@:
 0F8C  F8				clc
 0F8D  C3				ret
 0F8E				chk_fc:
 0F8E  3C 31				cmp	al, '1'
 0F90  75 13				jne	err_fc_opt
 0F92  80 FC 00				cmp	ah, 0
 0F95  75 07				jne	enable_fcrx
 0F97				enable_fctx:
 0F97  C6 06 0000 E 01			mov	fctx, 1
 0F9C  EB 05				jmp	@F
 0F9E				enable_fcrx:
 0F9E  C6 06 0000 E 01			mov	fcrx, 1
 0FA3				@@:
 0FA3  F8				clc
 0FA4  C3				ret

 0FA5				err_fc_opt:
 0FA5  F9				stc
 0FA6  C3				ret
 0FA7				check_fc_option endp
				;;;;++

					include verifypi.asm
 0FA7 50 4B 54 20 44 52	      C signature	db	'PKT DRVR',0
       56 52 00
 0FB0 = 0009		      C signature_len	equ	$-signature
 0FB0 0D 0A		      C packet_int_msg	db	CR,LF
 0FB2  45 72 72 6F 72 3A      C 		db	"Error: <packet_int_no> should be 0x60->0x66, 0x68->0x6f, or 0x78->0x7e",CR,LF
       20 3C 70 61 63 6B
       65 74 5F 69 6E 74
       5F 6E 6F 3E 20 73
       68 6F 75 6C 64 20
       62 65 20 30 78 36
       30 2D 3E 30 78 36
       36 2C 20 30 78 36
       38 2D 3E 30 78 36
       66 2C 20 6F 72 20
       30 78 37 38 2D 3E
       30 78 37 65 0D 0A
 0FFA  20 20 20 20 20 20      C 		db	"       0x67 is the EMS interrupt, and 0x70 through 0x77 are used by second 8259"
       20 30 78 36 37 20
       69 73 20 74 68 65
       20 45 4D 53 20 69
       6E 74 65 72 72 75
       70 74 2C 20 61 6E
       64 20 30 78 37 30
       20 74 68 72 6F 75
       67 68 20 30 78 37
       37 20 61 72 65 20
       75 73 65 64 20 62
       79 20 73 65 63 6F
       6E 64 20 38 32 35
       39
 1049  24		      C 		db	'$'
			      C 
 104A			      C verify_packet_int:
			      C 
			      C ;enter with no special registers.
			      C ;exit with cy,dx-> error message if the packet int was bad,
			      C ;  or nc,zr,es:bx -> current interrupt if there is a packet driver there.
			      C ;  or nc,nz,es:bx -> current interrupt if there is no packet driver there.
			      C 
 104A  80 3E 0000 E 60	      C 	cmp	entry_point,60h 	;make sure that the packet interrupt
 104F  72 1C		      C 	jb	verify_packet_int_bad	;  number is in range.
 1051  80 3E 0000 E 67	      C 	cmp	entry_point,67h 	;make sure that the packet interrupt
 1056  74 15		      C 	je	verify_packet_int_bad	;  number is in range.
 1058  80 3E 0000 E 70	      C 	cmp	entry_point,70h 	;make sure that the packet interrupt
 105D  72 13		      C 	jb	verify_packet_int_ok	;  number is in range.
 105F  80 3E 0000 E 78	      C 	cmp	entry_point,78h 	;make sure that the packet interrupt
 1064  72 07		      C 	jb	verify_packet_int_bad	;  number is in range.
 1066  80 3E 0000 E 7E	      C 	cmp	entry_point,7eh
 106B  76 05		      C 	jbe	verify_packet_int_ok
			      C 
 106D			      C verify_packet_int_bad:
 106D  BA 0FB0 R	      C 	mov	dx,offset packet_int_msg
 1070  F9		      C 	stc
 1071  C3		      C 	ret
			      C 
 1072			      C verify_packet_int_ok:
 1072  B4 35		      C 	mov	ah,35h			;get their packet interrupt.
 1074  A0 0000 E	      C 	mov	al,entry_point
 1077  CD 21		      C 	int	21h
 1079  06		      C 	push	es
 107A  1E		      C 	push	ds
 107B  07		      C 	pop	es
 107C  8D 7F 03		      C 	lea	di,3[bx]		;see if there is already a signature
 107F  BE 0FA7 R	      C 	mov	si,offset signature	;  there.
 1082  B9 0009		      C 	mov	cx,signature_len
 1085  F3/ A6		      C 	repe	cmpsb
 1087  07		      C 	pop	es
 1088  F8		      C 	clc
 1089  C3		      C 	ret
			      C 
			      C  
			      C 
					include printea.asm
			      C 	public	print_ether_addr
 108A			      C print_ether_addr:
 108A  B9 0006		      C 	mov	cx,EADDR_LEN
 108D			      C print_ether_addr_0:
 108D  51		      C 	push	cx
 108E  AC		      C 	lodsb
 108F  B1 20		      C 	mov	cl,' '			;Don't eliminate leading zeroes.
 1091  E8 F056		      C 	call	byteout
 1094  59		      C 	pop	cx
 1095  83 F9 01		      C 	cmp	cx,1
 1098  74 05		      C 	je	print_ether_addr_1
 109A  B0 3A		      C 	mov	al,':'
 109C  E8 F032		      C 	call	chrout
 109F			      C print_ether_addr_1:
 109F  E2 EC		      C 	loop	print_ether_addr_0
 10A1  C3		      C 	ret
			      C 
					include pkterr.asm
			      C ;put into the public domain by Russell Nelson, nelson@crynwr.com
			      C 
			      C 
			      C 
 10A2 4E 6F 20 65 72 72	      C err0    db      "No error at all.",'$'
       6F 72 20 61 74 20
       61 6C 6C 2E 24
			      C 
 10B3 49 6E 76 61 6C 69	      C err1    db      "Invalid handle number",'$'
       64 20 68 61 6E 64
       6C 65 20 6E 75 6D
       62 65 72 24
			      C 
 10C9 4E 6F 20 69 6E 74	      C err2    db      "No interfaces of specified class found",'$'
       65 72 66 61 63 65
       73 20 6F 66 20 73
       70 65 63 69 66 69
       65 64 20 63 6C 61
       73 73 20 66 6F 75
       6E 64 24
			      C 
 10F0 4E 6F 20 69 6E 74	      C err3    db      "No interfaces of specified type found",'$'
       65 72 66 61 63 65
       73 20 6F 66 20 73
       70 65 63 69 66 69
       65 64 20 74 79 70
       65 20 66 6F 75 6E
       64 24
			      C 
 1116 4E 6F 20 69 6E 74	      C err4    db      "No interfaces of specified number found",'$'
       65 72 66 61 63 65
       73 20 6F 66 20 73
       70 65 63 69 66 69
       65 64 20 6E 75 6D
       62 65 72 20 66 6F
       75 6E 64 24
			      C 
 113E 42 61 64 20 70 61	      C err5    db      "Bad packet type specified",'$'
       63 6B 65 74 20 74
       79 70 65 20 73 70
       65 63 69 66 69 65
       64 24
			      C 
 1158 54 68 69 73 20 69	      C err6    db      "This interface does not support multicast",'$'
       6E 74 65 72 66 61
       63 65 20 64 6F 65
       73 20 6E 6F 74 20
       73 75 70 70 6F 72
       74 20 6D 75 6C 74
       69 63 61 73 74 24
			      C 
 1182 54 68 69 73 20 70	      C err7    db      "This packet driver cannot terminate",'$'
       61 63 6B 65 74 20
       64 72 69 76 65 72
       20 63 61 6E 6E 6F
       74 20 74 65 72 6D
       69 6E 61 74 65 24
			      C 
 11A6 41 6E 20 69 6E 76	      C err8    db      "An invalid receiver mode was specified",'$'
       61 6C 69 64 20 72
       65 63 65 69 76 65
       72 20 6D 6F 64 65
       20 77 61 73 20 73
       70 65 63 69 66 69
       65 64 24
			      C 
 11CD 4F 70 65 72 61 74	      C err9    db      "Operation failed because of insufficient space",'$'
       69 6F 6E 20 66 61
       69 6C 65 64 20 62
       65 63 61 75 73 65
       20 6F 66 20 69 6E
       73 75 66 66 69 63
       69 65 6E 74 20 73
       70 61 63 65 24
			      C 
 11FC 54 68 65 20 74 79	      C err10   db      "The type had previously been accessed, and not released.",'$'
       70 65 20 68 61 64
       20 70 72 65 76 69
       6F 75 73 6C 79 20
       62 65 65 6E 20 61
       63 63 65 73 73 65
       64 2C 20 61 6E 64
       20 6E 6F 74 20 72
       65 6C 65 61 73 65
       64 2E 24
			      C 
 1235 54 68 65 20 63 6F	      C err11   db      "The command was out of range, or not implemented",'$'
       6D 6D 61 6E 64 20
       77 61 73 20 6F 75
       74 20 6F 66 20 72
       61 6E 67 65 2C 20
       6F 72 20 6E 6F 74
       20 69 6D 70 6C 65
       6D 65 6E 74 65 64
       24
			      C 
 1266 54 68 65 20 70 61	      C err12   db      "The packet couldn't be sent (usually hardware error)",'$'
       63 6B 65 74 20 63
       6F 75 6C 64 6E 27
       74 20 62 65 20 73
       65 6E 74 20 28 75
       73 75 61 6C 6C 79
       20 68 61 72 64 77
       61 72 65 20 65 72
       72 6F 72 29 24
			      C 
 129B 48 61 72 64 77 61	      C err13   db      "Hardware address couldn't be changed (more than 1 handle open)",'$'
       72 65 20 61 64 64
       72 65 73 73 20 63
       6F 75 6C 64 6E 27
       74 20 62 65 20 63
       68 61 6E 67 65 64
       20 28 6D 6F 72 65
       20 74 68 61 6E 20
       31 20 68 61 6E 64
       6C 65 20 6F 70 65
       6E 29 24
			      C 
 12DA 48 61 72 64 77 61	      C err14   db      "Hardware address has bad length or format",'$'
       72 65 20 61 64 64
       72 65 73 73 20 68
       61 73 20 62 61 64
       20 6C 65 6E 67 74
       68 20 6F 72 20 66
       6F 72 6D 61 74 24
			      C 
 1304 43 6F 75 6C 64 6E	      C err15   db      "Couldn't reset/initialize interface (more than 1 handle open)",'$'
       27 74 20 72 65 73
       65 74 2F 69 6E 69
       74 69 61 6C 69 7A
       65 20 69 6E 74 65
       72 66 61 63 65 20
       28 6D 6F 72 65 20
       74 68 61 6E 20 31
       20 68 61 6E 64 6C
       65 20 6F 70 65 6E
       29 24
			      C 
 1342 41 6E 20 69 6E 76	      C err16   db      "An invalid iocb was specified",'$'
       61 6C 69 64 20 69
       6F 63 62 20 77 61
       73 20 73 70 65 63
       69 66 69 65 64 24
			      C 
 1360 55 6E 6B 6E 6F 77	      C errunk  db      "Unknown error",'$'
       6E 20 65 72 72 6F
       72 24
			      C 
			      C 
			      C 
 136E 10A2 R 10B3 R 10C9 R    C errlist dw      err0, err1, err2, err3, err4, err5, err6, err7, err8
       10F0 R 1116 R 113E R
       1158 R 1182 R 11A6 R
			      C 
 1380  11CD R 11FC R 1235 R   C         dw      err9, err10, err11, err12, err13, err14, err15, err16
       1266 R 129B R 12DA R
       1304 R 1342 R
			      C 
 1390 = 0011		      C error_count     equ     ($ - errlist)/2
			      C 
			      C 
			      C 
 1390			      C fatal_error:
 1390  E8 0005		      C         call    print_error
 1393  73 02		      C         jnc     fatal_error_1           ;Only terminate if there really
 1395  CD 20		      C         int     20h                     ;  was an error.
			      C 
 1397			      C fatal_error_1:
 1397  C3		      C         ret
			      C 
 1398			      C print_error:
			      C ;enter with cy set if an error occured, dh is the error number.  If cy
			      C ;  is not set, don't print anything.  Don't change any registers.
 1398  9C		      C         pushf
 1399  73 2E		      C         jnc     print_error_1
 139B  0A F6		      C         or      dh,dh
 139D  74 2A		      C         je      print_error_1
 139F  50		      C         push    ax
 13A0  53		      C         push    bx
 13A1  52		      C         push    dx
 13A2  1E		      C         push    ds
			      C 
			      C         movseg  ds,cs
 13A3  0E		     1C 	push	cs
 13A4  1F		     1C 	pop	ds
 13A5  8A DE		      C         mov     bl,dh
 13A7  32 FF		      C         xor     bh,bh
 13A9  BA 1360 R	      C         mov     dx,offset errunk        ;in case we don't know about it.
 13AC  80 FB 11		      C         cmp     bl,error_count          ;Do we know about this error number?
 13AF  73 06		      C         jae     print_error_2           ;  no, bail out.
 13B1  D1 E3		      C         shl     bx,1
 13B3  8B 97 136E R	      C         mov     dx,errlist[bx]
			      C 
 13B7			      C print_error_2:
 13B7  B4 09		      C         mov     ah,9
 13B9  CD 21		      C         int     21h
			      C 
 13BB  B0 0D		      C         mov     al,13                   ;crlf.
 13BD  E8 ED11		      C         call    chrout
 13C0  B0 0A		      C         mov     al,10
 13C2  E8 ED0C		      C         call    chrout
			      C 
 13C5  1F		      C         pop     ds
 13C6  5A		      C         pop     dx
 13C7  5B		      C         pop     bx
 13C8  58		      C         pop     ax
			      C 
 13C9			      C print_error_1:
 13C9  9D		      C         popf
 13CA  C3		      C         ret
			      C 
			      C 

 13CB				code	ends

					end
 
Microsoft (R) Macro Assembler Version 6.11		    08/31/01 09:41:39
.\tail.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

BRUSH_BYTE . . . . . . . . . . .	Proc
BRUSH_CHAR . . . . . . . . . . .	Proc
DISP_BYTE  . . . . . . . . . . .	Proc
DISP_CHAR  . . . . . . . . . . .	Proc
add2 . . . . . . . . . . . . . .	Proc
movseg . . . . . . . . . . . . .	Proc
repmov . . . . . . . . . . . . .	Proc
send_peekqueue . . . . . . . . .	Proc
send_queueempty  . . . . . . . .	Proc
to_scrn  . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

iocb . . . . . . . . . . . . . .	 0014
  buffer . . . . . . . . . . . .	 0000	     DWord
  len  . . . . . . . . . . . . .	 0004	     Word
  flags  . . . . . . . . . . . .	 0006	     Byte
  ret_code . . . . . . . . . . .	 0007	     Byte
  upcall . . . . . . . . . . . .	 0008	     DWord
  next . . . . . . . . . . . . .	 000C	     DWord
  resv . . . . . . . . . . . . .	 0010	     Byte
segmoffs . . . . . . . . . . . .	 0004
  offs . . . . . . . . . . . . .	 0000	     Word
  segm . . . . . . . . . . . . .	 0002	     Word
table_multicast  . . . . . . . .	 0005
  table_maxnum . . . . . . . . .	 0000	     Word
  table_current  . . . . . . . .	 0002	     Word
  table_multiaddr  . . . . . . .	 0004	     Byte


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_TEXT  . . . . . . . . . . . . .	16 Bit	 0000	  Word	  Public  'CODE'	
_DATA  . . . . . . . . . . . . .	16 Bit	 0000	  Word	  Public  'DATA'	
code . . . . . . . . . . . . . .	16 Bit	 13CB	  Para	  Public  


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

check_fc_option  . . . . . . . .	P Near	 0F51	  code	Length= 0056 Private
check_ignore_option  . . . . . .	P Near	 0EBA	  code	Length= 0036 Private
check_remote_option  . . . . . .	P Near	 0EF0	  code	Length= 002D Private
check_vlan_option  . . . . . . .	P Near	 0F1D	  code	Length= 0034 Private


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . .	Number	 0001h	 
@code  . . . . . . . . . . . . .	Text   	 DGROUP
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP
ARCADDR_LEN  . . . . . . . . . .	Number	 0001h	 
A_OPTION . . . . . . . . . . . .	Number	 0200h	 
BAD_ADDRESS  . . . . . . . . . .	Number	 000Eh	 
BAD_COMMAND  . . . . . . . . . .	Number	 000Bh	 
BAD_HANDLE . . . . . . . . . . .	Number	 0001h	 
BAD_IOCB . . . . . . . . . . . .	Number	 0010h	 
BAD_MODE . . . . . . . . . . . .	Number	 0008h	 
BAD_TYPE . . . . . . . . . . . .	Number	 0005h	 
BLACK  . . . . . . . . . . . . .	Number	 0000h	 
BLUEBOOK . . . . . . . . . . . .	Number	 0001h	 
BLUE . . . . . . . . . . . . . .	Number	 0001h	 
BROWN  . . . . . . . . . . . . .	Number	 0006h	 
B_OPTION . . . . . . . . . . . .	Number	 0200h	 
CALLED_ETOPEN  . . . . . . . . .	Number	 0001h	 
CALLME . . . . . . . . . . . . .	Number	 0002h	 
CANT_RESET . . . . . . . . . . .	Number	 000Fh	 
CANT_SEND  . . . . . . . . . . .	Number	 000Ch	 
CANT_SET . . . . . . . . . . . .	Number	 000Dh	 
CANT_TERMINATE . . . . . . . . .	Number	 0007h	 
CR . . . . . . . . . . . . . . .	Number	 000Dh	 
CYAN . . . . . . . . . . . . . .	Number	 0003h	 
CY . . . . . . . . . . . . . . .	Number	 0001h	 
CheckNextFctxChar  . . . . . . .	L Near	 0F59	  code	
CheckNextIgnoreChar  . . . . . .	L Near	 0EC0	  code	
CheckNextLotChar . . . . . . . .	L Near	 0C25	  code	
CheckNextRemoteChar  . . . . . .	L Near	 0EF6	  code	
CheckNextSpeedChar . . . . . . .	L Near	 0C61	  code	
CheckNextVlanChar  . . . . . . .	L Near	 0F23	  code	
DARKGRAY . . . . . . . . . . . .	Number	 0007h	 
DONE . . . . . . . . . . . . . .	Number	 0001h	 
D_OPTION . . . . . . . . . . . .	Number	 0002h	 
EADDR_LEN  . . . . . . . . . . .	Number	 0006h	 
EI . . . . . . . . . . . . . . .	Number	 0200h	 
FCTX_STR_LEN . . . . . . . . . .	Number	 0003h	 
F_OPTION . . . . . . . . . . . .	Number	 0040h	 
FctxStr  . . . . . . . . . . . .	Byte	 0A49	  code	
GEN_VER  . . . . . . . . . . . .	Text   	 0
GIANT  . . . . . . . . . . . . .	Number	 05EAh	 
GREEN  . . . . . . . . . . . . .	Number	 0002h	 
HOMEPNA  . . . . . . . . . . . .	Text   	 
HT . . . . . . . . . . . . . . .	Number	 0009h	 
H_OPTION . . . . . . . . . . . .	Number	 0020h	 
IEEE8023 . . . . . . . . . . . .	Number	 000Bh	 
IGNORE_STR_LEN . . . . . . . . .	Number	 0005h	 
IgnoreStr  . . . . . . . . . . .	Byte	 0A3C	  code	
InitPIDataRate . . . . . . . . .	Word	 0000	  code	External
LF . . . . . . . . . . . . . . .	Number	 000Ah	 
LIGHTBLUE  . . . . . . . . . . .	Number	 0009h	 
LIGHTCYAN  . . . . . . . . . . .	Number	 000Bh	 
LIGHTGRAY  . . . . . . . . . . .	Number	 0008h	 
LIGHTGREEN . . . . . . . . . . .	Number	 000Ah	 
LIGHTMAGENTA . . . . . . . . . .	Number	 000Dh	 
LIGHTRED . . . . . . . . . . . .	Number	 000Ch	 
LOT_STR_LEN  . . . . . . . . . .	Number	 0003h	 
LSpeedNumError . . . . . . . . .	Byte	 0A51	  code	
LSpeedNum  . . . . . . . . . . .	Word	 0000	  code	External
LotStr . . . . . . . . . . . . .	Byte	 0A0E	  code	
MAGENTA  . . . . . . . . . . . .	Number	 0005h	 
MAJ_VER  . . . . . . . . . . . .	Text   	 1
MAX_ADDR_LEN . . . . . . . . . .	Number	 0010h	 
MAX_HANDLE . . . . . . . . . . .	Number	 000Ah	 
MAX_MULTICAST  . . . . . . . . .	Number	 000Eh	 
MAX_P_LEN  . . . . . . . . . . .	Number	 0008h	 
MIN_VER  . . . . . . . . . . . .	Text   	 4
NO_CLASS . . . . . . . . . . . .	Number	 0002h	 
NO_ERROR . . . . . . . . . . . .	Number	 0000h	 
NO_MULTICAST . . . . . . . . . .	Number	 0006h	 
NO_NUMBER  . . . . . . . . . . .	Number	 0004h	 
NO_SPACE . . . . . . . . . . . .	Number	 0009h	 
NO_TYPE  . . . . . . . . . . . .	Number	 0003h	 
N_OPTION . . . . . . . . . . . .	Number	 0004h	 
RED  . . . . . . . . . . . . . .	Number	 0004h	 
REMOTE_STR_LEN . . . . . . . . .	Number	 0005h	 
RUNT . . . . . . . . . . . . . .	Number	 003Ch	 
RemoteStr  . . . . . . . . . . .	Byte	 0A41	  code	
SINGLE_PORT  . . . . . . . . . .	Text   	 
SPEED_STR_LEN  . . . . . . . . .	Number	 0005h	 
SROMPortFlag . . . . . . . . . .	Byte	 0000	  code	External
SW_ONE_PKT . . . . . . . . . . .	Text   	 
SYS_MCA  . . . . . . . . . . . .	Number	 0002h	 
SlotNumError . . . . . . . . . .	Byte	 0A11	  code	
SlotNum  . . . . . . . . . . . .	Word	 0A0C	  code	Public
SpeedStr . . . . . . . . . . . .	Byte	 0A4C	  code	
TWO_8259 . . . . . . . . . . . .	Number	 0040h	 
TYPE_INUSE . . . . . . . . . . .	Number	 000Ah	 
T_OPTION . . . . . . . . . . . .	Number	 0400h	 
U_OPTION . . . . . . . . . . . .	Number	 0010h	 
VLAN_STR_LEN . . . . . . . . . .	Number	 0003h	 
VlanStr  . . . . . . . . . . . .	Byte	 0A46	  code	
WHITE  . . . . . . . . . . . . .	Number	 000Fh	 
W_OPTION . . . . . . . . . . . .	Number	 0008h	 
XF_OPTION  . . . . . . . . . . .	Number	 0100h	 
XH_OPTION  . . . . . . . . . . .	Number	 0080h	 
YELLOW . . . . . . . . . . . . .	Number	 000Eh	 
aaddr_msg  . . . . . . . . . . .	Byte	 07E7	  code	
addbit . . . . . . . . . . . . .	L Near	 0140	  code	
already_error_1  . . . . . . . .	L Near	 0A9A	  code	
already_error  . . . . . . . . .	L Near	 0A97	  code	
already_msg  . . . . . . . . . .	Byte	 07FD	  code	
bogus_type . . . . . . . . . . .	Byte	 0A0A	  code	
branding_msg . . . . . . . . . .	Byte	 0000	  code	External
byteout  . . . . . . . . . . . .	L Near	 00EA	  code	Public
check_speed_opt  . . . . . . . .	L Near	 0B19	  code	
chk_fc . . . . . . . . . . . . .	L Near	 0F8E	  code	
chk_ignore . . . . . . . . . . .	L Near	 0EE2	  code	
chk_options  . . . . . . . . . .	L Near	 0AE5	  code	
chk_vlan . . . . . . . . . . . .	L Near	 0F44	  code	
chrout . . . . . . . . . . . . .	L Near	 00D1	  code	Public
copyleft_msg . . . . . . . . . .	Byte	 05E9	  code	
copyright_msg  . . . . . . . . .	Byte	 0000	  code	External
crlf . . . . . . . . . . . . . .	L Near	 014B	  code	Public
datarate_100_msg . . . . . . . .	Byte	 0756	  code	
datarate_10_msg  . . . . . . . .	Byte	 0743	  code	
datarate_1_msg . . . . . . . . .	Byte	 0720	  code	
decout_1 . . . . . . . . . . . .	L Near	 011F	  code	
decout_nonzero . . . . . . . . .	L Near	 0116	  code	
decout . . . . . . . . . . . . .	L Near	 010A	  code	Public
delayed_open_1 . . . . . . . . .	L Near	 0E51	  code	
digout_1 . . . . . . . . . . . .	L Near	 0109	  code	
digout . . . . . . . . . . . . .	L Near	 00F9	  code	Public
disable_fcrx . . . . . . . . . .	L Near	 0F87	  code	
disable_fctx . . . . . . . . . .	L Near	 0F80	  code	
dm9009_chip_msg  . . . . . . . .	Byte	 0683	  code	Public
dm9009_warning_msg . . . . . . .	Byte	 06C0	  code	Public
dm9100_version . . . . . . . . .	Number	 0000h	 
driver_class . . . . . . . . . .	Byte	 0000	  code	External
dwordout . . . . . . . . . . . .	L Near	 00DC	  code	Public
eaddr_msg  . . . . . . . . . . .	Byte	 07CF	  code	
eisa_signature . . . . . . . . .	Byte	 065F	  code	
enable_fcrx  . . . . . . . . . .	L Near	 0F9E	  code	
enable_fctx  . . . . . . . . . .	L Near	 0F97	  code	
end_free_mem . . . . . . . . . .	Byte	 0000	  code	External
end_resident . . . . . . . . . .	Byte	 0000	  code	External
end_tail_1 . . . . . . . . . . .	Byte	 0176	  code	
entry_point_fnd  . . . . . . . .	Byte	 0A09	  code	
entry_point_name . . . . . . . .	Byte	 07AA	  code	
entry_point  . . . . . . . . . .	Byte	 0000	  code	External
err0 . . . . . . . . . . . . . .	Byte	 10A2	  code	
err10  . . . . . . . . . . . . .	Byte	 11FC	  code	
err11  . . . . . . . . . . . . .	Byte	 1235	  code	
err12  . . . . . . . . . . . . .	Byte	 1266	  code	
err13  . . . . . . . . . . . . .	Byte	 129B	  code	
err14  . . . . . . . . . . . . .	Byte	 12DA	  code	
err15  . . . . . . . . . . . . .	Byte	 1304	  code	
err16  . . . . . . . . . . . . .	Byte	 1342	  code	
err1 . . . . . . . . . . . . . .	Byte	 10B3	  code	
err2 . . . . . . . . . . . . . .	Byte	 10C9	  code	
err3 . . . . . . . . . . . . . .	Byte	 10F0	  code	
err4 . . . . . . . . . . . . . .	Byte	 1116	  code	
err5 . . . . . . . . . . . . . .	Byte	 113E	  code	
err6 . . . . . . . . . . . . . .	Byte	 1158	  code	
err7 . . . . . . . . . . . . . .	Byte	 1182	  code	
err8 . . . . . . . . . . . . . .	Byte	 11A6	  code	
err9 . . . . . . . . . . . . . .	Byte	 11CD	  code	
err_fc_opt . . . . . . . . . . .	L Near	 0FA5	  code	
err_ignore_opt . . . . . . . . .	L Near	 0EEE	  code	
err_remote_opt . . . . . . . . .	L Near	 0F1B	  code	
err_vlan_opt . . . . . . . . . .	L Near	 0F4F	  code	
errlist  . . . . . . . . . . . .	Word	 136E	  code	
error1 . . . . . . . . . . . . .	L Near	 0ABE	  code	
error_count  . . . . . . . . . .	Number	 0011h	 
error_lspeed_num . . . . . . . .	L Near	 0C9F	  code	
error_slot_num . . . . . . . . .	L Near	 0C51	  code	
error  . . . . . . . . . . . . .	L Near	 0ABA	  code	Public
errunk . . . . . . . . . . . . .	Byte	 1360	  code	
etopen_diagn . . . . . . . . . .	Byte	 0A94	  code	Public
etopen . . . . . . . . . . . . .	L Near	 0000	  code	External
f_release_type_1 . . . . . . . .	L Near	 0E89	  code	
fatal_error_1  . . . . . . . . .	L Near	 1397	  code	
fatal_error  . . . . . . . . . .	L Near	 1390	  code	
fcrx . . . . . . . . . . . . . .	Byte	 0000	  code	External
fctx . . . . . . . . . . . . . .	Byte	 0000	  code	External
flagword . . . . . . . . . . . .	Word	 0000	  code	External
free_mem . . . . . . . . . . . .	Word	 0000	  code	Public
full_duplex_msg  . . . . . . . .	Byte	 078A	  code	
get_digit_1  . . . . . . . . . .	L Near	 009E	  code	
get_digit_2  . . . . . . . . . .	L Near	 0086	  code	
get_digit_3  . . . . . . . . . .	L Near	 0092	  code	
get_digit  . . . . . . . . . . .	L Near	 007A	  code	Public
get_fc_value . . . . . . . . . .	L Near	 0F69	  code	
get_hex  . . . . . . . . . . . .	L Near	 0012	  code	Public
get_number_0 . . . . . . . . . .	L Near	 0015	  code	
get_number_1 . . . . . . . . . .	L Near	 002E	  code	
get_number_2 . . . . . . . . . .	L Near	 0060	  code	
get_number_3 . . . . . . . . . .	L Near	 0069	  code	
get_number_4 . . . . . . . . . .	L Near	 002A	  code	
get_number_5 . . . . . . . . . .	L Near	 005B	  code	
get_number_6 . . . . . . . . . .	L Near	 0079	  code	
get_number . . . . . . . . . . .	L Near	 000D	  code	Public
go_resident  . . . . . . . . . .	L Near	 0E97	  code	
half_duplex_msg  . . . . . . . .	Byte	 076A	  code	
handle . . . . . . . . . . . . .	Word	 0A07	  code	
initpci  . . . . . . . . . . . .	L Near	 0000	  code	External
int_msg_num  . . . . . . . . . .	Word	 0927	  code	
int_msg  . . . . . . . . . . . .	Byte	 08F7	  code	
int_no . . . . . . . . . . . . .	Byte	 0000	  code	External
io_addr  . . . . . . . . . . . .	Word	 0000	  code	External
io_invalid_msg . . . . . . . . .	Byte	 0934	  code	
lspeed_got . . . . . . . . . . .	L Near	 0C9C	  code	
majver . . . . . . . . . . . . .	Number	 0001h	 
malloc_1 . . . . . . . . . . . .	L Near	 0174	  code	
malloc . . . . . . . . . . . . .	L Near	 0164	  code	Public
media_home_pna_msg . . . . . . .	Byte	 0709	  code	
media_home_sw_msg  . . . . . . .	Byte	 0663	  code	
media_not_sw_adapt . . . . . . .	L Near	 0DB5	  code	
media_tp_msg . . . . . . . . . .	Byte	 0732	  code	
memory_to_keep . . . . . . . . .	Word	 0A95	  code	
my_address . . . . . . . . . . .	Byte	 0000	  code	External
no_et_diagn  . . . . . . . . . .	L Near	 0EB8	  code	
no_ieee_msg  . . . . . . . . . .	Byte	 09AA	  code	
no_mapping_needed  . . . . . . .	L Near	 0D8F	  code	
no_more_opt  . . . . . . . . . .	L Near	 0CA8	  code	
no_pkint_msg . . . . . . . . . .	Byte	 084B	  code	
no_pkt_msg . . . . . . . . . . .	Byte	 0872	  code	
no_resident_msg  . . . . . . . .	Byte	 0626	  code	
no_resident  . . . . . . . . . .	L Near	 0EA5	  code	
not_a_opt  . . . . . . . . . . .	L Near	 0BCF	  code	
not_d_opt  . . . . . . . . . . .	L Near	 0B7B	  code	
not_f_opt  . . . . . . . . . . .	L Near	 0BE8	  code	
not_h_opt  . . . . . . . . . . .	L Near	 0BF4	  code	
not_i_opt  . . . . . . . . . . .	L Near	 0C1B	  code	
not_ignore_opt . . . . . . . . .	L Near	 0B54	  code	
not_lspeed_opt . . . . . . . . .	L Near	 0CA5	  code	
not_n_opt  . . . . . . . . . . .	L Near	 0B87	  code	
not_p_opt  . . . . . . . . . . .	L Near	 0B47	  code	
not_ph_option  . . . . . . . . .	L Near	 0B0A	  code	
not_remote_opt . . . . . . . . .	L Near	 0B61	  code	
not_sh_option  . . . . . . . . .	L Near	 0B34	  code	
not_slot_opt . . . . . . . . . .	L Near	 0C57	  code	
not_t_opt  . . . . . . . . . . .	L Near	 0C01	  code	
not_terminate  . . . . . . . . .	L Near	 0D6C	  code	
not_u_opt  . . . . . . . . . . .	L Near	 0B9F	  code	
not_vlan_opt . . . . . . . . . .	L Near	 0B6F	  code	
not_w_opt  . . . . . . . . . . .	L Near	 0B93	  code	
not_xf_opt . . . . . . . . . . .	L Near	 0BB3	  code	
not_xs_opt . . . . . . . . . . .	L Near	 0BC2	  code	
now_close  . . . . . . . . . . .	L Near	 0D60	  code	
open_now . . . . . . . . . . . .	L Near	 0DA0	  code	
options_i_msg  . . . . . . . . .	Byte	 0176	  code	
options_msg  . . . . . . . . . .	Byte	 0176	  code	
our_isr  . . . . . . . . . . . .	L Near	 0000	  code	External
our_recv . . . . . . . . . . . .	L Near	 0A8F	  code	
p_CR0  . . . . . . . . . . . . .	Word	 0000	  code	External
packet_int_msg . . . . . . . . .	Byte	 0FB0	  code	
packet_int_ok  . . . . . . . . .	L Near	 0D8A	  code	
packet_int_unused  . . . . . . .	L Near	 0D8F	  code	
parse_args . . . . . . . . . . .	L Near	 0000	  code	External
pciok  . . . . . . . . . . . . .	L Near	 0D82	  code	
phd_dioa . . . . . . . . . . . .	Byte	 0000	  code	External
phd_environ  . . . . . . . . . .	Word	 0000	  code	External
pna_cr16 . . . . . . . . . . . .	Word	 0000	  code	External
pna_power_cmd  . . . . . . . . .	Word	 0000	  code	External
pna_speed_cmd  . . . . . . . . .	Word	 0000	  code	External
print100Mb . . . . . . . . . . .	L Near	 0DDF	  code	
print10Mb  . . . . . . . . . . .	L Near	 0DDA	  code	
print_addr_2 . . . . . . . . . .	L Near	 0E38	  code	
print_addr_3 . . . . . . . . . .	L Near	 0E51	  code	
print_auto_result  . . . . . . .	L Near	 0DF7	  code	
print_datarate . . . . . . . . .	L Near	 0DE2	  code	
print_duplex . . . . . . . . . .	L Near	 0E06	  code	
print_eaddr  . . . . . . . . . .	L Near	 0E28	  code	
print_error_1  . . . . . . . . .	L Near	 13C9	  code	
print_error_2  . . . . . . . . .	L Near	 13B7	  code	
print_error  . . . . . . . . . .	L Near	 1398	  code	
print_ether_addr_0 . . . . . . .	L Near	 108D	  code	
print_ether_addr_1 . . . . . . .	L Near	 109F	  code	
print_ether_addr . . . . . . . .	L Near	 108A	  code	Public
print_fd . . . . . . . . . . . .	L Near	 0E03	  code	
print_hd . . . . . . . . . . . .	L Near	 0DFE	  code	
print_media  . . . . . . . . . .	L Near	 0DC4	  code	
print_number . . . . . . . . . .	L Near	 00A0	  code	Public
print_parameters . . . . . . . .	L Near	 0000	  code	External
printmsg . . . . . . . . . . . .	L Near	 015C	  code	Public
printspeed . . . . . . . . . . .	L Near	 0DC7	  code	
printtp  . . . . . . . . . . . .	L Near	 0DC1	  code	
processor_identified . . . . . .	L Near	 0AD9	  code	
rcv_mode_num . . . . . . . . . .	Word	 0000	  code	External
rcv_modes  . . . . . . . . . . .	Word	 0000	  code	External
rom_address  . . . . . . . . . .	Byte	 0000	  code	External
send_remote_cmd  . . . . . . . .	Byte	 0000	  code	External
signature_len  . . . . . . . . .	Number	 0009h	 
signature  . . . . . . . . . . .	Byte	 0FA7	  code	
skip_blanks  . . . . . . . . . .	L Near	 0002	  code	Public
start_1  . . . . . . . . . . . .	L Near	 0AC3	  code	Public
switch_adapter . . . . . . . . .	Byte	 0000	  code	External
terminate_1  . . . . . . . . . .	L Near	 0D04	  code	
terminate_2  . . . . . . . . . .	L Near	 0D0C	  code	
terminate_check_int_1  . . . . .	L Near	 0CD8	  code	
terminate_check_int_2  . . . . .	L Near	 0CF6	  code	
terminate_check_int  . . . . . .	L Near	 0CC4	  code	
terminate_int_ok . . . . . . . .	L Near	 0CFC	  code	
terminated_msg . . . . . . . . .	Byte	 09F3	  code	
terminate  . . . . . . . . . . .	L Near	 0CB8	  code	
their_isr  . . . . . . . . . . .	DWord	 0000	  code	External
two_pkts_msg . . . . . . . . . .	Byte	 08AA	  code	
usage_error_j_1  . . . . . . . .	L Near	 0CA5	  code	
usage_error_j_2  . . . . . . . .	L Near	 0D69	  code	
usage_error  . . . . . . . . . .	L Near	 0AA5	  code	
usage_msg  . . . . . . . . . . .	Byte	 0000	  code	External
verify_packet_int_bad  . . . . .	L Near	 106D	  code	
verify_packet_int_ok . . . . . .	L Near	 1072	  code	
verify_packet_int  . . . . . . .	L Near	 104A	  code	
version  . . . . . . . . . . . .	Number	 0004h	 
vlan . . . . . . . . . . . . . .	Byte	 0000	  code	External
wordout  . . . . . . . . . . . .	L Near	 00E3	  code	Public
xt_hd_warn_msg . . . . . . . . .	Byte	 0957	  code	
yes_resident . . . . . . . . . .	L Near	 0DA8	  code	

	   0 Warnings
	   0 Errors
