Nur in 21b4jwasm/bin: com2exe.exe.
Nur in 21b4jwasm/bin: comtest.com.
Bin√§rdateien 21b4tasm/bin/ctmouse.exe and 21b4jwasm/bin/ctmouse.exe sind verschieden.
Nur in 21b4jwasm/bin: mousetst.com.
Nur in 21b4jwasm/bin: protocol.com.
diff -ru 21b4tasm/source/ctmouse/asmlib/asm.mac 21b4jwasm/source/ctmouse/asmlib/asm.mac
--- 21b4tasm/source/ctmouse/asmlib/asm.mac	2002-06-04 00:00:00.000000000 +0200
+++ 21b4jwasm/source/ctmouse/asmlib/asm.mac	2008-05-31 17:37:00.000000000 +0200
@@ -24,23 +24,23 @@
 
 j		equ	jmp short
 
-saveFAR		macro	addr:req,segm:req,offs:rest
+saveFAR		macro	addr:req,segm:req,offs	; :rest
 		mov	word ptr addr[0],offs
 		mov	word ptr addr[2],segm
 endm
 
-MOVSEG		macro	segreg:req,val:req,temp,segname:rest
+MOVSEG		macro	segreg:req,val:req,temp,segname ; :rest
 		MOVSEG_	<segreg>,<val>,<temp>,<segname>
 endm
 
-POPSEG		macro	segreg:req,segname:rest
+POPSEG		macro	segreg:req,segname ; :rest
 		pop	segreg
 		assume	segreg:segname
 endm
 
 ;------------------------------------------------------------------------
 
-movadd		macro	dst:req,base,index:vararg
+movadd		macro	dst:req,base,index ; :vararg
 	ifb <index>
 		MOVREG_	<dst>,<base>		;; dst=base
 		exitm
@@ -120,7 +120,7 @@
 		add	dst,index
 endm
 
-movsub		macro	dst:req,base,index:vararg
+movsub		macro	dst:req,base,index ; :vararg
 	ifb <index>
 		MOVREG_	<dst>,<base>		;; dst=base
 		exitm
@@ -206,7 +206,7 @@
 
 ;------------------------------------------------------------------------
 
-memcopy		macro	cnt:=<cx>,dstseg,dstsegname,dstoff,srcseg,srcsegname,srcoff:vararg
+memcopy		macro	cnt:=<cx>,dstseg,dstsegname,dstoff,srcseg,srcsegname,srcoff ; :vararg
 	if (.type cnt) ne 00100100b
 	  ;; symbol not defined or expression not a constant value
 		MOVROO_	cx,<cnt>,di,<dstoff>,si,<srcoff>
@@ -233,7 +233,7 @@
 
 ;------------------------------------------------------------------------
 
-movidx		macro	reg:req,index:req,base,oldindex:vararg
+movidx		macro	reg:req,index:req,base,oldindex ; :vararg
 	ifb <oldindex>
 		movadd	<reg>,<base>,<index>
 	elseifb <base>
@@ -249,7 +249,7 @@
 
 ;------------------------------------------------------------------------
 
-out_		macro	port:=<dx>,lo:=<al>,hi:vararg
+out_		macro	port:=<dx>,lo:=<al>,hi ; :vararg
 	if (.type port) eq 00100100b
 	;; symbol is defined and expression is a constant value
 	if port lt 100h
@@ -270,7 +270,7 @@
 	endif
 endm
 
-outw		macro	port:=<dx>,val:vararg
+outw		macro	port:=<dx>,val ; :vararg
 	if (.type port) eq 00100100b
 	;; symbol is defined and expression is a constant value
 	if port lt 100h
@@ -283,7 +283,7 @@
 		out	dx,ax
 endm
 
-inb		macro	var,port:vararg
+inb		macro	var,port ; :vararg
 	ifnb <port>
 	if (.type port) eq 00100100b
 	;; symbol is defined and expression is a constant value
@@ -299,7 +299,7 @@
 		MOVREG_	<var>,al
 endm
 
-inw		macro	var,port:vararg
+inw		macro	var,port ; :vararg
 	ifnb <port>
 	if (.type port) eq 00100100b
 	;; symbol is defined and expression is a constant value
diff -ru 21b4tasm/source/ctmouse/asmlib/bios/area0.def 21b4jwasm/source/ctmouse/asmlib/bios/area0.def
--- 21b4tasm/source/ctmouse/asmlib/bios/area0.def	2003-03-01 00:00:00.000000000 +0100
+++ 21b4jwasm/source/ctmouse/asmlib/bios/area0.def	2008-06-01 18:59:40.000000000 +0200
@@ -109,7 +109,7 @@
 VIDEO_text_charset@	dd ?	; ptr to Text Character Set Override
 VIDEO_graph_charset@	dd ?	; ptr to Graphics Character Set Override
 VIDEO_savetbl2@		dd ?	; [VGA] ptr to Secondary Save Pointer Table
-ends
+VIDEOSAVETBL ends
 
 ; Video Parameter Table:
 ;	VIDEOPARAM 4 dup(?)	; modes 0-3 in 200-line CGA emulation mode
@@ -132,7 +132,7 @@
 VPARAM_CRTC	db 25 dup(?)	; values for CRTC Registers (3x4h)
 VPARAM_ATC	db 20 dup(?)	; values for Attribute Controller Regs (3C0h)
 VPARAM_GRC	db 9 dup(?)	; values for Graphics Controller Regs (3CEh)
-ends		; sizeof(VIDEOPARAM) == 64
+VIDEOPARAM ends		; sizeof(VIDEOPARAM) == 64
 
 
 ;========================================================================
@@ -159,7 +159,8 @@
 VIDEO_width	dw ?		; 44A: screen width in text columns
 VIDEO_pagesize	dw ?		; 44C: video page (regen buffer) size in bytes
 VIDEO_pageoff	dw ?		; 44E: active page offset in video segment
-CURSOR_pos	db 8 dup(?,?)	; 450: cursor column/row on each video page
+; CURSOR_pos	db 8 dup(?,?)	; 450: cursor column/row on each video page
+CURSOR_pos	db (8+8) dup (?)	; JWASM does not understand dup(?,?)
 CURSOR_shape	db ?,?		; 460: cursor end/start scan lines
 VIDEO_pageno	db ?		; 462: active page number
 CRTC_base	dw ?		; 463: base IO address of CRT controller (3x4h)
diff -ru 21b4tasm/source/ctmouse/asmlib/code.mac 21b4jwasm/source/ctmouse/asmlib/code.mac
--- 21b4tasm/source/ctmouse/asmlib/code.mac	2002-09-01 00:00:00.000000000 +0200
+++ 21b4jwasm/source/ctmouse/asmlib/code.mac	2008-05-31 17:36:50.000000000 +0200
@@ -16,40 +16,40 @@
 ; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ;
 
-CODE_		macro	op:req,name,def:vararg
+CODE_		macro	op:req,name,def ; :vararg
 		OPCODE_&op
 name		def
 endm
 
 ;------------------------------------------------------------------------
 
-call_		macro	name:req,value:vararg
+call_		macro	name:req,value ; :vararg
 		db	0E8h		; CALL NEAR word
 name		dw	value-$-2
 endm
 
-jmp_		macro	name:req,value:vararg
+jmp_		macro	name:req,value ; :vararg
 		db	0E9h		; JMP NEAR word
 name		dw	value-$-2
 endm
 
-call_far	macro	name:vararg
+call_far	macro	name ; :vararg
 		db	09Ah		; CALL FAR dword
 name		dd	?
 endm
 
-jmp_far		macro	name:vararg
+jmp_far		macro	name ; :vararg
 		db	0EAh		; JMP FAR dword
 name		dd	?
 endm
 
 ;------------------------------------------------------------------------
 
-fixnear		macro	name:req,value:vararg
+fixnear		macro	name:req,value ; :vararg
 		mov	[name],value-name-2
 endm
 
-fixcode		macro	offs:req,op,arg:vararg
+fixcode		macro	offs:req,op,arg ; :vararg
 	ifb <arg>
 		mov	[offs],op
 	elseifb <op>
diff -ru 21b4tasm/source/ctmouse/asmlib/convert/count2x.mac 21b4jwasm/source/ctmouse/asmlib/convert/count2x.mac
--- 21b4tasm/source/ctmouse/asmlib/convert/count2x.mac	2002-06-04 00:00:00.000000000 +0200
+++ 21b4jwasm/source/ctmouse/asmlib/convert/count2x.mac	2008-06-01 19:16:34.000000000 +0200
@@ -34,7 +34,7 @@
 ; Hint: AX may be immediately stored into memory to get 2-digit ASCII
 ;	string (with leading zero, if input value less than 10h).
 ;
-_byte_hex_AX	macro	val:=<al>,case,shift:vararg
+_byte_hex_AX	macro	val:=<al>,case,shift ; :vararg
 	ifnb <shift>
 	ifdifi <shift>,<4>
 	ifdifi <shift>,<cl>
@@ -56,7 +56,8 @@
 		shr	ah,4
 	endif
 		_digit2ch 16,<case>
-		xchg	ah,al
+;		xchg	ah,al
+	xchg al,ah	; TASM and JWASM use opposite encodings
 		_digit2ch 16,<case>
 endm
 
@@ -79,7 +80,7 @@
 ; Note:	all four digits generated from higher to lower (including all
 ;	leading zero).
 ;
-_word_hex	macro	val:=<ax>,code:rest
+_word_hex	macro	val:=<ax>,code ; :rest
 	local loop
 	ifidni <val>,<cx>
 		MOVREG_	ax,<val>
Nur in 21b4tasm/source/ctmouse/asmlib/dos: file.mac.
diff -ru 21b4tasm/source/ctmouse/asmlib/dos/io.mac 21b4jwasm/source/ctmouse/asmlib/dos/io.mac
--- 21b4tasm/source/ctmouse/asmlib/dos/io.mac	2002-06-02 00:00:00.000000000 +0200
+++ 21b4jwasm/source/ctmouse/asmlib/dos/io.mac	2008-05-31 17:37:09.000000000 +0200
@@ -30,7 +30,7 @@
 ; Modf:	AH
 ; Call:	INT 21/02
 ;
-DOSWriteC	macro	char:vararg
+DOSWriteC	macro	char ; :vararg
 		MOVREG_	dl,<char>
 		mov	ah,2
 		int	21h		; write character to stdout
@@ -48,7 +48,7 @@
 ; Modf:	AH
 ; Call:	INT 21/09
 ;
-DOSWriteS	macro	strseg,strsegname,stroff:vararg
+DOSWriteS	macro	strseg,strsegname,stroff ; :vararg
 		MOVOFF_	dx,<stroff>
 		MOVSEG_	ds,<strseg>,,<strsegname>
 		mov	ah,9
diff -ru 21b4tasm/source/ctmouse/asmlib/dos/mem.mac 21b4jwasm/source/ctmouse/asmlib/dos/mem.mac
--- 21b4tasm/source/ctmouse/asmlib/dos/mem.mac	2002-06-02 00:00:00.000000000 +0200
+++ 21b4jwasm/source/ctmouse/asmlib/dos/mem.mac	2008-05-31 17:37:05.000000000 +0200
@@ -52,7 +52,7 @@
 ; Modf:	AH
 ; Call:	INT 21/35
 ;
-DOSGetIntr	macro	intrno:vararg
+DOSGetIntr	macro	intrno ; :vararg
 		MOVREG2	ax,ah,al,35h,<intrno>
 		int	21h		; get INT in ES:BX
 		assume	es:nothing
@@ -71,7 +71,7 @@
 ; Modf:	AH
 ; Call:	INT 21/25
 ;
-DOSSetIntr	macro	intrno,hseg,hsegname,hoff:vararg
+DOSSetIntr	macro	intrno,hseg,hsegname,hoff ; :vararg
 		MOVOFFax_ dx,dh,dl,<hoff>,25h,<intrno>
 		MOVSEG_	ds,<hseg>,,<hsegname>
 		int	21h		; set INT in DS:DX
@@ -93,7 +93,7 @@
 ; Modf:	none
 ; Call:	INT 21/48
 ;
-DOSAlloc	macro	size,message,errlabel:vararg
+DOSAlloc	macro	size,message,errlabel ; :vararg
 		MOVREG_	bx,<size>
 		mov	ah,48h
 		int	21h		; allocate memory
@@ -121,7 +121,7 @@
 ; Modf:	none
 ; Call:	INT 21/4A
 ;
-DOSRealloc	macro	memseg,memsegname,size,message,errlabel:vararg
+DOSRealloc	macro	memseg,memsegname,size,message,errlabel ; :vararg
 		MOVREG_	bx,<size>
 		MOVSEG_	es,<memseg>,,<memsegname>
 		mov	ah,4Ah
@@ -147,7 +147,7 @@
 ; Modf:	none
 ; Call:	INT 21/49
 ;
-DOSFreeMem	macro	memseg,memsegname,message,errlabel:vararg
+DOSFreeMem	macro	memseg,memsegname,message,errlabel ; :vararg
 		MOVSEG_	es,<memseg>,,<memsegname>
 		mov	ah,49h
 		int	21h		; free memory
@@ -186,7 +186,7 @@
 ; Modf:	AX
 ; Call:	INT 21/5801
 ;
-DOSSetAlloc	macro	strategy:vararg
+DOSSetAlloc	macro	strategy ; :vararg
 		MOVREG_	bx,<strategy>
 		mov	ax,5801h
 		int	21h		; set DOS memory allocation strategy
@@ -222,7 +222,7 @@
 ; Modf:	AX
 ; Call:	INT 21/5803
 ;
-DOSSetUMBlink	macro	state:vararg
+DOSSetUMBlink	macro	state ; :vararg
 		MOVREG_	bx,<state>
 		mov	ax,5803h
 		int	21h		; set UMB link state
diff -ru 21b4tasm/source/ctmouse/asmlib/dos/psp.def 21b4jwasm/source/ctmouse/asmlib/dos/psp.def
--- 21b4tasm/source/ctmouse/asmlib/dos/psp.def	2003-03-01 00:00:00.000000000 +0100
+++ 21b4jwasm/source/ctmouse/asmlib/dos/psp.def	2008-05-31 17:40:48.000000000 +0200
@@ -39,7 +39,7 @@
 FCB1		db 16 dup(?)	; 5C: unopened FCB for 1st cmd argument
 FCB2		db 16 dup(?)	; 6C: unopened FCB for 2nd cmd argument
 		db  4 dup(?)
-defaultDTA	label
+defaultDTA	label byte
 cmdline_len	db ?		; 80
 cmdline		db 127 dup(?)
 PSP		ends		; sizeof(PSP) == 256
Nur in 21b4tasm/source/ctmouse/asmlib: hll.mac.
diff -ru 21b4tasm/source/ctmouse/asmlib/macro.mac 21b4jwasm/source/ctmouse/asmlib/macro.mac
--- 21b4tasm/source/ctmouse/asmlib/macro.mac	2002-06-04 00:00:00.000000000 +0200
+++ 21b4jwasm/source/ctmouse/asmlib/macro.mac	2008-05-31 17:36:08.000000000 +0200
@@ -21,7 +21,7 @@
 ;	  MOVREG2, MOVREGax_, MOVOFFax_,
 ;	  TESTREG_
 
-MOVREG_		macro	reg,val:vararg
+MOVREG_		macro	reg,val ; :vararg
 	ifnb <reg>
 	ifnb <val>
 	ifdifi <val>,<reg>
@@ -41,7 +41,7 @@
 	endif
 endm
 
-MOVOFF_		macro	reg,offs:vararg
+MOVOFF_		macro	reg,offs ; :vararg
 	ifnb <reg>
 	ifnb <offs>
 	ifdifi <offs>,<reg>
@@ -51,7 +51,7 @@
 	endif
 endm
 
-MOVSEG_		macro	segreg,val,temp,segname:vararg
+MOVSEG_		macro	segreg,val,temp,segname ; :vararg
 	ifb <segreg>
 	  exitm
 	endif
@@ -68,7 +68,7 @@
 	    endif
 	  elseif ((.type val) eq 00100100b) or ((.type val) eq 0)
 		;; symbol is defined and expression is a constant value
-		errifb <temp> "Temporary register should be present!"
+;		errifb <temp> "Temporary register should be present!"
 		MOVREG_	<temp>,<val>
 		mov	segreg,temp
 	  else
@@ -83,7 +83,7 @@
 
 ;------------------------------------------------------------------------
 
-MOVRR_		macro	r1,v1,r2,v2:vararg
+MOVRR_		macro	r1,v1,r2,v2 ; :vararg
 	ifdifi <v2>,<r1>
 		MOVREG_	<r1>,<v1>
 	  ifnb <v2>
@@ -101,7 +101,7 @@
 	endif
 endm
 
-MOVRO_		macro	r1,v,r2,off:vararg
+MOVRO_		macro	r1,v,r2,off ; :vararg
 	ifdifi <off>,<r1>
 		MOVREG_	<r1>,<v>
 	  ifnb <off>
@@ -119,7 +119,7 @@
 	endif
 endm
 
-MOVOO_		macro	r1,off1,r2,off2:vararg
+MOVOO_		macro	r1,off1,r2,off2 ; :vararg
 	ifdifi <off2>,<r1>
 		MOVOFF_	<r1>,<off1>
 	  ifnb <off2>
@@ -139,7 +139,7 @@
 
 ;------------------------------------------------------------------------
 
-MOVRRR_		macro	r1,v1,r2,v2,r3,v3:vararg
+MOVRRR_		macro	r1,v1,r2,v2,r3,v3 ; :vararg
 	ifidni <v3>,<r1>
 	  ifdifi <v1>,<r2>
 		MOVREG_	<r2>,<v2>
@@ -168,7 +168,7 @@
 	endif
 endm
 
-MOVRRO_		macro	r1,v1,r2,v2,r3,off:vararg
+MOVRRO_		macro	r1,v1,r2,v2,r3,off ; :vararg
 	ifidni <off>,<r1>
 		MOVRRR_	<r1>,<v1>,<r2>,<v2>,<r3>,<off>
 	elseifidni <off>,<r2>
@@ -179,7 +179,7 @@
 	endif
 endm
 
-MOVROO_		macro	r1,v1,r2,off2,r3,off3:vararg
+MOVROO_		macro	r1,v1,r2,off2,r3,off3 ; :vararg
 	ifidni <off3>,<r1>
 		MOVRRO_	<r1>,<v1>,<r3>,<off3>,<r2>,<off2>
 	elseifidni <off3>,<r2>
@@ -192,7 +192,7 @@
 
 ;------------------------------------------------------------------------
 
-MOVREG2		macro	r,rhi,rlo,hi,lo:vararg
+MOVREG2		macro	r,rhi,rlo,hi,lo ; :vararg
 	ifidni <lo&-&hi>,<al-ah>
 		MOVREG_	<r>,ax
 	elseifidni <lo&-&hi>,<cl-ch>
@@ -209,7 +209,7 @@
 	endif
 endm
 
-MOVREGax_	macro	r:req,rhi:req,rlo:req,val,ahi:=<ah>,alo:vararg
+MOVREGax_	macro	r:req,rhi:req,rlo:req,val,ahi:=<ah>,alo ; :vararg
 	??ASLflag = 0
 	ifb <alo>
 		??ASLflag = 00001b
@@ -266,7 +266,7 @@
 	endif
 endm
 
-MOVOFFax_	macro	r:req,rhi:req,rlo:req,off,ahi:=<ah>,alo:vararg
+MOVOFFax_	macro	r:req,rhi:req,rlo:req,off,ahi:=<ah>,alo ; :vararg
 	??ASLflag = 0
 	ifb <alo>
 		??ASLflag = 00001b
@@ -325,7 +325,7 @@
 
 ;------------------------------------------------------------------------
 
-TESTREG_	macro	reg:vararg
+TESTREG_	macro	reg ; :vararg
 	ifnb <reg>
 	??ASL instr <,ah,cl,ch,dl,dh,bl,bh,ax,cx,dx,bx,sp,bp,si,di,eax,ecx,edx,ebx,esp,ebp,esi,edi,>,<,&reg&,>
 	if ??ASL
diff -ru 21b4tasm/source/ctmouse/ctm-en.msg 21b4jwasm/source/ctmouse/ctm-en.msg
--- 21b4tasm/source/ctmouse/ctm-en.msg	2008-01-09 01:29:42.000000000 +0100
+++ 21b4jwasm/source/ctmouse/ctm-en.msg	2008-06-01 16:24:04.000000000 +0200
@@ -30,7 +30,7 @@
 S_CRLF		db nl,eos
 
 Copyright	db nl,'CuteMouse v',CTMRELEASE,' [FreeDOS]',nl,eos
-Syntax		label
+Syntax		label byte
     db 0,nl,'Options:',nl
     db '  /V	   - reverse search: find PS/2 after serial mouse',nl
     db '  /P	   - force PS/2 mouse mode, do not probe serial ports',nl
diff -ru 21b4tasm/source/ctmouse/ctmouse.asm 21b4jwasm/source/ctmouse/ctmouse.asm
--- 21b4tasm/source/ctmouse/ctmouse.asm	2008-01-09 01:32:09.000000000 +0100
+++ 21b4jwasm/source/ctmouse/ctmouse.asm	2008-06-01 21:49:55.000000000 +0200
@@ -22,16 +22,16 @@
 ;
 
 ; NOTE: memcopy and MOVSEG_ have "assume..." as side effects!
-%pagesize 255
-%noincl
+; %pagesize 255
+; %noincl
 ;%macs
-%nosyms
+; %nosyms
 ;%depth 0
-%linum 0
+; %linum 0
 ;%pcnt 0
 ;%bin 0
-warn
-locals
+; warn
+; locals
 
 CTMVER		equ <"2.1">		; major driver version
 CTMRELEASE	equ <"2.1 beta4">	; full driver version with suffixes
@@ -49,20 +49,26 @@
 
 ;------------------------------------------------------------------------
 
-include asm.mac
-include hll.mac
-include code.def
-include code.mac
-include macro.mac
-include BIOS/area0.def
-include convert/digit.mac
-include convert/count2x.mac
-include DOS/MCB.def
-include DOS/PSP.def
-include DOS/file.mac
-include DOS/mem.mac
-include hard/PIC8259A.def
-include hard/UART.def
+include asmlib/asm.mac
+; *** include asmlib/hll.mac	; if_ loop_ countloop_ etc - TASM specific
+include asmlib/code.def
+include asmlib/code.mac
+include asmlib/macro.mac
+include asmlib/BIOS/area0.def	; ** int11 flags and various 40:xx gfx info
+; HW_PS2	equ 4	; bit set in int 11h returned AX if PS/2 mouse present
+; VIDEO_control VIDEO_switches VIDEO_width VIDEO_pageoff VIDEO_mode
+; VIDEO_switches VIDSW_feature0 VIDSW_display VIDEO_ptrtable@
+; VPARAM_SEQC VIDEO_paramtbl@ VIDEO_lastrow VIDEO_pageno
+include asmlib/convert/digit.mac	; ** only count2x uses digits in ASCII
+include asmlib/convert/count2x.mac	; ** only used as _word_hex for I/O port
+include asmlib/DOS/MCB.def	; ** small, used to set ownerid and name
+include asmlib/DOS/PSP.def	; ** only DOS_exit env_seg cmdline_len PSP_TSR used
+; include asmlib/DOS/file.mac	; was only used once - DOSCloseFile
+include asmlib/DOS/mem.mac
+; include asmlib/hard/PIC8259A.def	; only PIC1_OCW2, PIC1_IMR const used:
+PIC1_OCW2	equ 20h
+PIC1_IMR	equ 21h
+include asmlib/hard/UART.def
 
 USE_286		equ <(@CPU and 4)>
 USE_386		equ <(@CPU and 8)>
@@ -95,8 +101,24 @@
 _ARG_DS_	equ <word ptr [bp+16]>
 _ARG_OFFS_	=   22
 
-PUSHALL		equ <push	ax cx dx bx bp si di>
-POPALL		equ <pop	di si bp bx dx cx ax>
+PUSHALL		macro
+		push	ax
+		push	cx
+		push	dx
+		push	bx
+		push	bp
+		push	si
+		push	di
+endm
+POPALL		macro
+		pop	di
+		pop	si
+		pop	bp
+		pop	bx
+		pop	dx
+		pop	cx
+		pop	ax
+endm
 
 endif ; USE_286
 
@@ -106,9 +128,9 @@
 POINT		struc
   X		dw 0
   Y		dw 0
-ends
+POINT ends
 
-PS2serv		macro	serv:req,errlabel:vararg
+PS2serv		macro	serv:req,errlabel ; :vararg
 		mov	ax,serv
 	push ax
 	mov al,'<'
@@ -154,7 +176,7 @@
 
 ;€€€€€€€€€€€€€€€€€€€€€€€€€€ SEGMENTS DEFINITION €€€€€€€€€€€€€€€€€€€€€€€€€€
 
-.model use16 tiny
+; .model use16 tiny
 assume ss:nothing
 
 @TSRcode equ <DGROUP>
@@ -168,10 +190,10 @@
 
 .code
 		org	0
-TSRstart	label
+TSRstart	label byte
 		org	100h		; .COM style program
 start:		jmp	real_start
-TSRavail	label			; initialized data may come from here
+TSRavail	label byte			; initialized data may come from here
 
 
 ;€€€€€€€€€€€€€€€€€€€€€€€€€€ UNINITIALIZED DATA €€€€€€€€€€€€€€€€€€€€€€€€€€
@@ -187,7 +209,7 @@
 ;!!! WARNING: variables order between RedefArea and szDefArea must be
 ;		syncronized with variables order after DefArea
 
-		evendata
+		even
 SaveArea = $
 RedefArea = $
 
@@ -205,7 +227,7 @@
 cursormask	db	2*16 dup (?)	; user defined cursor mask
 nocursorcnt	db	?		; 0=cursor enabled, else hide counter
 ;;*nolightpen?	db	?		; 0=emulate light pen
-		evendata
+		even
 szDefArea = $ - RedefArea		; initialized by softreset_21
 
 rangemax	POINT	?		; horizontal/vertical range max
@@ -215,17 +237,17 @@
 granpos		POINT	?		; granulated virtual cursor position
 UIR@		dd	?		; user interrupt routine address
 
-		evendata
+		even
 ClearArea = $
 
 sensround	POINT	?		; rounding error in applying
 					;  sensitivity for mickeys
 rounderr	POINT	?		; same in conversion mickeys to pixels
-		evendata
+		even
 szClearArea1 = $ - ClearArea		; cleared by setpos_04
 
 rangemin	POINT	?		; horizontal/vertical range min
-		evendata
+		even
 szClearArea2 = $ - ClearArea		; cleared by setupvideo
 
 cursortype	db	?		; 0 - software, else hardware
@@ -235,12 +257,12 @@
   counter	dw	?
   lastrow	dw	?
   lastcol	dw	?
-ends
+BUTTLASTSTATE ends
 buttpress	BUTTLASTSTATE ?,?,?
 buttrelease	BUTTLASTSTATE ?,?,?
 wheel		BUTTLASTSTATE ?		; wheel counter since last access
 wheelUIR	db	?		; wheel counter for UIR
-		evendata
+		even
 szClearArea3 = $ - ClearArea		; cleared by softreset_21
 szSaveArea = $ - SaveArea
 
@@ -249,7 +271,7 @@
 
 ;!!! WARNING: registers order and RGROUPDEF contents must be fixed
 
-		evendata
+		even
 VRegsArea = $
 
 regs_SEQC	db	5 dup (?)
@@ -274,7 +296,7 @@
 
 szVRegsArea = $ - DefVRegsArea
 
-ERRIF (szVRegsArea ne 64 or $-VRegsArea ne 2*64) "VRegs area contents corrupted!"
+; ERRIF (szVRegsArea ne 64 or $-VRegsArea ne 2*64) "VRegs area contents corrupted!"
 else
 crtc		 dw ?			; 3d4 or 3b4
 endif					; -X- USERIL
@@ -287,10 +309,10 @@
 
 ;€€€€€€€€€€€€€€€€€€€€€€€€€€€ INITIALIZED DATA €€€€€€€€€€€€€€€€€€€€€€€€€€€
 
-		evendata
-TSRdata		label
+		even
+TSRdata		label byte
 
-ERRIF (TSRdata lt TSRavail) "TSR uninitialized data area too small!"
+; ERRIF (TSRdata lt TSRavail) "TSR uninitialized data area too small!"
 
 DefArea = $
 		POINT	<8,16>			; mickey8
@@ -333,12 +355,13 @@
 		dw	0000000000000000b
 		db	1			; nocursorcnt
 ;;*		db	0			; nolightpen?
-		evendata
-ERRIF ($-DefArea ne szDefArea) "Defaults area contents corrupted!"
+	db 0	; JWASM would use 0fch, "CLD" as pad byte??
+		even
+; ERRIF ($-DefArea ne szDefArea) "Defaults area contents corrupted!"
 
 ;----- driver and video state begins here -----
 
-		evendata
+		even
 granumask	POINT	<-1,-1>
 
 textbuf		label	word
@@ -357,14 +380,16 @@
   rgroup	dw	?
   regnum	db	?
   regval	db	?
-ends
-		evendata
+REGSET ends
+
+	db 0	; JWASM would use 0fch, "CLD" as pad byte??
+		even
 		dw	(vdata1end-vdata1)/(size REGSET)
 vdata1		REGSET	<10h,1>,<10h,3>,<10h,4>,<10h,5>,<10h,8>,<08h,2>
-vdata1end	label
+vdata1end	label word
 		dw	(vdata2end-vdata2)/(size REGSET)
 vdata2		REGSET	<10h,1,0>,<10h,4,0>,<10h,5,1>,<10h,8,0FFh>,<08h,2,0Fh>
-vdata2end	label
+vdata2end	label byte
 
 RGROUPDEF	struc
   port@		dw	?
@@ -372,11 +397,11 @@
   def@		dw	?
   regscnt	db	1
   rmodify?	db	0
-ends
+RGROUPDEF ends
 
 if USERIL					; -X-
-		evendata
-videoregs@	label
+		even
+videoregs@	label RGROUPDEF
 	RGROUPDEF <3D4h,regs_CRTC,def_CRTC,25>	; CRTC
 	RGROUPDEF <3C4h,regs_SEQC,def_SEQC,5>	; Sequencer
 	RGROUPDEF <3CEh,regs_GRC, def_GRC, 9>	; Graphics controller
@@ -395,16 +420,23 @@
 IRQhandler	proc
 		assume	ds:nothing,es:nothing
 		cld
-		push	ds es
+		push ds
+		push es
 		PUSHALL
 		MOVSEG	ds,cs,,@TSRdata
-	CODE_	MOV_CX	IOdone,<db ?,0>		; processed bytes counter
+;	CODE_	MOV_CX	IOdone,<db ?,0>		; processed bytes counter
+		OPCODE_MOV_CX
+IOdone		db ?,0
 ; -X- IRQproc	label	byte			; "mov al,OCW2<OCW2_EOI>"
 ; -X-		j	PS2proc			;  if serial mode
 ; -X-		out	PIC1_OCW2,al		; {20h} end of interrupt
-		out_	PIC1_OCW2,%OCW2<OCW2_EOI>
-
-	CODE_	MOV_DX	IO_address,<dw ?>	; UART IO address
+;		out_	PIC1_OCW2,%OCW2<OCW2_EOI>
+		mov	al,20h
+		out	PIC1_OCW2,al
+
+;	CODE_	MOV_DX	IO_address,<dw ?>	; UART IO address
+		OPCODE_MOV_DX
+IO_address	dw ?
 		push	dx
 		movidx	dx,LSR_index
 		 in	al,dx			; {3FDh} LSR: get status
@@ -414,15 +446,19 @@
 		 in	al,dx			; {3F8h} flush receive buffer
 
 		test	bl,mask LSR_break+mask LSR_FE+mask LSR_OE
-	if_ nz					; if break/framing/overrun
+;	if_ nz					; if break/framing/overrun
+	jz @@irqhandlerz
 		xor	cx,cx			;  errors then restart
 		mov	[IOdone],cl		;  sequence: clear counter
-	end_
+;	end_
+@@irqhandlerz:
 		shr	bl,LSR_RBF+1
-	if_ carry				; process data if data ready
+;	if_ carry				; process data if data ready
+	jnc @@irqhandlernc
 		call_	mouseproc,MSMproc	; never PS/2
-	end_
-		jmp	@rethandler
+;	end_
+@@irqhandlernc:
+		jmp	rethandler
 IRQhandler	endp
 		assume	ds:@TSRdata
 
@@ -488,14 +524,17 @@
 ; -X- this handler is called by the BIOS, it is no IRQ handler :-)
 PS2handler	proc
 		assume	ds:nothing,es:nothing
-		push	ds es
+		push	ds
+		push es
 		PUSHALL
 		MOVSEG	ds,cs,,@TSRdata
 
 		mov	bp,sp
 
-PS2WHEELCODE	label	byte			; "j @@PS2WHEEL" if wheel
-		j	@@PS2PLAIN
+PS2WHEELCODE	label	byte		; jump to wheel or plain: test 0/-1
+;		test	sp,0		; 2 byte opcode, sp always NZ here
+;		jnz	PS2WHEEL
+	j	@@PS2PLAIN
 		; stack for non-wheel mice: ... - - Y - X - BTN -
 		; stack for wheel mice:     ... - - W - Y - BTN X
 		; flags: (yext) (xext) ysign xsign 1 btn3 btn1 btn2
@@ -511,7 +550,8 @@
 		mov	bl,al			; backup, xchg will restore
 		shl	al,cl			; CF=Y sign bit, MSB=X sign
 endif
-		sbb	ch,ch			; extend Y sign bit
+;		sbb	ch,ch			; extend Y sign bit
+	db 1ah, 0edh	; JWASM and TASM use opposite encoding
 		cbw				; extend X sign bit
 		mov	al,[bp+_ARG_OFFS_+4]	; AX=X movement
 		xchg	bx,ax			; X to BX, buttons to AL
@@ -523,7 +563,7 @@
 		; stack for wheel mice:     ... - - W - Y - BTN X
 		; flags: (yext) (xext) ysign xsign 1 btn3 btn1 btn2
 		; "ext" flag can be used to trigger "xor value,100h"
-PS2WHEEL:	; handler based on public domain code from Konstantin Koll
+PS2WHEEL::	; handler based on public domain code from Konstantin Koll
 		; old KoKo code used only ext, not sign, ok on all but Alps
 		mov	al,[bp+_ARG_OFFS_+6]	; buttons and flags
 if USE_286
@@ -534,7 +574,8 @@
 		mov	bl,al			; backup, xchg will restore
 		shl	al,cl			; CF=Y sign bit, MSB=X sign
 endif
-		sbb	ch,ch			; extend Y sign bit
+;		sbb	ch,ch			; extend Y sign bit
+	db 1ah, 0edh	; JWASM and TASM use opposite encoding
 		cbw				; extend X sign bit
 		mov	al,[bp+_ARG_OFFS_+7]	; AX=X movement <--
 		xchg	bx,ax			; X to BX, buttons to AL
@@ -544,7 +585,8 @@
 
 @@PS2DONE:	call	reverseY		; AL flags AH wheel BX X CX Y
 		POPALL
-		pop	es ds
+		pop	es
+		pop	ds
 		retf
 PS2handler		endp
 		assume	ds:@TSRdata		; added...?
@@ -565,20 +607,30 @@
 ;----- set new IRQ handler
 
 		mov	dx,TSRcref:IRQhandler	; -X- IRQintnum 0 means none
-	CODE_	MOV_AX	IRQintnum,<db 0,25h>	; INT number of selected IRQ
+;	CODE_	MOV_AX	IRQintnum,<db 0,25h>	; INT number of selected IRQ
+		OPCODE_MOV_AX
+IRQintnum	db 0,25h
 		int	21h			; set INT in DS:DX
 
 ;----- set communication parameters
 
 		mov	si,[IO_address]
 		movidx	dx,LCR_index,si
-		 out_	dx,%LCR{LCR_DLAB=1}	; {3FBh} LCR: DLAB on
-		xchg	dx,si			; 1200 baud rate
-		 outw	dx,96			; {3F8h},{3F9h} divisor latch
-		xchg	dx,si
-	CODE_	 MOV_AX
-LCRset		 LCR	<0,,LCR_noparity,0,2>	; {3FBh} LCR: DLAB off, 7/8N1
-		 MCR	<,,,1,1,1,1>		; {3FCh} MCR: DTR/RTS/OUTx on
+;		 out_	dx,%LCR{LCR_DLAB=1}	; {3FBh} LCR: DLAB on
+;		mov al,%LCR{LCR_DLAB=1}	; {3FBh} LCR: DLAB on
+		mov 	al,80h
+		out	dx,al
+;		xchg	dx,si			; 1200 baud rate
+	xchg si,dx	; JWASM and TASM use opposite encoding
+		mov	ax,96
+;		 outw	dx,96			; {3F8h},{3F9h} divisor latch
+		out	dx,ax
+;		xchg	dx,si
+	xchg si,dx	; JWASM and TASM use opposite encoding
+;	CODE_	 MOV_AX
+		OPCODE_MOV_AX
+LCRset	db 00000010b	; LCR	<0,,LCR_noparity,0,2>	; {3FBh} LCR: DLAB off, 7/8N1
+	db 00001111b	; MCR	<,,,1,1,1,1>		; {3FCh} MCR: DTR/RTS/OUTx on
 		 out	dx,ax
 
 ;----- prepare UART for interrupts
@@ -586,8 +638,12 @@
 		movidx	dx,RBR_index,si,LCR_index
 		 in	al,dx			; {3F8h} flush receive buffer
 		movidx	dx,IER_index,si,RBR_index
-		 out_	dx,%IER{IER_DR=1},%FCR<>; {3F9h} IER: enable DR intr
+;		 out_	dx,%IER{IER_DR=1},%FCR<>; {3F9h} IER: enable DR intr
 						; {3FAh} FCR: disable FIFO
+;		mov	al,%IER{IER_DR=1}
+;		mov	ah,%FCR<>
+		mov ax,1
+		out	dx,ax
 		dec	ax			; OPTIMIZE: instead MOV AL,0
 		mov	[IOdone],al
 		mov	[MSLTbuttons],al
@@ -595,7 +651,9 @@
 ;-----
 
 		in	al,PIC1_IMR		; {21h} get IMR
-	CODE_	AND_AL	notPIC1state,<db ?>	; clear bit to enable interrupt
+;	CODE_	AND_AL	notPIC1state,<db ?>	; clear bit to enable interrupt
+		OPCODE_AND_AL
+notPIC1state	db ?
 		out	PIC1_IMR,al		; {21h} enable serial interrupts
 		ret
 enableUART	endp
@@ -612,7 +670,9 @@
 ;
 disableUART	proc
 		in	al,PIC1_IMR		; {21h} get IMR
-	CODE_	OR_AL	PIC1state,<db ?>	; set bit to disable interrupt
+;	CODE_	OR_AL	PIC1state,<db ?>	; set bit to disable interrupt
+		OPCODE_OR_AL
+PIC1state	db ?
 		out	PIC1_IMR,al		; {21h} disable serial interrupts
 
 ;-----
@@ -621,7 +681,11 @@
 ;	driver with following enabling, below DTR and RTS remained active
 
 		movidx	dx,LCR_index,[IO_address] ; {3FBh} LCR: DLAB off
-		 out_	dx,%LCR<>,%MCR<,,,0,,1,1> ; {3FCh} MCR: DTR/RTS on, OUT2 off
+;		 out_	dx,%LCR<>,%MCR<,,,0,,1,1> ; {3FCh} MCR: DTR/RTS on, OUT2 off
+;		mov	al,%LCR<>
+;		mov	ah,%MCR<,,,0,,1,1>
+	mov ax,300h
+		out	dx,ax
 		movidx	dx,IER_index,,LCR_index
 		 ;mov	al,IER<>
 		 out	dx,al			; {3F9h} IER: interrupts off
@@ -643,9 +707,12 @@
 ;‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
 
 MSLTproc	proc
-	CODE_	MOV_DL	MSLTbuttons,<db ?>	; buttons state for MS3/LT/WM
+;	CODE_	MOV_DL	MSLTbuttons,<db ?>	; buttons state for MS3/LT/WM
+		OPCODE_MOV_DL
+MSLTbuttons	db ?
 		test	al,01000000b	; =40h	; synchro check
-	if_ nz					; if first byte
+;	if_ nz					; if first byte
+	jz @@msltz
 		mov	[IOdone],1		; request next 2/3 bytes
 		mov	[MSLT_1],al
 MSLTCODE1	label	byte			; "ret" if not LT/WM
@@ -653,25 +720,33 @@
 		sub	al,3			; if first byte after 3 bytes
 		jz	@@LTWMbutton3		;  then release middle button
 		ret
-	end_
+;	end_
+@@msltz:
 
-	if_ ncxz				; skip nonfirst byte at start
+;	if_ ncxz				; skip nonfirst byte at start
+	jcxz @@msltcxz
 		inc	[IOdone]		; request next byte
 		loop	@@MSLT_3
 		mov	[MSLT_X],al		; keep X movement LO
-	end_
+;	end_
+@@msltcxz:
 @@LTret:	ret
 
 @@MSLT_3:	loop	@@LTWM_4
 		;mov	cl,0
-	CODE_	MOV_BX	MSLT_1,<db ?,0>		; mouse packet first byte
+;	CODE_	MOV_BX	MSLT_1,<db ?,0>		; mouse packet first byte
+		OPCODE_MOV_BX
+MSLT_1		db ?,0
 		ror	bx,2
-		xchg	cl,bh			; bits 1-0: X movement HI
+;		xchg	cl,bh			; bits 1-0: X movement HI
+		xchg	bh,cl	; TASM and JWASM use opposite encoding
 		ror	bx,2			; bits 5-4: LR buttons
 		or	al,bh			; bits 3-2: Y movement HI
 		cbw
 		 xchg	cx,ax			; CX=Y movement
-	CODE_	OR_AL	MSLT_X,<db ?>
+;	CODE_	OR_AL	MSLT_X,<db ?>
+		OPCODE_OR_AL
+MSLT_X		db ?
 		cbw
 		 xchg	bx,ax			; BX=X movement
 
@@ -724,25 +799,35 @@
 
 @@MSM_1:	xor	al,10000111b	; =87h	; sync check: AL should
 		test	al,11111000b	; =0F8h	;  be equal to 10000lmr
-	if_ zero
+;	if_ zero
+	jnz @@msmnz
 		test	al,00000110b	; =6	; check the L and M buttons
-	 if_ odd				; if buttons not same
+;	 if_ odd				; if buttons not same
+	jpe @@msmeven
 		xor	al,00000110b	; =6	; swap them
-	 end_
+;	 end_
+@@msmeven:
 		mov	[MSM_buttons],al	; bits 2-0: MLR buttons
 		;j	@@MSMnext
 
 @@MSM_3:	mov	[MSM_Y],ax
 @@MSMnext:	inc	[IOdone]		; request next byte
-	end_
+;	end_
+@@msmnz:
 		ret
 
 @@MSM_5:	;mov	ch,0
 		mov	[IOdone],ch		; request next packet
-	CODE_	ADD_AX	MSM_Y,<dw ?>
-	CODE_	MOV_BX	MSM_X,<dw ?>
+;	CODE_	ADD_AX	MSM_Y,<dw ?>
+		OPCODE_ADD_AX
+MSM_Y		dw ?
+;	CODE_	MOV_BX	MSM_X,<dw ?>
+		OPCODE_MOV_BX
+MSM_X		dw ?
 		xchg	cx,ax			; OPTIMIZE: instead MOV CX,AX
-	CODE_	MOV_AL	MSM_buttons,<db ?>
+;	CODE_	MOV_AL	MSM_buttons,<db ?>
+		OPCODE_MOV_AL
+MSM_buttons	db ?
 		;j	reverseY		; reverseY is next line anyway
 MSMproc		endp
 
@@ -766,14 +851,19 @@
 
 swapbuttons	proc
 		test	al,00000011b	; =3	; check the L and R buttons
-	if_ odd					; if buttons not same
-	CODE_	XOR_AL	swapmask,<db 00000011b>	; 0 if (PS2 xor LEFTHAND)
-	end_
+;	if_ odd					; if buttons not same
+	jpe @@swapeven
+;	CODE_	XOR_AL	swapmask,<db 00000011b>	; 0 if (PS2 xor LEFTHAND)
+		OPCODE_XOR_AL
+swapmask	db 00000011b
+;	end_
+@@swapeven:
 		;j	mouseupdate
 swapbuttons	endp
 
 mouseupdate	proc
-	CODE_	AND_AX
+;	CODE_	AND_AX
+		OPCODE_AND_AX
 buttonsmask	db	00000111b	; =8
 wheelmask	db	0
 		xchg	di,ax			; keep btn, wheel state in DI
@@ -781,11 +871,13 @@
 ;----- update mickey counters and screen position
 
 		xchg	ax,bx			; OPTIMIZE: instead MOV AX,BX
-		MOVREG_	bx,<offset X>
+;		MOVREG_	bx,<offset X>
+	xor bx,bx	; MOVREG optimizes mov bx,offset POINT.X into this
 		call	updateposition
 
 		xchg	ax,cx
-		MOVREG_	bl,<offset Y>		; OPTIMIZE: BL instead BX
+;		MOVREG_	bl,<offset Y>		; OPTIMIZE: BL instead BX
+	mov bl,offset POINT.Y
 		call	updateposition
 		or	cl,al			; bit 0=mickeys change flag
 
@@ -797,15 +889,17 @@
 		mov	al,dh			; wheel: signed 4 bit value
 		xor	al,00001000b	; =8
 		sub	al,00001000b	; =8	; sign extension AL[0:3]->AL
-	if_ nz					; if wheel moved
+;	if_ nz					; if wheel moved
+	jz @@wheelz
 		cbw
 		mov	si,TSRdref:wheel
-		add	[si].counter,ax		; wheel counter
+		add	[si + offset BUTTLASTSTATE.counter],ax	; wheel counter
 		add	[wheelUIR],al		; same, but used for the UIR
 		mov	al,10000000b	; =80h	; bit 7=wheel movement flag
 		xor	bx,bx
 		call	@lastpos
-	end_
+;	end_
+@@wheelz:
 
 ;----- update buttons state
 
@@ -813,7 +907,8 @@
 		xchg	dl,[buttstatus]
 		xor	dl,dh			; DL=buttons change state
 if FASTER_CODE
-	if_ nz
+;	if_ nz
+	jz @@btnfastz
 endif
 		xor	bx,bx			; buttpress array index
 		mov	al,00000010b		; mask for button 1
@@ -823,16 +918,21 @@
 		mov	al,00100000b		; mask for button 3
 		call	updatebutton
 if FASTER_CODE
-	end_
+;	end_
+@@btnfastz:
 endif
 
 ;----- call User Interrupt Routine (CX=events mask)
 
 		dec	[UIRunlock]
-	if_ zero				; if user proc not running
+;	if_ zero				; if user proc not running
+	jnz @@uirnz
 		and	cl,[callmask]
-	 if_ nz					; if there is a user events
-	CODE_	MOV_BX	buttstatus,<db 0,0>	; buttons status
+;	 if_ nz					; if there is a user events
+	jz @@maskz
+;	CODE_	MOV_BX	buttstatus,<db 0,0>	; buttons status
+		OPCODE_MOV_BX
+buttstatus	db 0,0
 		xchg	bh,[wheelUIR]
 		mov	ax,[granpos.X]
 		mov	dx,[granpos.Y]
@@ -843,9 +943,11 @@
 		sti
 		call	[UIR@]
 		pop	ds
-	 end_
+;	 end_
+@@maskz:
 		call	refreshcursor
-	end_
+;	end_
+@@uirnz:
 
 ;-----
 
@@ -864,43 +966,58 @@
 		test	ax,ax
 		jz	@@uposret
 		mov	si,ax
-	if_ sign
+;	if_ sign
+	jns @@upns
 		neg	ax
-	end_
+;	end_
+@@upns:
 
 ;----- apply sensitivity (SI=movement, AX=abs(SI))
 
 		mov	dx,word ptr senscoeff[bx] ; ~[1/3..3.0]*256
-		cmp	ax,4
-	if_ be
+;		cmp	ax,4	; JWASM uses "signed byte" variant
+	db 03dh, 4, 0	; "cmp ax, word 4"
+;	if_ be
+	ja @@upa
 		 mov	ax,si
 		 cmp	dh,1		; skip [-4..4] movements
 		 jae	@@newmickeys	;  when sensitivity >= 1.0
 		 imul	dx		; =mickeys*sensitivity
-	else_
-		cmp	ax,12
-	 if_ ae
+;	else_
+	jmp short @@upbe
+@@upa:
+;		cmp	ax,12	; JWASM uses "signed byte" variant
+	db 03dh, 12, 0	; "cmp ax, word 12"
+;	 if_ ae
 if FASTER_CODE
+	jb @@up2b
 		 mov	ax,dx
 		 shl	ax,1
 		 add	ax,dx		; =sensitivity*3
-	 else_
+;	 else_
+	jmp short @@up2ae
+@@up2b:
 		mul	dx
 		shr	ax,2		; =sensitivity*min(12,abs(mickeys))/4
-	 end_
+;	 end_
+@@up2ae:
 else
+	jb @@up2ae
 		 mov	ax,12
-	 end_
+;	 end_
+@@up2ae:
 		mul	dx
 		shr	ax,2		; =sensitivity*min(12,abs(mickeys))/4
 endif
 		imul	si		; DX:AX=mickeys*newsensitivity
-	end_
+;	end_
+@@upbe:
 		add	al,byte ptr sensround[bx]
 		mov	byte ptr sensround[bx],al
 		mov	al,ah		; remove 256 multiplier from
 		mov	ah,dl		;  sensitivity: AX=DX:AX/256
-		adc	ax,0		; add carry from previous adding
+;		adc	ax,0		; add carry from previous adding
+	db 15h, 0, 0	; JWASM uses signed byte variant, same length
 
 ;----- apply mickeys per 8 pixels ratio to calculate cursor position
 
@@ -931,14 +1048,16 @@
 
 ;----- cut new position by virtual ranges and save
 
-@savecutpos:	mov	dx,word ptr rangemax[bx]
+@savecutpos::	mov	dx,word ptr rangemax[bx]
 		cmp	ax,dx
 		jge	@@cutpos
 		mov	dx,word ptr rangemin[bx]
 		cmp	ax,dx
-	if_ le
+;	if_ le
+	jg @@cpg
 @@cutpos:	xchg	ax,dx			; OPTIMIZE: instead MOV AX,DX
-	end_
+;	end_
+@@cpg:
 		mov	word ptr pos[bx],ax	; new position
 		and	al,byte ptr granumask[bx]
 		mov	word ptr granpos[bx],ax	; new granulated position
@@ -960,20 +1079,24 @@
 ;
 updatebutton	proc
 		shr	dx,1
-	if_ carry				; if button changed
+;	if_ carry				; if button changed
+	jnc @@ubnc
 		mov	si,TSRdref:buttpress
 		test	dl,dl
-	 if_ ns					; if button not pressed
+;	 if_ ns					; if button not pressed
+	js @@ubs
 		add	al,al			; indicate that it released
 		mov	si,TSRdref:buttrelease
-	 end_
-		inc	[si+bx].counter
-@lastpos:	or	cl,al
+;	 end_
+@@ubs:
+		inc	word ptr [si + bx + offset BUTTLASTSTATE.counter]
+@lastpos::	or	cl,al
 		mov	ax,[granpos.Y]
-		mov	[si+bx].lastrow,ax
+		mov	[si + bx + offset BUTTLASTSTATE.lastrow],ax
 		mov	ax,[granpos.X]
-		mov	[si+bx].lastcol,ax
-	end_
+		mov	[si + bx + offset BUTTLASTSTATE.lastcol],ax
+;	end_
+@@ubnc:
 		add	bx,size BUTTLASTSTATE	; next button
 		ret
 updatebutton	endp
@@ -984,7 +1107,7 @@
 ;€€€€€€€€€€€€€€€€€€€€€€€€€€€€ INT 10 HANDLER €€€€€€€€€€€€€€€€€€€€€€€€€€€€
 
 if USERIL					; -X-
-		evendata
+		even
 RILtable	dw TSRcref:RIL_F0	; RIL functions
 		dw TSRcref:RIL_F1
 		dw TSRcref:RIL_F2
@@ -1030,12 +1153,13 @@
 		pop	ax
 		pushf
 		call	[oldint10]
-		push	ds es
+		push	ds
+		push	es
 		PUSHALL
 		MOVSEG	ds,cs,,@TSRdata
 		mov	[nocursorcnt],1		; normalize hide counter
 		call	setupvideo
-@@exitINT10:	jmp	@rethandler
+@@exitINT10:	jmp	rethandler
 
 if USERIL					; -X-
 ;===== RIL
@@ -1080,9 +1204,11 @@
 		mov	si,dx
 		mov	si,videoregs@[si].regs@
 		cmp	dx,20h
-	if_ below				; if not single register
+;	if_ below				; if not single register
+	jae @@rilf0ae
 		add	si,bx
-	end_
+;	end_
+@@rilf0ae:
 		lodsb
 		mov	byte ptr [_ARG_BX_],al
 		ret
@@ -1126,9 +1252,11 @@
 		mov	dx,videoregs@[di].port@
 		mov	videoregs@[di].rmodify?,dl ; OPTIMIZE: DL instead 1
 		mov	di,videoregs@[di].regs@
-	if_ below				; if not single register
+;	if_ below				; if not single register
+	jae @@rilwae
 		mov	bl,al
-	end_
+;	end_
+@@rilwae:
 		mov	[di+bx],ah
 		jae	RILoutAH
 		;j	RILgroupwrite
@@ -1145,10 +1273,12 @@
 ;
 RILgroupwrite	proc
 		cmp	dl,0C0h
-	if_ ne					; if not ATTR controller
+;	if_ ne					; if not ATTR controller
+	jz @@rilgwz
 		out	dx,ax	; <---
 		ret
-	end_
+;	end_
+@@rilgwz:
 		push	ax dx
 		mov	dx,videoregs@[(size RGROUPDEF)*5].port@
 		in	al,dx	; <---		; {3DAh} force address mode
@@ -1212,14 +1342,16 @@
 RILgrouploop:	xor	ax,ax
 		xchg	al,ch
 		add	di,ax
-	countloop_
+;	countloop_
+@@rilf3loop:
 		mov	ah,es:[bx]
 		mov	[di],ah
 		inc	bx
 		inc	di
 		call	RILgroupwrite
 		inc	ax			; OPTIMIZE: AX instead AL
-	end_
+;	end_
+		loop @@rilf3loop
 		ret
 RIL_F3		endp
 
@@ -1238,7 +1370,8 @@
 		assume	es:nothing
 		; -X- sti
 		mov	di,bx
-	countloop_
+;	countloop_
+@@rilf4loop:
 		mov	bx,es:[di]
 		movadd	di,,2
 		mov	bx,videoregs@[bx].regs@
@@ -1246,7 +1379,8 @@
 		inc	di
 		xlat
 		stosb
-	end_
+;	end_
+		loop @@rilf4loop
 		ret
 RIL_F4		endp
 
@@ -1264,12 +1398,14 @@
 RIL_F5		proc
 		assume	es:nothing
 		mov	si,bx
-	countloop_
+;	countloop_
+@@rilf5loop:
 		lods	word ptr es:[si]
 		xchg	dx,ax			; OPTIMIZE: instead MOV DX,AX
 		lods	word ptr es:[si]
 		call	RILwrite
-	end_
+;	end_
+		loop @@rilf5loop
 		ret
 RIL_F5		endp
 
@@ -1369,16 +1505,19 @@
 
 		call	gettxtoffset
 		cmp	di,[cursor@]
-	if_ eq					; exit if position not changed
+;	if_ eq					; exit if position not changed
+	jnz @@drnz
 		jcxz	@@drawret		;  and cursor not forced
-	end_
+;	end_
+@@drnz:
 		push	di
 		call	restorescreen
 		;MOVSEG	es,[videoseg],,nothing
 		pop	di
 
 		cmp	[cursortype],ch		; OPTIMIZE: CH instead 0
-	if_ nz
+;	if_ nz
+	jz @@drz
 
 ;----- position hardware text mode cursor
 
@@ -1389,11 +1528,17 @@
 		mov	dx,[crtc]		; 3d4 or 3b4
 endif						; -X- USERIL
 		mov	ax,di
-		out_	dx,0Fh,al		; cursor position lo
+;		out_	dx,0Fh,al		; cursor position lo
+		mov	ah,al
+		mov	al,0fh
+		out	dx,ax
 		xchg	ax,di			; OPTIMIZE: instead MOV AX,DI
-		out_	dx,0Eh,ah		; cursor position hi
+;		out_	dx,0Eh,ah		; cursor position hi
+		mov	al,0eh
+		out	dx,ax
 		ret
-	end_
+;	end_
+@@drz:
 
 ;----- draw software text mode cursor
 
@@ -1415,30 +1560,36 @@
 		les	di,dword ptr [cursor@]
 		assume	es:nothing
 		inc	di
-	if_ nz					; if cursor drawn
+;	if_ nz					; if cursor drawn
+	jz @@rsz
 		sub	[cursor@],di		; OPTIMIZE: instead MOV -1
 		mov	ax,[granumask.Y]
 		dec	di
 		inc	ax
 
-	 if_ zero
+;	 if_ zero
+	jnz @@rsnz
 
 ;----- graphics mode
 
 		call	restoresprite
 		jmp	restorevregs
-	 end_
+;	 end_
+@@rsnz:
 
 ;----- text mode
 
 		mov	si,TSRdref:textbuf
 		lodsw
 		cmp	ax,es:[di]
-	 if_ eq					; if screen not changed
+;	 if_ eq					; if screen not changed
+	jnz @@rsnz2
 		movsw				; restore old text char/attrib
-	 end_
-	end_
-@drawret:	ret
+;	 end_
+@@rsnz2:
+;	end_
+@@rsz:
+@drawret::	ret
 restorescreen	endp
 
 ;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
@@ -1457,16 +1608,20 @@
 		xchg	ax,bx
 		xor	dx,dx
 		neg	ax
-	if_ lt
+;	if_ lt
+	jge @@gcge
 		neg	ax
 		xchg	ax,dx
-	end_
+;	end_
+@@gcge:
 		mov	[spritetop],ax
 		mov	ax,[screenheight]
 		cmp	si,ax
-	if_ ge
+;	if_ ge
+	jl @@gclt
 		xchg	si,ax			; OPTIMIZE: instead MOV SI,AX
-	end_
+;	end_
+@@gclt:
 		sub	si,dx			; =spriteheight
 		push	si			;  =min(16-ax,screenheight-dx)
 		call	getgroffset
@@ -1478,23 +1633,35 @@
 		les	ax,dword ptr [cursor@]
 		assume	es:nothing
 		inc	ax
-	if_ nz					; if cursor drawn
-	CODE_	CMP_DI	cursorpos,<dw ?>
-	 if_ eq
+;	if_ nz					; if cursor drawn
+	jz @@cpz
+;	CODE_	CMP_DI	cursorpos,<dw ?>
+		OPCODE_CMP_DI
+cursorpos	dw ?
+;	 if_ eq
+	jnz @@cpnz2
 		cmp	dx,[spriteheight]
-	 andif_ eq				; exit if position not changed
+;	 andif_ eq				; exit if position not changed
+	jnz @@cpnz2
 		jcxz	@drawret		;  and cursor not forced
-	 end_
-		push	bx dx di
+;	 end_
+@@cpnz2:
+		push	bx
+		push	dx
+		push	di
 		dec	ax
 		xchg	di,ax			; OPTIMIZE: instead MOV DI,AX
 		call	restoresprite
 		;MOVSEG	es,[videoseg],,nothing
-		pop	di dx
-	else_
+		pop	di
+		pop	dx
+;	else_
+	jmp short @@cpnz
+@@cpz:
 		push	bx
 		call	updatevregs
-	end_
+;	end_
+@@cpnz:
 		pop	bx
 
 ; bx=X, di=line offset+bx, si=nextrow, dx=spriteheight, es=videoseg
@@ -1514,21 +1681,25 @@
 		mov	ax,[scanline]
 		add	dx,bx			; right sprite offset
 		cmp	dx,ax
-	if_ ae
+;	if_ ae
+	jb @@pspb
 		xchg	dx,ax			; DX=min(DX,scanline)
-	end_
+;	end_
+@@pspb:
 
 		pop	ax			; =cursorX
 		sub	cl,3			; mode 0Dh=1, other=0
 		and	ax,[granumask.X]	; fix for mode 4/5
 		sar	ax,cl			; sprite shift for non 13h modes
 		neg	bx			; sprite shift for 13h mode
-	if_ lt					; if left sprite offset>0
+;	if_ lt					; if left sprite offset>0
+	jge @@pspge
 		add	dx,bx
 		sub	di,bx
 		mov	bl,0
 		and	al,7			; shift in byte (X%8)
-	end_
+;	end_
+@@pspge:
 
 		inc	bx			; OPTIMIZE: BX instead BL
 		sub	al,8			; if cursorX>0
@@ -1542,22 +1713,36 @@
 		mov	al,0D6h			; screen source
 		call	copysprite		; save new sprite
 
-	CODE_	MOV_BX	spritetop,<dw ?>
-		pop	cx ax			; CL/CH=sprite shift
+;	CODE_	MOV_BX	spritetop,<dw ?>
+		OPCODE_MOV_BX
+spritetop	dw ?
+		pop	cx
+		pop	ax			; CL/CH=sprite shift
 						; AX=[spriteheight]
 						; SI=[nextrow]
 		add	bx,bx			; mask offset
-	countloop_ ,ax
-		push	ax cx bx si di
+;	countloop_ ,ax
+@@spriteloop:
+		push	ax
+		push	cx
+		push	bx
+		push	si
+		push	di
 		mov	si,[spritewidth]
 		mov	dx,word ptr screenmask[bx]
 		mov	bx,word ptr cursormask[bx]
 		call	makerow
-		pop	di si bx cx ax
+		pop	di
+		pop	si
+		pop	bx
+		pop	cx
+		pop	ax
 		add	di,si
 		xor	si,[nextxor]		; for interlaced mode?
 		movadd	bx,,2
-	end_
+;	end_
+	dec ax
+	jnz @@spriteloop
 
 ;-----
 
@@ -1583,9 +1768,9 @@
 		call	@registerset
 
 		mov	bx,TSRdref:vdata2
-@writevregs:	mov	ah,0F5h			; write register set
+@writevregs::	mov	ah,0F5h			; write register set
 
-@registerset:	; if planar videomode [0Dh-12h] then "push es" else "ret"
+@registerset::	; if planar videomode [0Dh-12h] then "push es" else "ret"
 		db	?
 		MOVSEG	es,ds,,@TSRdata
 		mov	cx,[bx-2]
@@ -1619,8 +1804,12 @@
 		cmp	al,0D6h
 		pushf				; whether to swap pointers
 		mov	NEXTOFFSCODE[1],al
-	CODE_	MOV_AX	nextrow,<dw ?>		; ax = next row offset
-	CODE_	MOV_BX	spriteheight,<dw ?>	; bx = sprite height in lines
+;	CODE_	MOV_AX	nextrow,<dw ?>		; ax = next row offset
+		OPCODE_MOV_AX
+nextrow		dw ?
+;	CODE_	MOV_BX	spriteheight,<dw ?>	; bx = sprite height in lines
+		OPCODE_MOV_BX
+spriteheight	dw ?
 
 		push	ax
 		mov	al,0BEh			; 1 for CGA / MCGA: MOV SI
@@ -1648,14 +1837,22 @@
 		lds	si,[buffer@]
 		assume	ds:nothing
 		popf				; whether to swap pointers
-	if_ eq
-		push	ds es
-		pop	ds es			; DS:SI=screen
-		xchg	si,di			; ES:DI=buffer
-	end_
-
-	countloop_ ,bx
-	CODE_	MOV_CX	spritewidth,<dw ?>	; seen part of sprite in bytes
+;	if_ eq
+	jnz @@blitnz
+		push	ds
+		push	es
+		pop	ds
+		pop	es			; DS:SI=screen
+;		xchg	si,di			; ES:DI=buffer
+		xchg	di,si	; JWASM and TASM use opposite encoding
+;	end_
+@@blitnz:
+
+;	countloop_ ,bx
+@@spritewloop:
+;	CODE_	MOV_CX	spritewidth,<dw ?>	; seen part of sprite in bytes
+		OPCODE_MOV_CX
+spritewidth	dw ?
 		movsub	dx,ax,cx		; mov dx,ax sub dx,cx
 		; instead of movsb inside a000:x, one could possibly do
 		; out 3ce,4 read/stosb out 3ce,104 read/stosb out 3ce,204
@@ -1664,8 +1861,12 @@
 		rep	movsb			; -X- now for CGA EGA VGA MCGA
 
 NEXTOFFSCODE	db	01h,0d6h		; ADD SI,DX/ADD DI,DX
-	CODE_	XOR_AX	nextxor,<dw ?>		; for interlace modes?
-	end_	; of outer countloop_
+;	CODE_	XOR_AX	nextxor,<dw ?>		; for interlace modes?
+		OPCODE_XOR_AX
+nextxor		dw ?
+;	end_	; of outer countloop_
+	dec bx
+	jnz @@spritewloop
 
 BLITCODE	db 90h				; for the label ;-)
 		call restore3ce			; CALL or nop-ish MOV SI
@@ -1692,55 +1893,77 @@
 makerow		proc
 		assume	es:nothing
 		cmp	[bitmapshift],1		; =1 for 13h mode
-	if_ eq
+;	if_ eq
+	jnz @@mrnz
 
 ;-----
 
-	 countloop_ ,si				; loop over x pixels
+;	 countloop_ ,si				; loop over x pixels
+@@pixloop:
 		shl	bx,cl			; if MSB=0
-		sbb	al,al			; ...then AL=0
+;		sbb	al,al			; ...then AL=0
+	db 1ah, 0c0h	; JWASM and TASM use opposite encoding
 		and	al,0Fh			; ...else AL=0Fh (WHITE color)
 		shl	dx,cl
-	  if_ carry				; if most sign bit nonzero
+;	  if_ carry				; if most sign bit nonzero
+	jnc @@mrnc
 		xor	al,es:[di]
-	  end_
+;	  end_
+@@mrnc:
 		stosb
 		mov	cl,1
-	 end_ countloop
+;	 end_ countloop
+		dec si
+		jnz @@pixloop
 		ret
-	end_ if
+;	end_ if
+@@mrnz:
 
 ;----- display cursor row in modes other than 13h
 
 makerowno13:	call 	backup3ce
 
 		mov	ax,0FFh
-	loop_					; shift masks left until ch++ is 0
+;	loop_					; shift masks left until ch++ is 0
+@@m13zloop:
 		add	dx,dx
 		adc	al,al
 		inc	dx			; al:dh:dl shifted screenmask
 		add	bx,bx
 		adc	ah,ah			; ah:bh:bl shifted cursormask
 		inc	ch
-	until_ zero
-		xchg	dh,bl			; al:bl:dl - ah:bh:dh
+;	until_ zero
+	jnz @@m13zloop
+;		xchg	dh,bl			; al:bl:dl - ah:bh:dh
+		xchg	bl,dh	; JWASM and TASM use opposite encoding
 
-	countloop_ ,si
+;	countloop_ ,si
+@@m13loop:
 		push	dx
 ; ***		push	bx			; must be omitted, but why?
 		mov	dx,es
 		cmp	dh,0A0h
-	 if_ ne					; if not planar mode 0Dh-12h
+;	 if_ ne					; if not planar mode 0Dh-12h
+	jz @@m13z
 		and	al,es:[di]
 		xor	al,ah
 		stosb
-	 else_
+;	 else_
+	jmp short @@m13nz
+@@m13z:
 		xchg	cx,ax			; OPTIMIZE: instead MOV CX,AX
 if 1	; OLD BUT WORKING
-		out_	3CEh,5,0		; set write mode 0: "color: reg2 mask: reg8"
-		out_	,3,8h			; data ANDed with latched data
+;		out_	3CEh,5,0		; set write mode 0: "color: reg2 mask: reg8"
+		mov	dx,3ceh
+		mov	ax,5
+		out	dx,ax
+;		out_	,3,8h			; data ANDed with latched data
+		mov	ax,803h
+		out	dx,ax
 		xchg	es:[di],cl
-		out_	,3,18h			; data XORed with latched data
+;		out_	,3,18h			; data XORed with latched data
+		mov	ax,1803h
+		out	dx,ax
 		xchg	es:[di],ch
 else	; NEW BUT NO TRANSPARENCY
 		mov	dx,3ceh			; graphics controller
@@ -1763,13 +1986,16 @@
 		mov	byte ptr es:[di],15	; color
 endif
 		inc	di
-	 end_
+;	 end_
+@@m13nz:
 		xchg	ax,bx			; OPTIMIZE: instead MOV AX,BX
 		pop	bx			; why was this push dx - pop bx?
 ; ***		pop	dx			; must be omitted, but why?
-	end_ countloop
+;	end_ countloop
+	dec si
+	jnz @@m13loop
 
-restore3ce:	push	dx
+restore3ce::	push	dx
 		push	ax
 		mov	dx,3ceh			; graphics controller
 SEQ3		db	0b8h,3,0		; mov ax,0003
@@ -1786,7 +2012,7 @@
 
 ;----- backup 4 EGA+ graphics controller registers, can only read VGA, not from EGA
 
-backup3ce:	push	dx
+backup3ce::	push	dx
 		push	ax
 		mov	dx,3ceh			; graphics controller
 		mov	al,3			; operator / pan, pan is 3 LSB
@@ -1877,7 +2103,7 @@
 		sar	ax,2			; AX=row*2=Y/4
 		mov	dx,[VIDEO_width]	; screen width
 
-@getoffsret:	imul	dx			; AX=row*screen width
+@getoffsret::	imul	dx			; AX=row*screen width
 		add	ax,[VIDEO_pageoff]	; add video page offset
 		add	di,ax
 		ret
@@ -1905,8 +2131,12 @@
 		cmp	bx,[screenheight]
 		jge	@@retunseen		; fail if Y>maxY
 
-	CODE_	MOV_CL	bitmapshift,<db ?>	; mode 13h=1, 0Dh=4, other=3
-	CODE_	MOV_DX	cursorwidth,<dw ?>	; cursor width in bytes
+;	CODE_	MOV_CL	bitmapshift,<db ?>	; mode 13h=1, 0Dh=4, other=3
+		OPCODE_MOV_CL
+bitmapshift	db ?
+;	CODE_	MOV_DX	cursorwidth,<dw ?>	; cursor width in bytes
+		OPCODE_MOV_DX
+cursorwidth	dw ?
 		sar	ax,cl
 		add	dx,ax
 		jle	@@retunseen		; fail if X+width<=0
@@ -1940,7 +2170,7 @@
 
 setupvideo	proc
 		mov	si,szClearArea2/2	; clear area 2
-ERRIF (szClearArea2 mod 2 ne 0) "szClearArea2 must be even!"
+; ERRIF (szClearArea2 mod 2 ne 0) "szClearArea2 must be even!"
 		j	@setvideo
 setupvideo	endp
 
@@ -1964,11 +2194,11 @@
 		memcopy	szDefArea,ds,@TSRdata,@TSRdata:RedefArea,,,@TSRdata:DefArea
 		call	hidecursor		; restore screen contents
 		mov	si,szClearArea3/2	; clear area 3
-ERRIF (szClearArea3 mod 2 ne 0) "szClearArea3 must be even!"
+; ERRIF (szClearArea3 mod 2 ne 0) "szClearArea3 must be even!"
 
 ;----- setup video regs values for current video mode
 
-@setvideo:	push	si
+@setvideo::	push	si
 		MOVSEG	es,ds,,@TSRdata		; push ds pop es, assume...
 		MOVSEG	ds,0,ax,BIOS		; xor ax,ax mov ds,ax
 		mov	ax,[CRTC_base]		; base IO address of CRTC
@@ -1984,32 +2214,44 @@
 
 ;-----
 
-	block_
+;	block_
 		mov	ah,9
 		cmp	al,11h			; VGA videomodes?
-	 breakif_ ae
+;	 breakif_ ae
+	jae @@blend
 
 		cbw				; OPTIMIZE: instead MOV AH,0
 		cmp	al,0Fh			; 0F-10 videomodes?
-	 if_ ae
-		testflag [VIDEO_control],mask VCTRL_RAM_64K
-	  breakif_ zero				; break if only 64K of VRAM
+;	 if_ ae
+	jb @@blb
+;		testflag [VIDEO_control],mask VCTRL_RAM_64K
+		test [VIDEO_control],60h	; mask VCTRL_RAM_64K
+		; value ?nn????? where n+1 = 64kBy blocks of RAM installed
+;	  breakif_ zero				; break if only 64K of VRAM
+	jz @@blend
 		mov	ah,2
-	 else_
+;	 else_
+	jmp short @@blend
+@@blb:
 		cmp	al,4			; not color text modes?
-	 andif_ below
+;	 andif_ below
+	jnb @@blend
 		xchg	cx,ax			; OPTIMIZE: instead MOV CX,AX
 		mov	al,[VIDEO_switches]	; get display combination
-		maskflag al,mask VIDSW_feature0+mask VIDSW_display
+;		maskflag al,mask VIDSW_feature0+mask VIDSW_display
+		and al,mask VIDSW_feature0+mask VIDSW_display
 		cmp	al,9			; EGA+ECD/MDA?
 		je	@@lines350
 		cmp	al,3			; MDA/EGA+ECD?
-	  if_ eq
+;	  if_ eq
+	jnz @@blnz
 @@lines350:	mov	ch,13h
-	  end_
+;	  end_
+@@blnz:
 		xchg	ax,cx			; OPTIMIZE: instead MOV AX,CX
-	 end_ if
-	end_ block
+;	 end_ if
+;	end_ block
+@@blend:
 
 ;-----
 
@@ -2037,16 +2279,18 @@
 
 		pop	si			; initialize area of defaults
 		;mov	di,TSRdref:DefVRegsArea
-ERRIF (DefVRegsArea ne VRegsArea+64) "VRegs area contents corrupted!"
+; ERRIF (DefVRegsArea ne VRegsArea+64) "VRegs area contents corrupted!"
 		memcopy	szVRegsArea,,,,es,@TSRdata	; NOTE: changes es assume!
 
 		dec	ax			; OPTIMIZE: instead MOV AL,0
 		mov	cx,8
 		mov	di,TSRdref:videoregs@[0].rmodify?
-	countloop_
+;	countloop_
+@@setvloop:
 		stosb
 		add	di,(size RGROUPDEF)-1
-	end_
+;	end_
+	loop @@setvloop
 else						; -X-
 ; ***		MOVSEG	es,ds,,@TSRdata		; -X- push ds pop es, assume...
 		assume	es:nothing		; -X-
@@ -2079,15 +2323,18 @@
 		mov	cx,0304h		; 16x8: [0-1]
 		mov	di,200			; x200: [4-6,0Dh-0Eh,13h]
 		cmp	al,2
-	if_ ae
+;	if_ ae
+	jb @@stb
 		dec	cx			; 8x8: [2-3,7]
 		cmp	al,4
-	andif_ ae
+;	andif_ ae
+	jb @@stb
 ; mode 7
 		cmp	al,7
 		jne	@@checkgraph
 		mov	dh,0B0h			; B000h: [7]
-	end_
+;	end_
+@@stb:
 
 @@settext:	mov	ch,1
 		mov	bh,0F8h
@@ -2095,7 +2342,8 @@
 
 		MOVSEG	es,0,ax,BIOS		; xor ax,ax mov es,ax assume
 		add	al,[VIDEO_lastrow]	; screen height-1
-	if_ nz					; zero on old machines
+;	if_ nz					; zero on old machines
+	jz @@stz
 		inc	ax			; OPTIMIZE: AX instead AL
 if USE_286
 		shl	ax,3
@@ -2104,7 +2352,8 @@
 		mul	ah
 endif
 		xchg	di,ax			; OPTIMIZE: instead MOV DI,AX
-	end_
+;	end_
+@@stz:
 		mov	ax,[VIDEO_width]	; screen width
 		j	@@setcommon
 
@@ -2196,18 +2445,21 @@
 
 ;----- set cursor position (CX=X, DX=Y, SI=area size to clear)
 
-@setpos:	nop	;cli			; -X-
+@setpos::	nop	;cli			; -X-
 		MOVSEG	es,ds,,@TSRdata
 		mov	di,TSRdref:ClearArea
-		xchg	cx,si
+;		xchg	cx,si
+		xchg	si,cx	; JWASM and TASM use opposite encoding
 		xor	ax,ax
 		rep	stosw
 
 		xchg	ax,dx			; OPTIMIZE: instead MOV AX,DX
-		MOVREG_	bx,<offset Y>
+;		MOVREG_	bx,<offset Y>
+		mov	bx,offset POINT.Y
 		call	@savecutpos
 		xchg	ax,si			; OPTIMIZE: instead MOV AX,SI
-		MOVREG_	bl,<offset X>		; OPTIMIZE: BL instead BX
+;		MOVREG_	bl,<offset X>		; OPTIMIZE: BL instead BX
+		mov	bl,offset POINT.X
 		jmp	@savecutpos
 softreset_21	endp
 
@@ -2235,7 +2487,8 @@
 
 		mov	al,[disabled?]
 		test	al,al
-	if_ zero				; if driver not disabled
+;	if_ zero				; if driver not disabled
+	jnz @@ddrvnz
 		mov	[buttstatus],al
 		inc	ax			; OPTIMIZE: instead MOV AL,1
 		mov	[nocursorcnt],al	; normalize hide counter
@@ -2250,10 +2503,10 @@
 		cmp	dx,cx
 		jne	althandler_18
 
-		;mov	ah,35h
+		; DOSGetIntr 10h
+		; mov	ah,35h
 		mov	al,10h
 		int	21h
-		;DOSGetIntr 10h
 		movsub	ax,es,cx
 		jne	althandler_18
 
@@ -2262,7 +2515,8 @@
 		lds	dx,[oldint10]
 		assume	ds:nothing
 		DOSSetIntr 10h			; restore old INT 10 handler
-	end_ if
+;	end_ if
+@@ddrvnz:
 		ret
 disabledrv_1F	endp
 		assume	ds:@TSRdata
@@ -2323,7 +2577,8 @@
 enabledriver_20	proc
 		xor	cx,cx
 		xchg	cl,[disabled?]
-	if_ ncxz
+;	if_ ncxz
+	jcxz @@edcxz
 
 ;----- set new INT 10 handler
 
@@ -2333,9 +2588,13 @@
 		push	ds	; -X-
 		push	cs	; -X-
 		pop	ds	; -X-
-		DOSSetIntr ,,,@TSRcode:int10handler
+;		DOSSetIntr ,,,@TSRcode:int10handler
+		mov	dx,@TSRcode:int10handler
+		mov	ah,25h
+		int	21h
 		pop	ds	; -X-
-	end_
+;	end_
+@@edcxz:
 
 ;-----
 
@@ -2402,7 +2661,7 @@
 ;
 releasedata_06	proc
 		mov	cx,TSRdref:buttrelease-(size BUTTLASTSTATE)
-@retbuttstat:	mov	ah,byte ptr [wheel.counter]
+@retbuttstat::	mov	ah,byte ptr [wheel.counter]
 		mov	al,[buttstatus]
 		mov	[_ARG_AX_],ax
 		xor	ax,ax
@@ -2415,19 +2674,21 @@
 		xor	cx,cx
 		xor	dx,dx
 		cmp	bx,2+1
-	if_ be
-ERRIF (6 ne size BUTTLASTSTATE) "BUTTLASTSTATE structure size changed!"
+;	if_ be
+	ja @@rlpa
+; ERRIF (6 ne size BUTTLASTSTATE) "BUTTLASTSTATE structure size changed!"
 		add	bx,bx
 		add	si,bx			; SI+BX=buttrelease
 		add	bx,bx			;  +button*size BUTTLASTSTATE
 
-@@retlastpos:	xchg	[si+bx.counter],ax
-		mov	cx,[si+bx.lastcol]
-		mov	dx,[si+bx.lastrow]
-	end_ if
-@retBCDX:	mov	[_ARG_DX_],dx
-@retBCX:	mov	[_ARG_CX_],cx
-@retBX:		mov	[_ARG_BX_],ax
+@@retlastpos:	xchg	[si + bx + offset BUTTLASTSTATE.counter],ax
+		mov	cx,[si+bx + offset BUTTLASTSTATE.lastcol]
+		mov	dx,[si+bx + offset BUTTLASTSTATE.lastrow]
+;	end_ if
+@@rlpa:
+@retBCDX::	mov	[_ARG_DX_],dx
+@retBCX::	mov	[_ARG_CX_],cx
+@retBX::	mov	[_ARG_BX_],ax
 		ret
 releasedata_06	endp
 
@@ -2465,7 +2726,9 @@
 ;
 wheelAPI_11	proc
 		mov	[_ARG_AX_],574Dh
-	CODE_	MOV_CX	wheelflags,<db 0,0>
+;	CODE_	MOV_CX	wheelflags,<db 0,0>
+		OPCODE_MOV_CX
+wheelflags	db 0,0
 		xor	ax,ax
 		j	@retBCX
 wheelAPI_11	endp
@@ -2582,7 +2845,8 @@
 ; Call:	@setnewrange
 ;
 hrange_07	proc
-		MOVREG_	bx,<offset X>
+;		MOVREG_	bx,<offset X>
+		xor bx,bx	; MOVREG optimizes mov bx,offset POINT.X ...
 		j	@setnewrange
 hrange_07	endp
 
@@ -2598,16 +2862,19 @@
 ; Call:	setpos_04
 ;
 vrange_08	proc
-		MOVREG_	bx,<offset Y>
+;		MOVREG_	bx,<offset Y>
+		mov	bx,offset POINT.Y
 if FOOLPROOF
-@setnewrange:	xchg	ax,cx			; OPTIMIZE: instead MOV AX,CX
+@setnewrange::	xchg	ax,cx			; OPTIMIZE: instead MOV AX,CX
 		cmp	ax,dx
-	if_ ge
+;	if_ ge
+	jl @@snrl
 		xchg	ax,dx
-	end_
+;	end_
+@@snrl:
 		mov	word ptr rangemin[bx],ax
 else
-@setnewrange:	mov	word ptr rangemin[bx],cx
+@setnewrange::	mov	word ptr rangemin[bx],cx
 endif
 		mov	word ptr rangemax[bx],dx
 		mov	cx,[pos.X]
@@ -2628,7 +2895,7 @@
 ;
 setpos_04	proc
 		mov	si,szClearArea1/2	; clear area 1
-ERRIF (szClearArea1 mod 2 ne 0) "szClearArea1 must be even!"
+; ERRIF (szClearArea1 mod 2 ne 0) "szClearArea1 must be even!"
 		call	@setpos
 		;j	refreshcursor
 setpos_04	endp
@@ -2641,13 +2908,15 @@
 		js	@@refreshdone		; was -1: queue already used
 		sti
 
-	loop_
+;	loop_
+@@rcloop:
 		call	drawcursor
 @@refreshdone:	inc	[videolock]		; drawing stopped
-	until_ nz				; loop until queue empty
+;	until_ nz				; loop until queue empty
+	jz @@rcloop
 
 		cli
-@showret:	ret
+@showret::	ret
 refreshcursor	endp
 
 ;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
@@ -2670,10 +2939,12 @@
 		mov	si,TSRdref:hotspot
 		lodsw
 		cmp	ax,bx
-	if_ eq
+;	if_ eq
+	jnz @@gc9nz
 		lodsw
 		xor	ax,cx
-	andif_ eq
+;	andif_ eq
+	jnz @@gc9nz
 		mov	di,dx
 		;mov	ah,0
 		mov	al,16+16
@@ -2681,18 +2952,25 @@
 		repe	cmpsw
 		je	@showret		; exit if cursor not changed
 		xchg	cx,ax			; OPTIMIZE: instead MOV CX,AX
-	end_
+;	end_
+@@gc9nz:
 
 ;----- copy user shape to internal area
 
-		push	ds ds es
-		pop	ds es
+		push	ds
+		push	ds
+		push	es
+		pop	ds
+		pop	es
 		mov	di,TSRdref:hotspot
 		xchg	ax,bx			; OPTIMIZE: instead MOV AX,BX
 		stosw
 		xchg	ax,cx			; OPTIMIZE: instead MOV AX,CX
 		stosw
-		memcopy	2*(16+16),,,,,,dx
+;		memcopy	2*(16+16),,,,,,dx
+		mov si,dx
+		mov cx, 16+16
+		rep	movsw
 		pop	ds
 		;j	redrawcursor
 graphcursor_09	endp
@@ -2700,7 +2978,7 @@
 ;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
 
 redrawcursor	proc
-hidecursor:	mov	[newcursor],1		; force cursor redraw
+hidecursor::	mov	[newcursor],1		; force cursor redraw
 		j	refreshcursor
 redrawcursor	endp
 
@@ -2717,21 +2995,27 @@
 ; Call:	INT 10/01, @showret, redrawcursor
 ;
 textcursor_0A	proc
-		xchg	cx,bx
-	if_ ncxz				; if hardware cursor
+;		xchg	cx,bx
+		xchg	bx,cx	; TASM and JWASM use opposite encodings
+;	if_ ncxz				; if hardware cursor
+	jcxz @@tcacxz
 		mov	ch,bl
 		mov	cl,dl
 		mov	ah,1
 		int	10h			; set cursor shape & size
 		mov	cl,1
-	end_
+;	end_
+@@tcacxz:
 		cmp	cl,[cursortype]
-	if_ eq
+;	if_ eq
+	jnz @@tcanz
 		cmp	bx,[startscan]
-	andif_ eq
+;	andif_ eq
+	jnz @@tcanz
 		cmp	dx,[endscan]
 		je	@showret		; exit if cursor not changed
-	end_
+;	end_
+@@tcanz:
 
 ;-----
 
@@ -2756,16 +3040,20 @@
 		mov	ax,[_ARG_SI_]
 if FOOLPROOF
 		cmp	cx,ax
-	if_ ge
+;	if_ ge
+	jl @@ur10l
 		xchg	cx,ax
-	end_
+;	end_
+@@ur10l:
 		mov	[upleft.X],cx
 		mov	[lowright.X],ax
 		xchg	ax,di			; OPTIMIZE: instead MOV AX,DI
 		cmp	dx,ax
-	if_ ge
+;	if_ ge
+	jl @@ur10l2
 		xchg	dx,ax
-	end_
+;	end_
+@@ur10l2:
 		mov	[upleft.Y],dx
 		mov	[lowright.Y],ax
 else
@@ -2794,7 +3082,11 @@
 ;;-		cmp	bx,szSaveArea		;!!! TurboPascal IDE
 ;;-		jb	@stateret		;  workaround: garbage in BX
 endif
-		memcopy	szSaveArea,,,dx,,,@TSRdata:SaveArea
+;		memcopy	szSaveArea,,,dx,,,@TSRdata:SaveArea
+		mov di,dx
+		mov si,@TSRdata:SaveArea
+		mov cx,szSaveArea/2	; happens to be even
+		rep movsw
 @stateret:	ret
 savestate_16	endp
 
@@ -2827,9 +3119,11 @@
 
 ;----- change SaveArea
 
-		push	es dx
+		push	es
+		push	dx
 		MOVSEG	es,ds,,@TSRdata
-		pop	si ds
+		pop	si
+		pop	ds
 		assume	ds:nothing
 		memcopy	szSaveArea,,,@TSRdata:SaveArea
 		MOVSEG	ds,es,,@TSRdata
@@ -2922,13 +3216,16 @@
 sensitivity_0F	proc
 if FOOLPROOF
 		test	dx,dx
-	if_ nz					; ignore wrong ratio
-	andif_ ncxz				; ignore wrong ratio
+;	if_ nz					; ignore wrong ratio
+	jz @@sensfp
+;	andif_ ncxz				; ignore wrong ratio
+	jcxz @@sensfp
 endif
 		mov	[mickey8.X],cx
 		mov	[mickey8.Y],dx
 if FOOLPROOF
-	end_
+;	end_
+@@sensfp:
 endif
 		ret
 sensitivity_0F	endp
@@ -2947,10 +3244,12 @@
 ;
 sensitivity_1A	proc
 		xchg	ax,bx			; OPTIMIZE: instead MOV AX,BX
-		MOVREG_	bx,<offset X>
+;		MOVREG_	bx,<offset X>
+	xor bx,bx	; MOVREG optimizes	mov bx,offset POINT.X
 		call	senscalc
 		xchg	ax,cx			; OPTIMIZE: instead MOV AX,CX
-		MOVREG_	bl,<offset Y>		; OPTIMIZE: BL instead BX
+;		MOVREG_	bl,<offset Y>		; OPTIMIZE: BL instead BX
+	mov bl,offset POINT.Y
 		;j	senscalc
 sensitivity_1A	endp
 
@@ -2964,20 +3263,26 @@
 ;
 senscalc	proc
 		dec	ax
-		cmp	ax,100			; ignore original values
-	if_ below				;  outside [1..100]
+;		cmp	ax,100			; ignore original values
+	db 3dh, 100, 0	; "cmp ax, word 100"
+		; JWASM encodes this in the "byte 100" syntax, same size
+;	if_ below				;  outside [1..100]
+	jnc @@scnc
 		mov	word ptr sensval[bx],ax
 		mul	ax			; DX:AX=V^2 (0<=X^2<10000)
 		add	ax,3600/3
 		;adc	dx,0			; DX:AX=V^2+1200
 		;mov	dh,0
 		;xchg	dh,dl
-		xchg	dl,al
-		xchg	dl,ah			; DX:AX=(V^2+1200)*256
+;		xchg	dl,al
+		xchg	al,dl	; JWASM and TASM use opposite encoding
+;		xchg	dl,ah			; DX:AX=(V^2+1200)*256
+		xchg	ah,dl	; JWASM and TASM use opposite encoding
 		mov	di,3600
 		div	di			; AX=(V^2+1200)*256/3600
 		mov	word ptr senscoeff[bx],ax
-	end_
+;	end_
+@@scnc:
 		ret
 senscalc	endp
 
@@ -3012,7 +3317,7 @@
 ;				INT 33 handler
 ;‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
 
-		evendata
+		even
 handler33table	dw TSRcref:resetdriver_00
 		dw TSRcref:showcursor_01
 		dw TSRcref:hidecursor_02
@@ -3052,7 +3357,8 @@
 		assume	ds:nothing,es:nothing
 		cld
 		test	ah,ah
-	if_ zero
+;	if_ zero
+	jnz @@h33nz
 		push	ds
 		MOVSEG	ds,cs,,@TSRdata
 		cmp	al,21h
@@ -3063,9 +3369,11 @@
 		mov	bp,sp
 		add	si,si
 		call	handler33table[si]	; call by calculated offset
-@rethandler:	POPALL
-		pop	es ds
-	end_
+rethandler::	POPALL
+		pop	es
+		pop	ds
+;	end_
+@@h33nz:
 		iret
 		assume	ds:@TSRdata
 
@@ -3085,10 +3393,14 @@
 ; Use:	driverversion
 ;
 version_24:	cmp	al,24h
-	if_ eq
+;	if_ eq
+	jnz @@v24nz
 		mov	bx,driverversion
-	CODE_	MOV_CX	mouseinfo,<db ?,4>
-	end_
+;	CODE_	MOV_CX	mouseinfo,<db ?,4>
+		OPCODE_MOV_CX
+mouseinfo	db ?,4
+;	end_
+@@v24nz:
 
 ;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
 ; 26 - Get maximum virtual screen coordinates
@@ -3098,16 +3410,24 @@
 ; Use:	bitmapshift
 ;
 maxscreen_26:	cmp	al,26h
-	if_ eq
+;	if_ eq
+	jnz @@m26nz
 		mov	cl,[bitmapshift]
-	CODE_	MOV_BX	scanline,<dw ?>
-	CODE_	MOV_DX	screenheight,<dw ?>
+;	CODE_	MOV_BX	scanline,<dw ?>
+		OPCODE_MOV_BX
+scanline	dw ?
+;	CODE_	MOV_DX	screenheight,<dw ?>
+		OPCODE_MOV_DX
+screenheight	dw ?
 		shl	bx,cl
 		dec	dx
 		mov	cx,bx
 		dec	cx
-	CODE_	MOV_BX	disabled?,<db 1,0>	; 1=driver disabled
-	end_
+;	CODE_	MOV_BX	disabled?,<db 1,0>	; 1=driver disabled
+		OPCODE_MOV_BX
+disabled?	db 1,0
+;	end_
+@@m26nz:
 
 ;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
 ; 27 - Get screen/cursor masks and mickey counters
@@ -3119,7 +3439,8 @@
 ; Modf:	mickeys
 ;
 cursor_27:	cmp	al,27h
-	if_ eq
+;	if_ eq
+	jnz @@c27nz
 		mov	ax,[startscan]
 		mov	bx,[endscan]
 		xor	cx,cx
@@ -3128,7 +3449,8 @@
 		xchg	dx,[mickeys.Y]
 		pop	ds
 		iret
-	end_
+;	end_
+@@c27nz:
 
 ;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
 ; 31 - Get current virtual cursor coordinates
@@ -3139,14 +3461,16 @@
 ; Use:	rangemin, rangemax
 ;
 cursrange_31:	cmp	al,31h
-	if_ eq
+;	if_ eq
+	jnz @@c31nz
 		mov	ax,[rangemin.X]
 		mov	bx,[rangemin.Y]
 		lds	cx,[rangemax]
 		mov	dx,ds
 		pop	ds
 		iret
-	end_
+;	end_
+@@c31nz:
 
 ;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
 ; 32 - Get supported advanced functions flag
@@ -3156,7 +3480,8 @@
 ;	[BX] = 0
 ;
 active_32:	cmp	al,32h
-	if_ eq
+;	if_ eq
+	jnz @@a32nz
 if USE28
 		mov	ax,0111010000001100b	; active: 26 27 28 2A 31 32
 else
@@ -3167,7 +3492,8 @@
 @iretBX0:	xor	bx,bx
 		pop	ds
 		iret
-	end_
+;	end_
+@@a32nz:
 
 ;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
 ; 4D - Get pointer to copyright string
@@ -3175,10 +3501,12 @@
 ; Use:	IDstring
 ;
 copyright_4D:	cmp	al,4Dh
-	if_ eq
+;	if_ eq
+	jnz @@c4dnz
 		MOVSEG	es,cs,,@TSRcode
 		mov	di,TSRcref:IDstring
-	end_
+;	end_
+@@c4dnz:
 
 ;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
 ; 6D - Get pointer to version
@@ -3186,10 +3514,12 @@
 ; Use:	msversion
 ;
 version_6D:	cmp	al,6Dh
-	if_ eq
+;	if_ eq
+	jnz @@v6dnz
 		MOVSEG	es,cs,,@TSRcode
 		mov	di,TSRcref:msversion
-	end_
+;	end_
+@@v6dnz:
 
 if USE28
 ;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
@@ -3201,10 +3531,12 @@
 ; Call:	none
 ;
 setvidmode_28:	cmp	al,28h
-	if_ eq
+;	if_ eq
+	jnz @@v28nz
 		push	ax bx bp		;!!! some BIOSes trash BP
 		test	ch,ch			; VESA mode >= 100h
-	 if_ zero
+;	 if_ zero
+	jnz @@v28nz2
 		mov	ax,cx
 		;mov	ah,0
 		int	10h			; set the video mode in AL
@@ -3212,7 +3544,8 @@
 		int	10h			; get current video mode
 		cmp	al,cl			; CL=requested video mode
 		je	@@setmoderet0		; return if successful
-	 end_
+;	 end_
+@@v28nz2:
 		mov	bx,cx
 		mov	ax,4F02h
 		int	10h			; set VESA video mode in BX
@@ -3221,7 +3554,8 @@
 
 @@setmoderet0:	xor	cx,cx			; CX=0 if successful
 @@setmoderet:	pop	bp bx ax		; CX=requested mode or 0
-	end_
+;	end_
+@@v28nz:
 endif
 
 ;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
@@ -3233,13 +3567,17 @@
 ; Use:	nocursorcnt, hotspot
 ;
 hotspot_2A:	cmp	al,2Ah
-	if_ eq
+;	if_ eq
+	jnz @@h2anz
 		;mov	ah,0
 		mov	al,[nocursorcnt]
 		lds	bx,[hotspot]
 		mov	cx,ds
-	CODE_	MOV_DX	mouseinfo1,<db 4,0>
-	end_
+;	CODE_	MOV_DX	mouseinfo1,<db 4,0>
+		OPCODE_MOV_DX
+mouseinfo1	db 4,0
+;	end_
+@@h2anz:
 
 		pop	ds
 		iret
@@ -3248,12 +3586,12 @@
 ;€€€€€€€€€€€€€€€€€€€€€€€€ END OF INT 33 SERVICES €€€€€€€€€€€€€€€€€€€€€€€€
 
 
-RILversion	label
+RILversion	label byte
 msversion	db driverversion / 100h,driverversion mod 100h
 IDstring	db 'CuteMouse ',CTMVER,0
 szIDstring = $ - IDstring
 
-TSRend		label
+TSRend		label byte
 
 
 ;€€€€€€€€€€€€€€€€€€€€€€€ INITIALIZATION PART DATA €€€€€€€€€€€€€€€€€€€€€€€
@@ -3280,6 +3618,7 @@
 OPT_MSYS	equ    100000b
 OPT_lefthand	equ   1000000b
 OPT_noUMB	equ  10000000b
+
 OPT_newTSR	equ 100000000b
 OPT_Wheel	equ 1000000000b
 
@@ -3288,8 +3627,9 @@
 
 .code
 
-say		macro	stroff:vararg
-		MOVOFF_	di,<stroff>
+say		macro	stroff ; :vararg
+;		MOVOFF_	di,<stroff>
+	mov di,offset stroff
 		call	sayASCIIZ
 endm
 
@@ -3313,34 +3653,50 @@
 ;-----
 
 		mov	ax,[options]
-		testflag ax,OPT_PS2+OPT_serial
-	if_ zero				; if no /S and /P then
-		setflag	ax,OPT_PS2+OPT_serial	;  both PS2 and serial assumed
-	end_
+;		testflag ax,OPT_PS2+OPT_serial
+		test	al, OPT_PS2+OPT_serial	; value is 3, TASM optimizes
+;	if_ zero				; if no /S and /P then
+	jnz @@sonz
+;		setflag	ax,OPT_PS2+OPT_serial	;  both PS2 and serial assumed
+		or al, OPT_PS2+OPT_serial	; value is 3, TASM optimizes
+;	end_
+@@sonz:
 ;---
-		testflag ax,OPT_PS2after
-	if_ nz
+;		testflag ax,OPT_PS2after
+		test al, OPT_PS2after		; 8, TASM optimizes this
+;	if_ nz
+	jz @@paz
 		call	searchCOM		; call if /V
 		jnc	@@serialfound
-	end_
+;	end_
+@@paz:
 ;---
-		testflag ax,OPT_PS2+OPT_PS2after
-	if_ nz
+;		testflag ax,OPT_PS2+OPT_PS2after
+		test al, OPT_PS2+OPT_PS2after	; 9, TASM optimizes this
+;	if_ nz
+	jz @@p2z
 		push	ax
 		call	checkPS2		; call if /V or PS2
 		pop	ax
-	andif_ nc
+;	andif_ nc
+	jc @@p2z
 		mov	mouseinfo[0],bh
 		j	@@mousefound
-	end_
+;	end_
+@@p2z:
 ;---
-		testflag ax,OPT_PS2after
-	if_ zero
-		testflag ax,OPT_serial+OPT_MSYS	; 2008: better than +nomsys?
-	andif_ nz
+;		testflag ax,OPT_PS2after
+ 		test al, OPT_PS2after	; 8, TASM optimizes this
+;	if_ zero
+	jnz @@panz
+;		testflag ax,OPT_serial+OPT_MSYS	; 2008: better than +nomsys?
+		test al, OPT_serial+OPT_MSYS	; 22h, TASM optimizes this
+;	andif_ nz
+	jz @@panz
 		call	searchCOM		; call if no /V and serial
 		jnc	@@serialfound
-	end_
+;	end_
+@@panz:
 		mov	di,dataref:E_notfound	; 'Error: device not found'
 		jmp	EXITENABLE
 
@@ -3355,13 +3711,15 @@
 
 ;----- check if CuteMouse driver already installed
 
-		testflag ax,OPT_newTSR
+;		testflag ax,OPT_newTSR
+		test ah, OPT_newTSR shr 8	; ax,100h, TASM optimizes
 		jnz	@@newTSR
 		call	getCuteMouse
 		mov	di,dataref:S_reset	; 'Resident part reset to'
 		mov	cx,4C02h		; terminate, al=return code
 
-	if_ ne
+;	if_ ne
+	jz @@mfz
 
 ;----- allocate UMB memory, if possible, and set INT 33 handler
 
@@ -3377,46 +3735,61 @@
 		pop	ax
 		mov	di,dataref:S_installed	; 'Installed at'
 		mov	cl,0			; errorlevel
-	end_ if
+;	end_ if
+@@mfz:
 
 ;-----
 
 		push	ax			; size of TSR for INT 21/31
-		say	di
+;		say	di
+		call    sayASCIIZ
 		mov	al,[mousetype]
 
 		mov	bx,dataref:S_CRLF
 		add	al,al
-	if_ carry				; if wheel (=8xh)
+;	if_ carry				; if wheel (=8xh)
+	jnc @@mfnc
 		mov	bx,dataref:S_wheel
-	end_
+;	end_
+@@mfnc:
 
 		cbw				; OPTIMIZE: instead MOV AH,0
 		cmp	al,1 shl 1
 		xchg	si,ax			; OPTIMIZE: instead MOV SI,AX
-	if_ ae					; if not PS/2 mode (=0)
-	 if_ eq					; if Mouse Systems (=1)
+;	if_ ae					; if not PS/2 mode (=0)
+	jb @@mfb
+;	 if_ eq					; if Mouse Systems (=1)
+	 jnz @@mfnz
 		inc	cx			; OPTIMIZE: CX instead CL
-	 end_
+;	 end_
+@@mfnz:
 		say	@data:S_atCOM
-	end_
+;	end_
+@@mfb:
 		push	cx			; exit function and errorlevel
 		say	S_mousetype[si]
-		say	bx
+;		say	bx
+		mov	di,bx
+		call    sayASCIIZ
 		call	setupdriver
 
 ;----- close all handles (20 pieces) to prevent decreasing system
 ;	pool of handles if INT 21/31 used
 
 		mov	bx,19
-	loop_
-		DOSCloseFile
+;	loop_
+@@mfns:
+;		DOSCloseFile
+		mov	ah,3eh
+		int	21h
 		dec	bx
-	until_ sign
+;	until_ sign
+	jns @@mfns
 
 ;-----
 
-		pop	ax dx			; AH=31h (TSR) or 4Ch (EXIT)
+		pop	ax			; AH=31h (TSR) or 4Ch (EXIT)
+		pop	dx
 		int	21h
 
 ;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
@@ -3431,15 +3804,18 @@
 		int	10h			; get display type in BX
 		cmp	al,1Ah
 ; if USERIL					; -X-
-	if_ eq
+;	if_ eq
+	jnz @@sdnz
 		xchg	ax,bx			; OPTIMIZE: instead MOV AL,BL
 		sub	al,7
 		cmp	al,8-7
-	andif_ be					; if monochrome or color VGA
+;	andif_ be					; if monochrome or color VGA
+	ja @@sdnz
 if USERIL
 		inc	videoregs@[(size RGROUPDEF)*3].regscnt
 endif
-	end_
+;	end_
+@@sdnz:
 ; else
 if 1						; -X-
 		; *** SAY error if AL not 1ah: need VGA as we have no RIL ***
@@ -3451,70 +3827,93 @@
 
 ;----- setup left hand mode handling
 
-	CODE_	MOV_CX	mousetype,<db ?,0>	; 0=PS/2,1=MSys,2=LT,3=MS,
+;	CODE_	MOV_CX	mousetype,<db ?,0>	; 0=PS/2,1=MSys,2=LT,3=MS,
+		OPCODE_MOV_CX
+mousetype	db ?,0
 						; 80h=PS/2+wheel,83h=MS+wheel
 		test	cl,7Fh
 		mov	al,00000000b	; =0
-	if_ nz					; if not PS/2 mode (=x0h)
+;	if_ nz					; if not PS/2 mode (=x0h)
+	jz @@mtz
 		mov	al,00000011b	; =3
-	end_
-		testflag [options],OPT_lefthand
-	if_ nz
+;	end_
+@@mtz:
+;		testflag [options],OPT_lefthand
+		test byte ptr [options], OPT_lefthand	; 40h, TASM optimizes
+;	if_ nz
+	jz @@mtz2
 		xor	al,00000011b	; =3
-	end_
+;	end_
+@@mtz2:
 		mov	[swapmask],al
 
 ;----- setup buttons count, mask and wheel flags
 
 		mov	al,3
-		testflag [options],OPT_3button
-	if_ zero
+;		testflag [options],OPT_3button
+		test byte ptr [options], OPT_3button	; 10h, TASM optimizes
+;	if_ zero
+	jnz @@mtnz
 		jcxz	@@setbuttons		; jump if PS/2 mode (=0)
 		cmp	cl,al			; OPTIMIZE: AL instead 3
-	andif_ eq				; if MS mode (=3)
+;	andif_ eq				; if MS mode (=3)
+	jnz @@mtnz
 @@setbuttons:	mov	[buttonsmask],al	; OPTIMIZE: AL instead 0011b
 		dec	ax
 		mov	[buttonscnt],al		; OPTIMIZE: AL instead 2
-	end_
+;	end_
+@@mtnz:
 
 		cmp	cl,80h			; if some wheel protocol
-	if_ ae
+;	if_ ae
+	jb @@mtb
 		inc	wheelflags[0]		; report "wheel present"
 		mov	[wheelmask],00001111b	; =0Fh
-	end_
+;	end_
+@@mtb:
 
 ;----- setup mouse handlers code
 
-	block_
+;	block_
 		test	cl,7Fh
-	 breakif_ zero				; break if PS/2 mode (=x0h)
+;	 breakif_ zero				; break if PS/2 mode (=x0h)
+	jz @@mtblock
 
 ; -X-		fixcode	IRQproc,0B0h,%OCW2<OCW2_EOI> ; MOV AL,OCW2<OCW2_EOI>
 		fixnear	enableproc,enableUART
 		fixnear	disableproc,disableUART
 		dec	cx
-	 breakif_ zero				; break if Mouse Systems mode (=1)
+;	 breakif_ zero				; break if Mouse Systems mode (=1)
+	jz @@mtblock
 
 		fixnear	mouseproc,MSLTproc
 		dec	cx
-	 breakif_ zero				; break if Logitech mode (=2)
+;	 breakif_ zero				; break if Logitech mode (=2)
+	jz @@mtblock
 
 		fixcode	MSLTCODE3,,2
 		loop	@@setother		; break if wheel mode (=83h)
 
 		cmp	al,2			; OPTIMIZE: AL instead [buttonscnt]
-	 if_ ne					; if not MS2
+;	 if_ ne					; if not MS2
+	jz @@mtbz
 		fixcode	MSLTCODE2,075h		; JNZ
-	 end_
+;	 end_
+@@mtbz:
 		mov	al,0C3h			; RET
 		fixcode	MSLTCODE1,al
 		fixcode	MSLTCODE3,al
-	end_ block
+;	end_ block
+@@mtblock:
 
 ;----- setup, if required, other parameters
 
-@@setother:	push	es ds es ds
-		pop	es ds			; get back [oldint10]...
+@@setother:	push	es
+		push	ds
+		push	es
+		push	ds
+		pop	es
+		pop	ds			; get back [oldint10]...
 		memcopy	<size oldint10>,es,,@TSRdata:oldint10,ds,,@TSRdata:oldint10
 		mov	al,[disabled?]
 		pop	ds
@@ -3537,9 +3936,11 @@
 
 		pop	ax
 		pushf				;!!! Logitech MouseWare
-		push	cs ax			;  Windows driver workaround
+		push	cs
+		push	ax			;  Windows driver workaround
 		mov	ax,TSRcref:handler33
-		push	es ax
+		push	es
+		push	ax
 		xor	ax,ax			; reset driver
 		nop				; -X-
 		retf				; jump to relocated INT33
@@ -3555,11 +3956,13 @@
 		call	COMloop
 		jnc	@searchret
 
-		testflag [options],OPT_MSYS
+;		testflag [options],OPT_MSYS
+		test byte ptr [options], OPT_MSYS	; 20h, TASM optimizes
 		stc
 		jz	@searchret
 
-		mov	[LCRset],LCR<0,,LCR_noparity,0,3>
+;		mov	[LCRset],LCR<0,,LCR_noparity,0,3>
+		mov	[LCRset],3
 		mov	bl,1			; =Mouse Systems mode
 		mov	di,coderef:checkUART
 		;j	COMloop
@@ -3570,11 +3973,13 @@
 COMloop		proc
 		push	ax
 		xor	ax,ax			; scan only current COM port
-		testflag [options],OPT_COMforced
+;		testflag [options],OPT_COMforced
+		test byte ptr [options], OPT_COMforced	; 4, TASM optimizes
 		jnz	@@checkCOM
 		mov	ah,3			; scan all COM ports
 
-	loop_
+;	loop_
+@@ccns:
 		inc	ax			; OPTIMIZE: AX instead AL
 		push	ax
 		call	setCOMport
@@ -3585,11 +3990,12 @@
 		pop	ax
 		jnc	@@searchbreak
 		dec	ah
-	until_ sign
+;	until_ sign
+	jns @@ccns
 		;stc				; preserved from prev call
 
 @@searchbreak:	pop	ax
-@searchret:	ret
+@searchret::	ret
 COMloop		endp
 
 ;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
@@ -3610,7 +4016,8 @@
 
 		movidx	dx,MCR_index,si		; {3FCh} MCR (modem ctrl reg)
 		 in	ax,dx			; {3FDh} LSR (line status reg)
-		testflag al,mask MCR_reserved+mask MCR_AFE
+;		testflag al,mask MCR_reserved+mask MCR_AFE
+		test al, mask MCR_reserved+mask MCR_AFE
 		 jnz	@@noUART
 		movidx	dx,LSR_index,si,MCR_index
 		 in	al,dx			; {3FDh} LSR (line status reg)
@@ -3620,17 +4027,25 @@
 ;----- check LCR function
 
 		cli
-		movidx	dx,LCR_index,si,LSR_index
+		movidx	dx,LCR_index,si,LSR_index	; "dec dx dec dx"
 		 in	al,dx			; {3FBh} LCR (line ctrl reg)
 		 push	ax
-		out_	dx,%LCR<1,0,-1,-1,3>	; {3FBh} LCR: DLAB on, 8S2
+;		out_	dx,%LCR<1,0,-1,-1,3>	; {3FBh} LCR: DLAB on, 8S2
+;		mov	al,%LCR<1,0,-1,-1,3>
+		mov	al,10111111b
+		out	dx,al
 		 inb	ah,dx
-		out_	dx,%LCR<0,0,0,0,2>	; {3FBh} LCR: DLAB off, 7N1
+;		out_	dx,%LCR<0,0,0,0,2>	; {3FBh} LCR: DLAB off, 7N1
+;		mov	al,%LCR<0,0,0,0,2>
+		mov	al,00000010b
+		out	dx,al
 		 in	al,dx
 		sti
-		sub	ax,(LCR<1,0,-1,-1,3> shl 8)+LCR<0,0,0,0,2>
+;		sub	ax,(LCR<1,0,-1,-1,3> shl 8)+LCR<0,0,0,0,2>
+		sub	ax, (10111111b shl 8) + 00000010b
 
-	if_ zero				; zero if LCR conforms
+;	if_ zero				; zero if LCR conforms
+	jnz @@lcrnz
 
 ;----- check IER for reserved bits
 
@@ -3639,7 +4054,8 @@
 		movidx	dx,LCR_index,si,IER_index
 		;mov	ah,0
 		and	al,mask IER_reserved	; reserved bits should be clear
-	end_ if
+;	end_ if
+@@lcrnz:
 
 		neg	ax			; nonzero makes carry flag
 		pop	ax
@@ -3676,7 +4092,11 @@
 ;----- reset UART: drop RTS line, interrupts and disable FIFO
 
 		;movidx	dx,LCR_index,si		; {3FBh} LCR: DLAB off
-		 out_	dx,%LCR<>,%MCR<>	; {3FCh} MCR: DTR/RTS/OUT2 off
+;		 out_	dx,%LCR<>,%MCR<>	; {3FCh} MCR: DTR/RTS/OUT2 off
+;		mov	al,0	; %LCR<>
+;		mov	ah,0	; %MCR<>
+	xor ax,ax	; the out_ macro optimizes this
+		out	dx,ax
 		movidx	dx,IER_index,si,LCR_index
 		 ;mov	ax,(FCR<> shl 8)+IER<>	; {3F9h} IER: interrupts off
 		 out	dx,ax			; {3FAh} FCR: disable FIFO
@@ -3684,67 +4104,103 @@
 ;----- set communication parameters and flush receive buffer
 
 		movidx	dx,LCR_index,si,IER_index
-		 out_	dx,%LCR{LCR_DLAB=1}	; {3FBh} LCR: DLAB on
-		xchg	dx,si
+;		 out_	dx,%LCR{LCR_DLAB=1}	; {3FBh} LCR: DLAB on
+;		mov	al,%LCR{LCR_DLAB=1} 
+		mov	al,80h
+		out	dx,al
+;		xchg	dx,si
+		xchg	si,dx	; TASM and JWASM use opposite encodings
 		 ;mov	ah,0			; 1200 baud rate
-		 out_	dx,96,ah		; {3F8h},{3F9h} divisor latch
-		xchg	dx,si
-		 out_	dx,[LCRset]		; {3FBh} LCR: DLAB off, 7/8N1
+;		 out_	dx,96,ah		; {3F8h},{3F9h} divisor latch
+		mov	al,96
+		out	dx,ax
+;		xchg	dx,si
+		xchg	si,dx	; TASM and JWASM use opposite encodings
+;		 out_	dx,[LCRset]		; {3FBh} LCR: DLAB off, 7/8N1
+		mov	al,[LCRset]
+		out	dx,al
 		movidx	dx,RBR_index,si,LCR_index
 		 in	al,dx			; {3F8h} flush receive buffer
 
 ;----- wait current+next timer tick and then raise RTS line
 
 		MOVSEG	es,0,ax,BIOS
-	loop_
+;	loop_
+@@tmrnz:
 		mov	ah,byte ptr [BIOS_timer]
-	 loop_
+;	 loop_
+@@tmrz:
 		cmp	ah,byte ptr [BIOS_timer]
-	 until_ ne				; loop until next timer tick
+;	 until_ ne				; loop until next timer tick
+	jz @@tmrz
 		xor	al,1
-	until_ zero				; loop until end of 2nd tick
+;	until_ zero				; loop until end of 2nd tick
+	jnz @@tmrnz
 
 		movidx	dx,MCR_index,si,RBR_index
-		 out_	dx,%MCR<,,,0,,1,1>	; {3FCh} MCR: DTR/RTS on, OUT2 off
+;		 out_	dx,%MCR<,,,0,,1,1>	; {3FCh} MCR: DTR/RTS on, OUT2 off
+;		mov	al,%MCR<,,,0,,1,1>
+		mov al,00000011b
+		out	dx,al
 
 ;----- detect if Microsoft or Logitech mouse present
 
 		mov	bx,0103h		; bl=mouse type, bh=no `M'
-	countloop_ 4,cl				; scan 4 first bytes
-	 countloop_ 2+1,ch			; length of silence in ticks
+;	countloop_ 4,cl				; scan 4 first bytes
+	mov cl,4
+@@clloop:
+;	 countloop_ 2+1,ch			; length of silence in ticks
+	mov ch,2+1
+@@chloop:
 						; (include rest of curr tick)
 		mov	ah,byte ptr [BIOS_timer]
-	  loop_
+;	  loop_
+@@zloop:
 		movidx	dx,LSR_index,si
 		 in	al,dx			; {3FDh} LSR (line status reg)
-		testflag al,mask LSR_RBF
+;		testflag al,mask LSR_RBF
+		test al, mask LSR_RBF
 		 jnz	@@parse			; jump if data ready
 		cmp	ah,byte ptr [BIOS_timer]
-	  until_ ne				; loop until next timer tick
-	 end_ countloop				; loop until end of 2nd tick
-	 break_					; break if no more data
+;	  until_ ne				; loop until next timer tick
+	jz @@zloop
+;	 end_ countloop				; loop until end of 2nd tick
+	dec ch
+	jnz @@chloop
+; 	 break_					; break if no more data
+	jmp short @@clloopend
 
 @@parse:	movidx	dx,RBR_index,si
 		 in	al,dx			; {3F8h} receive byte
 		cmp	al,'('-20h
-	 breakif_ eq				; break if PnP data starts
+;	 breakif_ eq				; break if PnP data starts
+	jz @@clloopend
 		cmp	al,'M'			; PnP: microsoft?
-	 if_ eq
+;	 if_ eq
+	jnz @@prsnz
 		mov	bh,0			; MS compatible mouse found...
-	 end_
+;	 end_
+@@prsnz:
 		cmp	al,'Z'			; PnP: wheel?
-	 if_ eq
-; Only for PS2, wheel detection is a risk, so never disable COM wheel check
-;		testflag [options],OPT_Wheel
-;	if_ nz
+;	 if_ eq
+	jnz @@prsnz2
+; * Only for PS2, wheel detection is a risk, so never disable COM wheel check
+; *		testflag [options],OPT_Wheel
+; *	if_ nz
 		mov	bl,83h			; ...MS mouse+wheel found
-;	end_	; else leave bx = 103 (from above) = MS without wheel
-	 end_
+; *	end_	; else leave bx = 103 (from above) = MS without wheel
+;	 end_
+@@prsnz2:
 		cmp	al,'3'			; PnP: logitech?
-	 if_ eq
+;	 if_ eq
+	jnz @@prsnz3
 		mov	bl,2			; ...Logitech mouse found
-	 end_
-	end_ countloop
+;	 end_
+@@prsnz3:
+;	end_ countloop
+	dec cl
+	jnz @@clloop
+@@clloopend:
 
 		movidx	dx,LCR_index,si
 		 pop	ax			; {3FBh} LCR: restore contents
@@ -3774,7 +4230,8 @@
 @@noPS2y:	jmp	@@noPS2			; no supported type
 @@ps2foo:
 		int	11h			; get equipment list
-		testflag al,mask HW_PS2
+;		testflag al,mask HW_PS2
+		test al, mask HW_PS2
 		jz	@@noPS2y		; jump if PS/2 not indicated
 		mov	bh,3			; standard 3 byte packets
 		PS2serv 0C205h,@@noPS2y		; initialize mouse, bh=datasize
@@ -3802,8 +4259,10 @@
 		MOVSEG	es,0,bx,nothing
 		PS2serv	0C207h			; clear mouse handler (ES:BX=0)
 
-		testflag [options],OPT_Wheel	; dare to try PS2 wheel?
-	if_ nz
+;		testflag [options],OPT_Wheel	; dare to try PS2 wheel?
+		test byte ptr [options+1], OPT_Wheel shr 8	; TASM optimizes
+;	if_ nz
+	jz @@ps2wz
 ;----- select IntelliMouse Z wheel + 3 button mode, via magic rate handshake
 
 		mov	ah,200
@@ -3815,7 +4274,8 @@
 		mov	ah,80
 		call	setRate			; 200->100->80 rate does this
 		jc	@@noPS2z
-	end_
+;	end_
+@@ps2wz:
 
 ;----- check if successful
 
@@ -3846,10 +4306,18 @@
 @@PS2valid2:
 		xor	bx,bx			; =PS/2 mouse found
 		cmp	ah,3			; ID=3 -> 3 button+wheel mode
-	if_ eq
-		testflag [options],OPT_Wheel
-	if_ nz		; patch a jump short from to PS2PLAIN into to PS2WHEEL:
-		mov	PS2WHEELCODE[1],PS2WHEEL-PS2WHEELCODE-2
+;	if_ eq
+	jnz @@ps2w2
+;		testflag [options],OPT_Wheel
+		test byte ptr [options+1], OPT_Wheel shr 8 ; TASM optimizes
+;	if_ nz		; patch a jump short from to PS2PLAIN into to PS2WHEEL:
+	jz @@ps2w2
+;		mov	PS2WHEELCODE[1], PS2WHEEL - PS2WHEELCODE - 2
+; ...		push	bx
+; ...		mov	bx,offset PS2WHEELCODE + 2	; enable wheel
+; ...		mov	word ptr cs:[bx], -1	; make test return NZ
+; ...		pop	bx
+		mov	byte ptr [PS2WHEELCODE+1],PS2WHEEL-PS2WHEELCODE-2
 		mov	bl,80h			; =PS/2+wheel mouse
 
 		push	ax
@@ -3867,8 +4335,9 @@
 		jc	@@noPS2w
 		pop	bx
 		pop	ax
-	end_
-	end_
+;	end_
+;	end_
+@@ps2w2:
 
 ;-----
 
@@ -4014,7 +4483,8 @@
 ; Call:	setIRQ
 ;
 setCOMport	proc
-		push	ax di
+		push	ax
+		push	di
 		add	al,'0'
 		mov	[com_port],al
 
@@ -4029,7 +4499,8 @@
 		MOVSEG	es,ds,,@data
 		_word_hex
 
-		pop	di ax
+		pop	di
+		pop	ax
 		and	al,1			; 1=COM1/3, 0=COM2/4
 		add	al,3			; IRQ4 for COM1/3
 		;j	setIRQ			; IRQ3 for COM2/4
@@ -4078,10 +4549,12 @@
 		call	mousedrv
 		mov	si,TSRcref:IDstring
 		cmp	di,si
-	if_ eq
+;	if_ eq
+	jnz @@gcmnz
 		mov	cx,szIDstring
 		repe	cmpsb
-	end_
+;	end_
+@@gcmnz:
 		ret
 getCuteMouse	endp
 
@@ -4097,11 +4570,13 @@
 ;
 mousedrv	proc
 		mov	cx,word ptr oldint33[2]
-	if_ ncxz
+;	if_ ncxz
+	jcxz @@mdcxz
 		mov	ah,0
 		pushf				;!!! Logitech MouseWare
 		call	[oldint33]		;  Windows driver workaround
-	end_
+;	end_
+@@mdcxz:
 		ret
 mousedrv	endp
 
@@ -4115,15 +4590,18 @@
 _serialopt	proc
 		mov	bx,(4 shl 8)+1
 		call	parsedigit
-	if_ nc					; '/Sc' -> set COM port
-		setflag	[options],OPT_COMforced
+;	if_ nc					; '/Sc' -> set COM port
+	jc @@soc
+;		setflag	[options],OPT_COMforced
+		or byte ptr [options], OPT_COMforced	; TASM optimizes
 		call	setCOMport
 
 		;mov	bl,1
 		mov	bh,7
 		call	parsedigit
 		jnc	setIRQ			; '/Sci' -> set IRQ line
-	end_
+;	end_
+@@soc:
 		ret
 _serialopt	endp
 
@@ -4135,24 +4613,26 @@
 		;mov	ah,0
 		mov	bx,(9 shl 8)+0
 		call	parsedigit		; first argument
-	if_ nc
+;	if_ nc
+	jc @@resc
 		mov	ah,al
 		;mov	bx,(9 shl 8)+0
 		call	parsedigit		; second argument
 		jnc	@@setres		; jump if digit present
-	end_
+;	end_
+@@resc:
 		mov	al,ah			; replicate missing argument
 
 @@setres:	add	ax,0101h
 		push	ax			; AL=RY+1, AH=RX+1
 		mov	al,10
 		mul	ah			; AX=10*(RX+1)
-		mov	bx,offset X+(DefArea-SaveArea)
+		mov	bx,offset POINT.X+(DefArea-SaveArea)
 		call	senscalc
 		pop	ax
 		mov	ah,10
 		mul	ah			; AX=10*(RY+1)
-		mov	bx,offset Y+(DefArea-SaveArea)
+		mov	bx,offset POINT.Y+(DefArea-SaveArea)
 		jmp	senscalc
 _resolution	endp
 
@@ -4172,16 +4652,18 @@
 		;_ch2digit
 		sub	al,'0'
 		cmp	al,bh
-	if_ be
+;	if_ be
+	ja @@pda
 		cmp	al,bl
 		jae	@ret			; JAE mean CF=0
-	end_
+;	end_
+@@pda:
 		cmp	al,10
 		mov	cx,dataref:E_argument	; 'Error: Invalid argument'
 		jb	BADOPTION		; error if decimal digit
 		dec	si
 		stc
-@ret:		ret
+@ret::		ret
 parsedigit	endp
 
 ;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
@@ -4203,31 +4685,31 @@
 ;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
 .const
 
-OPTION		struc
+cmOPTION	struc	; OPTION is a reserved word in some MASM / TASM
   optchar	db ?
   optmask	dw 0
   optproc@	dw ?
-ends
+cmOPTION ends
 
-OPTABLE		OPTION <'P',OPT_PS2,			@ret>
-		OPTION <'O',OPT_Wheel,			@ret>
-		OPTION <'S',OPT_serial,			_serialopt>
-		OPTION <'V',OPT_PS2after,		@ret>
-		OPTION <'3' and not 20h,OPT_3button,	@ret>
-		OPTION <'R',,				_resolution>
-		OPTION <'L',OPT_lefthand,		@ret>
-		OPTION <'B',,				_checkdriver>
-		OPTION <'N',OPT_newTSR,			@ret>
-		OPTION <'W',OPT_noUMB,			@ret>
-		OPTION <'U',,				unloadTSR>
-		OPTION <'?' and not 20h,,		EXITMSG>
+OPTABLE		cmOPTION <'P',OPT_PS2,			@ret>
+		cmOPTION <'O',OPT_Wheel,			@ret>
+		cmOPTION <'S',OPT_serial,			_serialopt>
+		cmOPTION <'V',OPT_PS2after,		@ret>
+		cmOPTION <'3' and not 20h,OPT_3button,	@ret>
+		cmOPTION <'R',,				_resolution>
+		cmOPTION <'L',OPT_lefthand,		@ret>
+		cmOPTION <'B',,				_checkdriver>
+		cmOPTION <'N',OPT_newTSR,			@ret>
+		cmOPTION <'W',OPT_noUMB,			@ret>
+		cmOPTION <'U',,				unloadTSR>
+		cmOPTION <'?' and not 20h,,		EXITMSG>
 		; ignore the old "disable mouse systems" option
 		; default is now to disable old mouse systems, as
 		; those can be confused with empty serial ports.
-		OPTION <'Y',,				@ret>
+		cmOPTION <'Y',,				@ret>
 		; new option to "enable mouse systems"...
-		OPTION <'M',OPT_MSYS,			@ret>
-OPTABLEend	label
+		cmOPTION <'M',OPT_MSYS,			@ret>
+OPTABLEend	label byte
 
 .code
 
@@ -4235,40 +4717,51 @@
 ; In:	DS:SI			(null terminated command line)
 ;
 commandline	proc
-	loop_
+;	loop_
+@@clloop:
 		lodsb
 		test	al,al
 		jz	@ret			; exit if end of command line
 		cmp	al,' '
-	until_ above				; skips spaces and controls
+;	until_ above				; skips spaces and controls
+	jbe @@clloop
 
 		cmp	al,'/'			; option character?
-	if_ eq
+;	if_ eq
+	jnz @@clnz
 		lodsb
 		and	al,not 20h		; uppercase
 		mov	di,dataref:Syntax	; 'Options:'
 		mov	bx,dataref:OPTABLE
-	 loop_
-		cmp	al,[bx].optchar
-	  if_ eq
-		mov	ax,[bx].optmask
+;	 loop_
+@@cloloop:
+		cmp	al,[bx + offset cmOPTION.optchar]
+;	  if_ eq
+	jnz @@clonz
+		mov	ax,[bx + offset cmOPTION.optmask]
 		or	[options],ax
-		call	[bx].optproc@
+		call	[bx + offset cmOPTION.optproc@]
 		j	commandline
-	  end_
-		add	bx,size OPTION
+;	  end_
+@@clonz:
+		add	bx,size cmOPTION
 		cmp	bx,dataref:OPTABLEend
-	 until_ ae
-	end_ if
+;	 until_ ae
+	jb @@cloloop
+;	end_ if
+@@clnz:
 
 		mov	cx,dataref:E_option	; 'Error: Invalid option'
-BADOPTION:	say	@data:E_error		; 'Error: Invalid '
-		say	cx			; 'option'/'argument'
+BADOPTION::	say	@data:E_error		; 'Error: Invalid '
+;		say	cx			; 'option'/'argument'
+		mov	di,cx
+		call	sayASCIIZ
 		mov	di,dataref:E_help	; 'Enter /? on command line'
 
-EXITMSG:	mov	bl,[di]
+EXITMSG::	mov	bl,[di]
 		inc	di
-		say	di
+;		say	di
+		call	sayASCIIZ
 		say	@data:S_CRLF
 		xchg	ax,bx			; OPTIMIZE: instead MOV AL,BL
 		.exit				; terminate, al=return code
@@ -4282,13 +4775,15 @@
 ; Call:	none
 ;
 sayASCIIZ_	proc
-	loop_
+;	loop_
+@@sazloop:
 		mov	ah,2
 		int	21h		; write character in DL to stdout
 		inc	di
-sayASCIIZ:	mov	dl,[di]
+sayASCIIZ::	mov	dl,[di]
 		test	dl,dl
-	until_ zero
+;	until_ zero
+	jnz @@sazloop
 		ret
 sayASCIIZ_	endp
 
@@ -4312,16 +4807,22 @@
 
 		cmp	al,1Fh
 		mov	di,dataref:E_notunload	; 'Driver unload failed...'
-	if_ eq
+;	if_ eq
+	jnz @@unlnz
 		saveFAR	[oldint33],cx,bx
 		push	ds
-		DOSSetIntr 33h,cx,,bx		; restore old int33 handler
+;		DOSSetIntr 33h,cx,,bx		; restore old int33 handler
+		mov	dx,bx
+		mov	ax,2533h
+		mov	ds,cx
+		int	21h
 		pop	ds
 		call	FreeMem
 		mov	di,dataref:S_unloaded	; 'Driver successfully unloaded...'
-	end_
+;	end_
+@@unlnz:
 
-EXITENABLE:	mov	al,20h			; enable old/current driver
+EXITENABLE::	mov	al,20h			; enable old/current driver
 		call	mousedrv
 		j	EXITMSG
 unloadTSR	endp
@@ -4340,16 +4841,19 @@
 prepareTSR	proc
 		assume	ds:PSP
 		mov	cx,[env_seg]
-	if_ ncxz				; suggested by Matthias Paul
+;	if_ ncxz				; suggested by Matthias Paul
+	jcxz @@prepcxz
 		DOSFreeMem cx			; release environment block
-	end_
+;	end_
+@@prepcxz:
 		assume	ds:@data
 
 		call	AllocUMB
 		mov	ax,ds
 		mov	ch,31h			; TSR exit, al=return code
 		cmp	dx,ax
-	if_ ne					; if TSR not "in place"
+;	if_ ne					; if TSR not "in place"
+	jz @@prepz
 		push	ds
 		dec	ax			; current MCB
 		dec	dx			; target MCB...
@@ -4360,11 +4864,13 @@
 		mov	[MCB:ownerID],dx	; ...set owner to itself
 
 		mov	ch,4Ch			; terminate, al=return code
-	end_ if
+;	end_ if
+@@prepz:
 		mov	es,dx
-		mov	es:[PSP:DOS_exit],cx	; memory shouldn't be
+;		mov	es:[PSP:DOS_exit],cx	; memory shouldn't be
 						;  interpreted as PSP
 						;  (CX != 20CDh)
+		mov	es:[0],cx	; JWASM complains about es:PSP:...
 		ret
 prepareTSR	endp
 
@@ -4385,17 +4891,20 @@
 		DOSGetIntr 2Fh			; suggested by Matthias Paul
 		mov	cx,es
 		stc
-	if_ ncxz				; if INT 2F initialized
+;	if_ ncxz				; if INT 2F initialized
+	jcxz @@gxacxz
 		mov	ax,4300h
 		int	2Fh			; XMS: installation check
 		cmp	al,80h
 		stc
-	andif_ eq				; if XMS service present
+;	andif_ eq				; if XMS service present
+	jnz @@gxacxz
 		mov	ax,4310h		; XMS: Get Driver Address
 		int	2Fh
 		saveFAR [XMSentry],es,bx
 		clc
-	end_
+;	end_
+@@gxacxz:
 		ret
 getXMSaddr	endp
 endif
@@ -4427,9 +4936,13 @@
 ; Call:	INT 21/5801, INT 21/5803
 ;
 RestoreStrategy	proc
-	CODE_	MOV_BX	SaveMemStrat,<dw ?>
+;	CODE_	MOV_BX	SaveMemStrat,<dw ?>
+		OPCODE_MOV_BX
+SaveMemStrat	dw ?
 		DOSSetAlloc			; set DOS alloc strategy
-	CODE_	MOV_BX	SaveUMBLink,<db ?,0>
+;	CODE_	MOV_BX	SaveUMBLink,<db ?,0>
+		OPCODE_MOV_BX
+SaveUMBLink	db ?,0
 		DOSSetUMBlink			; set UMB link state
 		ret
 RestoreStrategy	endp
@@ -4447,7 +4960,8 @@
 ;
 AllocUMB	proc
 		push	bx
-		testflag [options],OPT_noUMB
+;		testflag [options],OPT_noUMB
+		test byte ptr [options], OPT_noUMB	; 80h, TASM optimizes
 		jnz	@@allocasis		; jump if UMB prohibited
 		mov	ax,ds
 		cmp	ah,0A0h
@@ -4461,10 +4975,12 @@
 		mov	bl,HI_BESTFIT		; OPTIMIZE: BL instead BX
 		DOSSetAlloc			; try best strategy to
 						;  allocate DOS UMBs
-	if_ carry
+;	if_ carry
+	jnc @@nhilo
 		mov	bl,HILOW_BESTFIT	; OPTIMIZE: BL instead BX
 		DOSSetAlloc			; try a worse one then
-	end_
+;	end_
+@@nhilo:
 
 		pop	bx
 		push	bx
@@ -4473,23 +4989,27 @@
 		xchg	dx,ax			; OPTIMIZE: instead MOV DX,AX
 		call	RestoreStrategy		; restore allocation strategy
 		popf
-	if_ nc
+;	if_ nc
+	jc @@allc
 		cmp	dh,0A0h			; exit if allocated mem is
 		jae	@@allocret		;  is above 640k (segment
 		DOSFreeMem dx			;  0A000h) else free it
-	end_
+;	end_
+@@allc:
 
 if 0
 ;----- try a XMS manager to allocate UMB
 
 		call	getXMSaddr
-	if_ nc
+;	if_ nc
+	jc @@xmsc
 		pop	dx
 		push	dx
 		mov	ah,10h			; XMS: Request UMB (size=DX)
 		call	[XMSentry]		; ...AX=1 -> BX=seg, DX=size
 		dec	ax
-	andif_ zero
+;	andif_ zero
+	jnz @@xmsc
 		pop	ax
 		push	ax
 		cmp	bx,ax
@@ -4497,7 +5017,8 @@
 		jae	@@allocret
 		mov	ah,11h			; XMS: Release UMB (seg=DX)
 		call	[XMSentry]
-	end_
+;	end_
+@@xmsc:
 endif
 
 ;----- use current memory segment
@@ -4519,11 +5040,13 @@
 		assume	es:nothing
 if 0
 		call	getXMSaddr
-	if_ nc
+;	if_ nc
+	jc @@fmc
 		mov	dx,es
 		mov	ah,11h			; XMS: Release UMB
 		call_far XMSentry
-	end_
+;	end_
+@@fmc:
 endif
 		DOSFreeMem			; free allocated memory
 		ret
Nur in 21b4tasm/source/ctmouse: ctmouse.ex-.
Bin√§rdateien 21b4tasm/source/ctmouse/ctmouse.exe and 21b4jwasm/source/ctmouse/ctmouse.exe sind verschieden.
Nur in 21b4jwasm/source/ctmouse: ctmouse.map.
diff -ru 21b4tasm/source/ctmouse/ctmouse.msg 21b4jwasm/source/ctmouse/ctmouse.msg
--- 21b4tasm/source/ctmouse/ctmouse.msg	2008-01-09 01:29:42.000000000 +0100
+++ 21b4jwasm/source/ctmouse/ctmouse.msg	2008-06-01 16:24:04.000000000 +0200
@@ -30,7 +30,7 @@
 S_CRLF		db nl,eos
 
 Copyright	db nl,'CuteMouse v',CTMRELEASE,' [FreeDOS]',nl,eos
-Syntax		label
+Syntax		label byte
     db 0,nl,'Options:',nl
     db '  /V	   - reverse search: find PS/2 after serial mouse',nl
     db '  /P	   - force PS/2 mouse mode, do not probe serial ports',nl
Nur in 21b4tasm/source/ctmouse: ctmouse.obj.
Nur in 21b4jwasm/source/ctmouse: jw-tasm.txt.
diff -ru 21b4tasm/source/ctmouse/makefile 21b4jwasm/source/ctmouse/makefile
--- 21b4tasm/source/ctmouse/makefile	2007-04-28 02:59:00.000000000 +0200
+++ 21b4jwasm/source/ctmouse/makefile	2008-06-01 21:51:29.000000000 +0200
@@ -1,8 +1,13 @@
 # Macros for building, deleting ########################################
 
-AS=tasm -m @asmlib.cfg
+# AS=tasm -m @asmlib.cfg
+# the following requires that you run jasmlib.bat first:
+# AS=jwasmd -mt @asmlib ... so we just hardcode the asmlib/ for includes
+AS=jwasmd -mt 
 LINKEXE=tlink /x
-LINKCOM=tlink /x /t
+# using tlink /x /t would create COM but fails on jwasm made OBJ:
+# it says that there would be data defined below initial CS:IP...
+# *** LINKCOM=tlink /x /t
 
 RM=del
 
@@ -11,8 +16,6 @@
 
 .asm.obj:
 	$(AS) $*
-.obj.com:
-	$(LINKCOM) $*
 .obj.exe:
 	$(LINKEXE) $*
 
@@ -22,8 +25,9 @@
 all: ctmouse.exe
 
 ctmouse.exe: ctmouse.obj com2exe.exe
-	$(LINKCOM) $*,$*.exe
-	com2exe -s512 $*.exe $*.exe
+	$(LINKEXE) $*,$*.exe
+	exe2bin $*.exe $*.bin
+	com2exe -s512 $*.bin $*.exe
 
 ctmouse.obj: ctmouse.asm ctmouse.msg asmlib\*.* asmlib\bios\*.* \
 		asmlib\convert\*.* asmlib\dos\*.* asmlib\hard\*.*
@@ -37,3 +41,6 @@
 clean:
 	-$(RM) ctmouse.msg
 	-$(RM) *.obj
+	-$(RM) ctmouse.bin
+# -$(RM) ctmouse.com
+
Nur in 21b4jwasm/source/ctmouse: tasm-bin.
diff -ru 21b4tasm/source/ctmouse/utility/comtest.asm 21b4jwasm/source/ctmouse/utility/comtest.asm
--- 21b4tasm/source/ctmouse/utility/comtest.asm	2003-03-01 02:06:00.000000000 +0100
+++ 21b4jwasm/source/ctmouse/utility/comtest.asm	2008-06-01 21:52:52.000000000 +0200
@@ -28,31 +28,31 @@
 ; 1.0 - First public release
 ;
 
-%pagesize 255
-%noincl
+; %pagesize 255
+; %noincl
 ;%macs
-%nosyms
+; %nosyms
 ;%depth 0
-%linum 0
-%pcnt 0
+; %linum 0
+; %pcnt 0
 ;%bin 0
-warn
-locals
+; warn
+; locals
 
-.model use16 tiny
+; .model use16 tiny --- use jwasm option -mt instead
 
 dataref equ <offset @data>	; offset relative data group
 
-include asm.mac
-include hll.mac
-include macro.mac
-include BIOS/area0.def
-include convert/digit.mac
-include convert/count2x.mac
-include DOS/io.mac
-include DOS/mem.mac
-include hard/PIC8259A.def
-include hard/UART.def
+include ../asmlib/asm.mac
+; include ../asmlib/hll.mac
+include ../asmlib/macro.mac
+include ../asmlib/BIOS/area0.def
+include ../asmlib/convert/digit.mac
+include ../asmlib/convert/count2x.mac
+include ../asmlib/DOS/io.mac
+include ../asmlib/DOS/mem.mac
+include ../asmlib/hard/PIC8259A.def
+include ../asmlib/hard/UART.def
 
 nl		equ <13,10>
 eos		equ <'$'>
@@ -108,14 +108,18 @@
 ;€€€€€€€€€€€€€€€€€€€€€€€€€€€€€ CODE SEGMENT €€€€€€€€€€€€€€€€€€€€€€€€€€€€€
 
 .code
-.startup
+; .startup      -- in jwasm this does "ds=dx=cs+0" (cs+0 is a reloc)
+        org 100h
+		assume ds:DGROUP
+start::
 		cld
 		mov	ax,1Fh			; disable mouse
 		call	mousedrv
 
 		DOSWriteS ,,@data:S_header
 		mov	bx,'1'
-	loop_
+;	loop_
+@@portloop:
 		push	bx
 
 ;----- get IO address for COM port
@@ -129,7 +133,8 @@
 		pop	bx
 		inc	bx
 		cmp	bx,'4'
-	until_ above
+;	until_ above
+	jna @@portloop
 
 		DOSWriteS ,,@data:S_note	; final note
 
@@ -141,14 +146,20 @@
 ;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
 
 mousedrv	proc
-		push	ax bx es
+		push	ax
+		push	bx
+		push	es
 		DOSGetIntr 33h
 		mov	ax,es
 		test	ax,ax
-		pop	es bx ax
-	if_ nz
+		pop	es
+		pop	bx
+		pop	ax
+;	if_ nz
+	jz @@i33z
 		int	33h
-	end_
+;	end_
+@@i33z:
 		ret
 mousedrv	endp
 
@@ -171,29 +182,38 @@
 		mov	di,dataref:S_noUART
 		mov	ax,'  '
 		mov	byte ptr S_IRQno[2],al
-	if_ nc
+;	if_ nc
+	jc @@skipuartcfg
 		shl	bx,1
 		mov	di,UARTtype[bx]
 		call	detectIRQ
 		mov	ax,' '+('?' shl 8)
 		mov	cx,bx
-	andif_ ncxz				; if IRQ detected
+;	andif_ ncxz				; if IRQ detected
+	jcxz @@skipuartcfg
 		dec	cx
 		and	cx,bx
-	 if_ nz					; if more than one IRQ
+;	 if_ nz					; if more than one IRQ
+	jz @@fixedirqno
 		mov	byte ptr S_IRQno[2],'*'
 		mov	byte ptr [S_note],13	; turn on final note
-	 end_
+;	 end_
+@@fixedirqno:
 		mov	ah,'0'+16
-	 loop_					; count lowest nonzero bit pos
+;	 loop_					; count lowest nonzero bit pos
+@@bitcnt:
 		dec	ah
 		shl	bx,1
-	 until_ zero
+;	 until_ zero
+	jnz @@bitcnt
 		cmp	ah,'9'
-	 if_ above
+;	 if_ above
+	jna @@na9
 		add	ax,('1'-' ')+(-10 shl 8)
-	 end_
-	end_ if
+;	 end_
+@@na9:
+;	end_ if
+@@skipuartcfg:
 
 ;----- print UART info
 
@@ -206,19 +226,24 @@
 ;----- check attached devices
 
 		cmp	di,dataref:S_noUART
-	if_ ne
+;	if_ ne
+	jz @@noshowdev
 		call	detectmouse
-	 if_ nc
+;	 if_ nc
+	jc @@nomousehere
 		shl	bx,1
 		mov	dx,micetype[bx]
 		jmp	@@showdevice
-	 end_
+;	 end_
+@@nomousehere:
 		call	checkmodem
-	 if_ nc
+;	 if_ nc
+	jc @@noshowdev
 		mov	dx,dataref:S_modem
 @@showdevice:	DOSWriteS
-	 end_
-	end_ if
+;	 end_
+;	end_ if
+@@noshowdev:
 		DOSWriteS ,,@data:CRLF
 		ret
 processbase	endp
@@ -245,7 +270,8 @@
 
 		movidx	dx,MCR_index,si		; {3FCh} MCR (modem ctrl reg)
 		 in	ax,dx			; {3FDh} LSR (line status reg)
-		testflag al,mask MCR_reserved+mask MCR_AFE
+;		testflag al,mask MCR_reserved+mask MCR_AFE
+	test al, mask MCR_reserved+mask MCR_AFE
 		 jnz	@@noUART
 		movidx	dx,LSR_index,si,MCR_index
 		 in	al,dx			; {3FDh} LSR (line status reg)
@@ -257,13 +283,19 @@
 		movidx	dx,LCR_index,si,LSR_index ; {3FBh} LCR (line ctrl reg)
 		 in	ax,dx			; {3FCh} MCR (modem ctrl reg)
 		 xchg	bx,ax			; OPTIMIZE: instead MOV BX,AX
-		out_	dx,%LCR<1,0,-1,-1,3>	; {3FBh} LCR: DLAB on, 8S2
+;		out_	dx,%LCR<1,0,-1,-1,3>	; {3FBh} LCR: DLAB on, 8S2
+	mov	al,10111111b
+	out	dx,al
 		 inb	ah,dx
-		out_	dx,%LCR<0,0,0,0,2>	; {3FBh} LCR: DLAB off, 7N1
+;		out_	dx,%LCR<0,0,0,0,2>	; {3FBh} LCR: DLAB off, 7N1
+	mov	al,00000010b
+	out	dx,al
 		 in	al,dx
-		cmp	ax,(LCR<1,0,-1,-1,3> shl 8)+LCR<0,0,0,0,2>
+;		cmp	ax,(LCR<1,0,-1,-1,3> shl 8)+LCR<0,0,0,0,2>
+	cmp	ax,(10111111b shl 8)+00000010b
 
-	if_ eq					; equal if LCR conforms
+;	if_ eq					; equal if LCR conforms
+	jnz @@nonconflcr
 
 ;----- check IER for reserved bits and clear UART interrupts
 
@@ -273,7 +305,8 @@
 		 jz	@@loopback
 
 		movidx	dx,LCR_index,si,IER_index
-	end_ if
+;	end_ if
+@@nonconflcr:
 
 		xchg	ax,bx			; OPTIMIZE: instead MOV AL,BL
 		 out	dx,al			; {3FBh} LCR: restore contents
@@ -285,17 +318,23 @@
 
 @@loopback:	;mov	al,%IER<>
 		 out	dx,al			; {3F9h} IER: interrupts off
-		movidx	dx,MCR_index,si,IER_index
-		 out_	dx,%MCR<,,1>		; {3FCh} MCR: enable loopback
+		movidx	dx,MCR_index,si,IER_index	; MCR: nnabcdef
+;		 out_	dx,%MCR<,,1>		; {3FCh} MCR: enable loopback
+	mov	al,00010000b
+	out	dx,al
 		movidx	dx,MSR_index,si,MCR_index
 		 inb	ah,dx			; {3FEh} MSR (modem stat reg)
 		movidx	dx,MCR_index,si,MSR_index ; MSR.4-7=MCR.1,0,2,3
-		 out_ 	dx,%MCR<,,1,1,1,1,1>	; {3FCh} MCR: enable loopback
+;		 out_ 	dx,%MCR<,,1,1,1,1,1>	; {3FCh} MCR: enable loopback
+	mov	al,00011111b
+	out	dx,al
 		movidx	dx,MSR_index,si,MCR_index
 		 in	al,dx			; {3FEh} MSR (modem stat reg)
 		movidx	dx,LCR_index,si,MSR_index
 		not	al
-		testflag ax,(MSR<1,1,1,1> shl 8)+MSR<1,1,1,1>
+;		testflag ax,(MSR<1,1,1,1> shl 8)+MSR<1,1,1,1>
+;		test ax,(MSR<1,1,1,1> shl 8)+MSR<1,1,1,1>
+		test ax,(11110000b shl 8) + 11110000b	; high part: loopback
 		xchg	ax,bx			; OPTIMIZE: instead MOV AX,BX
 		 out	dx,ax			; {3FBh} LCR: restore contents
 		jnz	@@noUART		; {3FCh} MCR: restore contents
@@ -305,13 +344,19 @@
 		movidx	dx,SCR_index,si,LCR_index
 		 in	al,dx			; {3FFh} SCR (scratch reg)
 		 xchg	bx,ax			; OPTIMIZE: instead MOV BL,AL
-		out_	dx,055h			; {3FFh} SCR (scratch reg)
+;		out_	dx,055h			; {3FFh} SCR (scratch reg)
+	mov	al,55h
+	out	dx,al
 		 inb	ah,dx			; 1: check if present
-		out_	dx,0AAh			; {3FFh} SCR (scratch reg)
+;		out_	dx,0AAh			; {3FFh} SCR (scratch reg)
+	mov	al,0aah
+	out	dx,al
 		 in	al,dx			; 2: check if present
 		sub	ax,055AAh
 		 neg	ax			; nonzero makes carry flag
-		 sbb	ax,ax			; UART=8250 (no SCR)
+;		 sbb	ax,ax			; UART=8250 (no SCR)
+	; JWASM and TASM use opposite encodings here
+	db 1bh, 0c0h	; sbb ax,ax
 		 inc	ax			;  or 16450 (with SCR)
 		xchg	ax,bx			; OPTIMIZE: instead MOV AL,BL
 		 out	dx,al			; {3FFh} SCR: restore contents
@@ -319,18 +364,29 @@
 ;----- check FIFO
 
 		movidx	dx,FCR_index,si,SCR_index
-		 out_	dx,%FCR<-1,,,1,1,1>	; {3FAh} FCR: enable FIFO
+;		 out_	dx,%FCR<-1,,,1,1,1>	; {3FAh} FCR: enable FIFO
+	mov	al,11000111b	; aabbcdef
+	out	dx,al
 		movidx	dx,IIR_index,si,FCR_index
 		 in	al,dx			; {3FAh} IIR (intr id reg)
-		testflag al,IIR{IIR_FIFO=10b}
-	if_ nz
+;		testflag al,IIR{IIR_FIFO=10b}
+;	test al,IIR{IIR_FIFO=10b}	; aabbcccd
+	test al,10000000b
+;	if_ nz
+	jz @@noiir
 		movadd	bx,,2			; UART=16550
-		testflag al,IIR{IIR_FIFO=01b}
-	andif_ nz
+;		testflag al,IIR{IIR_FIFO=01b}
+;	test al,IIR{IIR_FIFO=01b}	; aabbcccd
+	test al,01000000b
+;	andif_ nz
+	jz @@noiir
 		movadd	bx,,2			; UART=16550A
-	end_
+;	end_
+@@noiir:
 		movidx	dx,FCR_index,si,IIR_index
-		out_	dx,%FCR{FCR_enable=0}	; {3FAh} FCR: disable FIFO
+;		out_	dx,%FCR{FCR_enable=0}	; {3FAh} FCR: disable FIFO
+	mov	al,0
+	out	dx,al
 		sti
 		;clc
 		ret
@@ -348,7 +404,8 @@
 ;
 detectIRQ	proc
 		cli
-		mov	al,OCW3<,,,OCW3_IRR>
+;		mov	al,OCW3<,,,OCW3_IRR>
+	mov al,00001010b	; aabbcdd, bb should be 01
 		 out	PIC2_OCW3,al		; {0A0h} select IRR read mode
 		 out	PIC1_OCW3,al		; {20h} select IRR read mode
 
@@ -357,33 +414,43 @@
 		movidx	dx,LCR_index,si		; {3FBh} LCR (line ctrl reg)
 		 in	ax,dx			; {3FCh} MCR (modem ctrl reg)
 		 push	ax			; keep old LCR and MCR values
-		 out_	dx,%LCR<0,,,,3>,%MCR<,,0,1,1,0,0>
+;		 out_	dx,%LCR<0,,,,3>,%MCR<,,0,1,1,0,0>
+	mov	ax,(00001100b shl 8) + 00000011b ; lcr: abcccdee mcr: aabcdefg
+	out	dx,ax
 						; {3FBh} LCR: DLAB off
 						; {3FCh} MCR: DTR/RTS/loop off, OUTx on
 		movidx	dx,FCR_index,si,LCR_index
-		 out_	dx,%FCR<>		; {3FAh} FCR: disable FIFO
+;		 out_	dx,%FCR<>		; {3FAh} FCR: disable FIFO
+	mov	al,0
+	out	dx,al
 
 ;----- test THRE interrupt generation
 
 		movidx	dx,IER_index,si,FCR_index
 		mov	cx,3
 @@detIRQloop:	push	cx
-		out_	dx,%IER{IER_THRE=1}	; {3F9h} IER: enable THRE intr
+;		out_	dx,%IER{IER_THRE=1}	; {3F9h} IER: enable THRE intr
+	mov	al,00000010b
+	out	dx,al
 		mov	bx,1			; mask of detected IRQ
 						;  (except timer IRQ0)
 		mov	ch,1			; OPTIMIZE: instead MOV CX,1xxh
-@@waitIRQon:	inb	ah,PIC2_IRR		; {0A0h} get IRR
+@@waitIRQon:
+		inb	ah,PIC2_IRR		; {0A0h} get IRR
 		in	al,PIC1_IRR		; {20h} get IRR
 		or	ax,bx
 		xor	ax,bx			; detect raised IRQ
 		loopz	@@waitIRQon
 		xchg	bx,ax			; OPTIMIZE: instead MOV BX,AX
 
-		out_	dx,%IER<>		; {3F9h} IER: interrupts off
+;		out_	dx,%IER<>		; {3F9h} IER: interrupts off
+	mov	al,0
+	out	dx,al
 						;!!! under W4WG first THRE
 						;  sometime ignored (and CX=0)
 		inc	cx			; loop remained iterations
-@@waitIRQoff:	inb	ah,PIC2_IRR		; {0A0h} get IRR
+@@waitIRQoff:
+		inb	ah,PIC2_IRR		; {0A0h} get IRR
 		in	al,PIC1_IRR		; {20h} get IRR
 		xor	ax,bx
 		and	ax,bx			; detect dropped IRQ
@@ -395,9 +462,13 @@
 ;----- exclude IRQ2 if IRQs from slave PIC present
 
 		test	ah,ah
-	if_ nz					; if IRQ8-15 detected then
-		 maskflag ax,not (1 shl 2)	; exclude IRQ2 (PIC2 attach point)
-	end_
+;	if_ nz					; if IRQ8-15 detected then
+	jz @@nohiirq
+;		 maskflag ax,not (1 shl 2)	; exclude IRQ2 (PIC2 attach point)
+;	and	ax, not (1 shl 2)
+	and	al, not (1 shl 2)	; maskflag also does optimization!
+;	end_
+@@nohiirq:
 		xchg	bx,ax			; OPTIMIZE: instead MOV BX,AX
 
 ;----- restore LCR and MCR state
@@ -431,7 +502,9 @@
 ;----- reset UART: drop RTS line, interrupts and disable FIFO
 
 		;movidx	dx,LCR_index,si		; {3FBh} LCR: DLAB off
-		 out_	dx,%LCR<>,%MCR<>	; {3FCh} MCR: DTR/RTS/OUT2 off
+;		 out_	dx,%LCR<>,%MCR<>	; {3FCh} MCR: DTR/RTS/OUT2 off
+	xor ax,ax
+	out dx,ax
 		movidx	dx,IER_index,si,LCR_index
 		 ;mov	ax,(FCR<> shl 8)+IER<>	; {3F9h} IER: interrupts off
 		 out	dx,ax			; {3FAh} FCR: disable FIFO
@@ -439,12 +512,16 @@
 ;----- set communication parameters and flush receive buffer
 
 		movidx	dx,LCR_index,si,IER_index
-		 out_	dx,%LCR{LCR_DLAB=1}	; {3FBh} LCR: DLAB on
-		xchg	dx,si
+;		 out_	dx,%LCR{LCR_DLAB=1}	; {3FBh} LCR: DLAB on
+	mov	al,80h
+	out	dx,al
+		xchg	si,dx	; JWASM and TASM use opposite styles
 		 ;mov	ah,0			; 1200 baud rate
 		 out_	dx,96,ah		; {3F8h},{3F9h} divisor latch
-		xchg	dx,si
-		 out_	dx,%LCR<0,,0,0,2>	; {3FBh} LCR: DLAB off, 7N1
+		xchg	si,dx	; JWASM and TASM use opposite styles
+;		 out_	dx,%LCR<0,,0,0,2>	; {3FBh} LCR: DLAB off, 7N1
+	mov	al,00000010b	;	abcccdee
+	out	dx,al
 		movidx	dx,RBR_index,si,LCR_index
 		 in	al,dx			; {3F8h} flush receive buffer
 
@@ -453,42 +530,64 @@
 		call	delaytick
 		assume	es:BIOS
 		movidx	dx,MCR_index,si,RBR_index
-		 out_	dx,%MCR<,,,0,,1,1>	; {3FCh} MCR: DTR/RTS on, OUT2 off
+;		 out_	dx,%MCR<,,,0,,1,1>	; {3FCh} MCR: DTR/RTS on, OUT2 off
+	mov	al,00000011b	; aabcdefg
+	out	dx,al
 
 ;----- detect if Microsoft or Logitech mouse present
 
 		mov	bx,0100h		; bl=mouse type, bh=no `M'
-	countloop_ 4,cl				; scan 4 first bytes
-	 countloop_ 2+1,ch			; length of silence in ticks
+;	countloop_ 4,cl				; scan 4 first bytes
+	mov cl,4
+@@myclloop:
+;	 countloop_ 2+1,ch			; length of silence in ticks
+	mov ch,2+1
+@@mychloop:
 						; (include rest of curr tick)
 		mov	ah,byte ptr [BIOS_timer]
-	  loop_
+;	  loop_
+@@myzloop:
 		movidx	dx,LSR_index,si
 		 in	al,dx			; {3FDh} LSR (line status reg)
-		testflag al,mask LSR_RBF
+;		testflag al,mask LSR_RBF
+	test al,mask LSR_RBF
 		 jnz	@@parse			; jump if data ready
 		cmp	ah,byte ptr [BIOS_timer]
-	  until_ ne				; loop until next timer tick
-	 end_ countloop				; loop until end of 2nd tick
-	 break_					; break if no more data
+;	  until_ ne				; loop until next timer tick
+	jz @@myzloop
+;	 end_ countloop				; loop until end of 2nd tick
+	dec ch
+	jnz @@mychloop
+;	 break_					; break if no more data
+	j @@myclend
 
 @@parse:	movidx	dx,RBR_index,si
 		 in	al,dx			; {3F8h} receive byte
 		cmp	al,'('-20h
-	 breakif_ eq				; break if PnP data starts
+;	 breakif_ eq				; break if PnP data starts
+	jz @@myclend
 		cmp	al,'M'
-	 if_ eq
+;	 if_ eq
+	jnz @@mynotm
 		mov	bh,0			; MS compatible mouse found...
-	 end_
+;	 end_
+@@mynotm:
 		cmp	al,'Z'
-	 if_ eq
+;	 if_ eq
+	jnz @@mynotz
 		mov	bl,1			; ...MS mouse+wheel found
-	 end_
+;	 end_
+@@mynotz:
 		cmp	al,'3'
-	 if_ eq
+;	 if_ eq
+	jnz @@mynot3
 		mov	bl,2			; ...Logitech mouse found
-	 end_
-	end_ countloop
+;	 end_
+@@mynot3:
+;	end_ countloop
+	dec cl
+	jnz @@myclloop
+@@myclend:
 
 		movidx	dx,LCR_index,si
 		 pop	ax			; {3FBh} LCR: restore contents
@@ -519,7 +618,9 @@
 ;----- raise DTR/RTS lines and then wait current+next timer tick
 
 		;movidx	dx,LCR_index,si		; {3FBh} LCR: BREAK off
-		 out_	dx,%LCR<>,%MCR<,,,,,1,1> ; {3FCh} MCR: DTR/RTS on
+;		 out_	dx,%LCR<>,%MCR<,,,,,1,1> ; {3FCh} MCR: DTR/RTS on
+	mov	ax,(00000011b shl 8) + 00000000b
+	out	dx,ax
 		call	delaytick
 
 ;----- check CTS line
@@ -549,16 +650,20 @@
 ;
 delaytick	proc
 		MOVSEG	es,0,ax,BIOS
-	loop_
+;	loop_
+@@delaynz:
 		mov	ah,byte ptr [BIOS_timer]
-	 loop_
+;	 loop_
+@@delayz:
 		cmp	ah,byte ptr [BIOS_timer]
-	 until_ ne				; loop until next timer tick
+;	 until_ ne				; loop until next timer tick
+	jz @@delayz
 		xor	al,1
-	until_ zero				; loop until end of 2nd tick
+;	until_ zero				; loop until end of 2nd tick
+	jnz @@delaynz
 		ret
 delaytick	endp
 
 ;€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€
 
-end
+end	start
diff -ru 21b4tasm/source/ctmouse/utility/makefile 21b4jwasm/source/ctmouse/utility/makefile
--- 21b4tasm/source/ctmouse/utility/makefile	2007-06-06 22:40:49.000000000 +0200
+++ 21b4jwasm/source/ctmouse/utility/makefile	2008-06-01 21:51:51.000000000 +0200
@@ -1,6 +1,8 @@
 # Macros for building, deleting ########################################
 
-AS=tasm -m @..\asmlib.cfg
+# AS=tasm -m @..\asmlib.cfg
+# AS=jwasmd -mt @asmlib ... so we just hardcode the asmlib/ for includes  
+AS=jwasmd -mt 
 # CC=tcc
 # CFLAGS        = -IC:\TC\INCLUDE -LC:\TC\LIB -f -c -w -ms -a- -k- -N- -d -O -O2
 # CFLAGS=-IC:\TC\INCLUDE -LC:\TC\LIB -N -w -a- -f- -f87- -ms -r-
@@ -18,16 +20,18 @@
 	$(AS) $*
 .obj.com:
 	$(LINKCOM) $*
-# .obj.exe:
-# 	$(LINKEXE) $*
+.obj.exe:
+	$(LINKEXE) $*
 
 
 # Targets ##############################################################
 
-all: comtest.com protocol.com mousetst.exe
+all: comtest.com protocol.com mousetst.com
 
+# com does not link...
 comtest.com: comtest.obj
 
+# com does not link...
 protocol.com: protocol.obj
 
 # mousetst.exe: mousetst.obj prf.obj
@@ -35,17 +39,21 @@
 # mousetst.exe:	mousetst.c prf.c
 #		tcc -N -w -a- -f- -f87- -ms -r- \
 #		-IC:\TC\INCLUDE -LC:\TC\LIB mousetst prf
-mousetst.exe:	mousetst.c
-		tcc -N -w -a- -f- -f87- -ms -r- \
-		-IC:\TC\INCLUDE -LC:\TC\LIB mousetst
+# *** mousetst.exe:	mousetst.c
+# *** 		tcc -N -w -a- -f- -f87- -ms -r- \
+# *** 		-IC:\TC\INCLUDE -LC:\TC\LIB mousetst
 
+mousetst.com: mousetst.asm display.asm
+	nasm -o mousetst.com mousetst.asm
 
-comtest.obj: comtest.asm ..\asmlib\*.* ..\asmlib\bios\area0.def \
+comtest.obj: comtest.asm ..\asmlib\asm.mac ..\asmlib\bios\area0.def \
+		..\asmlib\macro.mac \
 		..\asmlib\convert\digit.mac ..\asmlib\convert\count2x.mac \
 		..\asmlib\dos\io.mac ..\asmlib\dos\mem.mac \
 		..\asmlib\hard\pic8259a.def ..\asmlib\hard\uart.def
 
-protocol.obj: protocol.asm ..\asmlib\*.* ..\asmlib\bios\area0.def \
+protocol.obj: protocol.asm ..\asmlib\asm.mac ..\asmlib\bios\area0.def \
+		..\asmlib\macro.mac ..\asmlib\code.def ..\asmlib\code.mac \
 		..\asmlib\convert\digit.mac ..\asmlib\convert\count2x.mac \
 		..\asmlib\dos\io.mac ..\asmlib\dos\mem.mac \
 		..\asmlib\hard\pic8259a.def ..\asmlib\hard\uart.def
@@ -58,3 +66,5 @@
 
 clean:
 	-$(RM) *.obj
+
+
diff -ru 21b4tasm/source/ctmouse/utility/protocol.asm 21b4jwasm/source/ctmouse/utility/protocol.asm
--- 21b4tasm/source/ctmouse/utility/protocol.asm	2003-03-01 01:06:00.000000000 +0100
+++ 21b4jwasm/source/ctmouse/utility/protocol.asm	2008-06-01 21:53:27.000000000 +0200
@@ -44,33 +44,33 @@
 ; 1.0 - First public release
 ;
 
-%pagesize 255
-%noincl
+; %pagesize 255
+; %noincl
 ;%macs
-%nosyms
+; %nosyms
 ;%depth 0
-%linum 0
-%pcnt 0
+; %linum 0
+; %pcnt 0
 ;%bin 0
-warn
-locals
+; warn
+; locals
 
-.model use16 tiny
+; .model use16 tiny --- use jwasm -mt option instead
 
 dataref equ <offset @data>	; offset relative data group
 
-include asm.mac
-include hll.mac
-include code.def
-include code.mac
-include macro.mac
-include BIOS/area0.def
-include convert/digit.mac
-include convert/count2x.mac
-include DOS/io.mac
-include DOS/mem.mac
-include hard/PIC8259A.def
-include hard/UART.def
+include ../asmlib/asm.mac
+; *** include ../asmlib/hll.mac
+include ../asmlib/code.def
+include ../asmlib/code.mac
+include ../asmlib/macro.mac
+include ../asmlib/BIOS/area0.def
+include ../asmlib/convert/digit.mac
+include ../asmlib/convert/count2x.mac
+include ../asmlib/DOS/io.mac
+include ../asmlib/DOS/mem.mac
+include ../asmlib/hard/PIC8259A.def
+include ../asmlib/hard/UART.def
 
 nl		equ <13,10>
 eos		equ <'$'>
@@ -105,34 +105,38 @@
 		db '       Class: ',eos
 		db '   Driver ID: ',eos
 		db '   User name: ',eos
-PnP_hdend	label
+PnP_hdend	label byte
 
 S_notCOM	db 'COM port not found!',nl,eos
 Syntax		db 'Syntax: protocol <COM (1-4)> [<bytes in event (3-5)>'
 		db			' [<COM LCR value (2-3)>]]',nl,eos
 
-.data?
+; .data?	; BSS
 
 oldIRQaddr	dd ?		; old IRQ handler address
 
-programend segment virtual	; place at the end of current segment
-
+; programend segment virtual	; place at the end of current segment
+; *** actually this was wrong in 2.0 - even TASM put queue at offset 0 :-p
+	even
 ;!!! this segment placed at the end of .data? segment, which placed after
 ;!!! other segments, thus in .COM program PnPdata points after program
 ;!!! end and before stack top
 
-PNPdata		label		; buffer for PnP data
+PNPdata		label byte	; buffer for PnP data
 
 queue		db 32 dup(?)	; queue for incoming serial data
-queue_end	label
+queue_end	label byte
 
-programend ends
+; programend ends
 
 
 ;€€€€€€€€€€€€€€€€€€€€€€€€€€€€€ CODE SEGMENT €€€€€€€€€€€€€€€€€€€€€€€€€€€€€
 
 .code
-.startup
+; .startup	-- in jwasm this does "ds=dx=cs+0" (cs+0 is a reloc)
+	org 100h
+                assume ds:DGROUP
+start::
 		cld
 		mov	si,80h			; offset PSP:cmdline_len
 		lodsb
@@ -168,14 +172,16 @@
 
 skipwhite	proc
 		cmp	di,si
-	if_ ae					; JB mean CF=1
+;	if_ ae					; JB mean CF=1
+	jb @@skipb
 		lodsb
 		cmp	al,' '
 		jbe	skipwhite
 		sub	al,'0'
 		jb	HELP
 		;clc
-	end_
+;	end_
+@@skipb:
 		ret
 skipwhite	endp
 
@@ -194,10 +200,15 @@
 ;----- install IRQ handler and enable interrupt
 
 		mov	al,[IRQintnum]
-		DOSGetIntr
+;		DOSGetIntr
+	mov ah,35h
+	int 21h
 		saveFAR [oldIRQaddr],es,bx	; save old IRQ handler
 		;mov	al,[IRQintnum]
-		DOSSetIntr ,,,@code:IRQhandler
+;		DOSSetIntr ,,,@code:IRQhandler
+	mov dx,offset @code:IRQhandler
+	mov ah,25h
+	int 21h
 		call	enableUART
 
 ;===== process mouse data until keystroke
@@ -205,46 +216,62 @@
 		MOVSEG	es,ds,,@data
 		mov	bx,dataref:queue
 
-	loop_
+;	loop_
 @@mainloop:	hlt
 		mov	ah,1
 		int	16h			; check for keystroke
-	while_ zero
+;	while_ zero
+	jnz @@emainloop	; at least this is what the HLL/TASM version had!
 		cmp	bx,[queue@]
 		je	@@mainloop
 
 		cmp	bx,dataref:queue_end
-	 if_ ae
+;	 if_ ae
+	jb @@mainb
 		mov	bx,dataref:queue
-	 end_
+;	 end_
+@@mainb:
 		mov	ah,[bx]
 		inc	bx
 
 		mov	di,dataref:S_bitbyte+1
-	 countloop_ 8				; 8 bits
+;	 countloop_ 8				; 8 bits
+	mov cx,8
+@@cl8:
 		mov	al,'0' shr 1
 		rol	ax,1
 		stosb
-	 end_
+;	 end_
+	loop @@cl8
 		say	@data:S_bitbyte
 
-	CODE_	MOV_AL	IOdone,<db 0>		; processed bytes counter
+;	CODE_	MOV_AL	IOdone,<db 0>		; processed bytes counter
+	OPCODE_MOV_AL
+IOdone	db 0
 		inc	ax			; OPTIMIZE: AX instead AL
-	CODE_	CMP_AL	limit,<db 3>
-	 if_ ae
+;	CODE_	CMP_AL	limit,<db 3>
+	OPCODE_CMP_AL
+limit	db 3
+;	 if_ ae
+	jb @@limitb
 		say	@data:CRLF
 		mov	al,0			; restart counter of bytes
-	 end_
+;	 end_
+@@limitb:
 		mov	[IOdone],al
-	end_ loop
+;	end_ loop
+	j @@mainloop
 
 ;===== final: flush keystroke, deinstall handler and exit
 
+@@emainloop:
 		mov	ah,0
 		int	16h			; get keystroke
 
 		call	disableUART
-	CODE_	MOV_AX	IRQintnum,<db ?,25h>	; INT number of selected IRQ
+;	CODE_	MOV_AX	IRQintnum,<db ?,25h>	; INT number of selected IRQ
+	OPCODE_MOV_AX
+IRQintnum	db ?, 25h
 		lds	dx,[oldIRQaddr]
 		assume	ds:nothing
 		int	21h			; set INT in DS:DX
@@ -259,14 +286,20 @@
 ;ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
 
 mousedrv	proc
-		push	ax bx es
+		push	ax
+		push	bx
+		push	es
 		DOSGetIntr 33h
 		mov	ax,es
 		test	ax,ax
-		pop	es bx ax
-	if_ nz
+		pop	es
+		pop	bx
+		pop	ax
+;	if_ nz
+	jz @@drvnoi33
 		int	33h
-	end_
+;	end_
+@@drvnoi33:
 		ret
 mousedrv	endp
 
@@ -278,7 +311,8 @@
 		shl	bx,1
 		mov	cx,COM_base[bx]
 		stc
-	if_ ncxz
+;	if_ ncxz
+	jcxz @@setccxz
 		mov	[IO_address],cx
 
 		inc	ax			; OPTIMIZE: AX instead AL
@@ -293,7 +327,8 @@
 		not	al
 		mov	[notPIC1state],al	; PIC interrupt enabler
 		;clc
-	end_ if
+;	end_ if
+@@setccxz:
 		ret
 setCOMport	endp
 
@@ -302,11 +337,15 @@
 
 disableUART	proc
 		in	al,PIC1_IMR		; {21h} get IMR
-	CODE_	OR_AL	PIC1state,<db ?>		; set bit to disable interrupt
+;	CODE_	OR_AL	PIC1state,<db ?>		; set bit to disable interrupt
+	OPCODE_OR_AL
+PIC1state	db ?
 		out	PIC1_IMR,al		; {21h} disable serial interrupts
 ;-----
 		movidx	dx,LCR_index,si		; {3FBh} LCR: DLAB off
-		 out_	dx,%LCR<>,%MCR<>	; {3FCh} MCR: DTR/RTS/OUT2 off
+;		 out_	dx,%LCR<>,%MCR<>	; {3FCh} MCR: DTR/RTS/OUT2 off
+	xor ax,ax
+	out dx,ax
 		movidx	dx,IER_index,si,LCR_index
 		 ;mov	ax,(FCR<> shl 8)+IER<>	; {3F9h} IER: interrupts off
 		 out	dx,ax			; {3FAh} FCR: disable FIFO
@@ -317,12 +356,18 @@
 
 enableUART	proc
 		movidx	dx,MCR_index,si
-		 out_	dx,%MCR<,,,1,1,1,1>	; {3FCh} MCR: DTR/RTS/OUTx on
+;		 out_	dx,%MCR<,,,1,1,1,1>	; {3FCh} MCR: DTR/RTS/OUTx on
+	mov al,00001111b	; aabcdefg
+	out dx,al
 		movidx	dx,IER_index,si,MCR_index
-		 out_	dx,%IER{IER_DR=1}	; {3F9h} IER: enable DR intr
+;		 out_	dx,%IER{IER_DR=1}	; {3F9h} IER: enable DR intr
+	mov al,00000001b	; aaaabcde
+	out dx,al
 ;-----
 		in	al,PIC1_IMR		; {21h} get IMR
-	CODE_	AND_AL	notPIC1state,<db ?>	; clear bit to enable interrupt
+;	CODE_	AND_AL	notPIC1state,<db ?>	; clear bit to enable interrupt
+	OPCODE_AND_AL
+notPIC1state	db ?
 		out	PIC1_IMR,al		; {21h} enable serial interrupts
 		ret
 enableUART	endp
@@ -331,7 +376,8 @@
 
 resetmouse	proc
 		mov	al,[LCRset]
-		maskflag al,mask LCR_stop+mask LCR_wordlen
+;		maskflag al,mask LCR_stop+mask LCR_wordlen
+	and	al,mask LCR_stop+mask LCR_wordlen
 		mov	cl,8-LCR_stop
 		shl	ax,cl			; LCR_stop
 		shr	al,cl			;  > LCR_wordlen
@@ -342,69 +388,93 @@
 ;----- set communication parameters
 
 		movidx	dx,LCR_index,si
-		 out_	dx,%LCR{LCR_DLAB=1}	; {3FBh} LCR: DLAB on
-		xchg	dx,si			; 1200 baud rate
+;		 out_	dx,%LCR{LCR_DLAB=1}	; {3FBh} LCR: DLAB on
+	mov al,80h
+	out dx,al
+;		xchg	dx,si			; 1200 baud rate
+	xchg si,dx	; TASM and JWASM use opposite encodings
 		 outw	dx,96			; {3F8h},{3F9h} divisor latch
-		xchg	dx,si
-	CODE_	 MOV_AL	LCRset,<LCR <0,,LCR_noparity,0,2>>
+;		xchg	dx,si
+	xchg si,dx	; TASM and JWASM use opposite encodings
+;	CODE_	 MOV_AL	LCRset,<LCR <0,,LCR_noparity,0,2>>
+	OPCODE_MOV_AL
+LCRset	db 00000010b	; abcccdee
 		 out	dx,al			; {3FBh} LCR: DLAB off, 7/8N1
 
 ;----- wait current+next timer tick and then raise RTS line
 
 		MOVSEG	es,0,ax,BIOS
-	loop_
+;	loop_
+@@tmrnz:
 		mov	ah,byte ptr [BIOS_timer]
-	 loop_
+;	 loop_
+@@tmrz:
 		cmp	ah,byte ptr [BIOS_timer]
-	 until_ ne				; loop until next timer tick
+;	 until_ ne				; loop until next timer tick
+	jz @@tmrz
 		xor	al,1
-	until_ zero				; loop until end of 2nd tick
+;	until_ zero				; loop until end of 2nd tick
+	jnz @@tmrnz
 
 		movidx	dx,MCR_index,si,LCR_index
-		 out_	dx,%MCR<,,,0,,1,1>	; {3FCh} MCR: DTR/RTS on, OUT2 off
+;		 out_	dx,%MCR<,,,0,,1,1>	; {3FCh} MCR: DTR/RTS on, OUT2 off
+	mov al,00000011b	; aabcdefg
+	out dx,al
 
 ;----- read and show reset sequence, generated by mouse
 
 		mov	bx,20+1			; output counter
 		mov	di,dataref:PnPdata
-	loop_
-	 countloop_ 2+1				; length of silence in ticks
+;	loop_
+@@nokeyyet:
+;	 countloop_ 2+1				; length of silence in ticks
+	mov cx,2+1
+@@tmr3loop:
 						; (include rest of curr tick)
 		mov	ah,byte ptr [BIOS_timer]
-	  loop_
+;	  loop_
+@@tmrzloop:
 		movidx	dx,LSR_index,si
 		 in	al,dx			; {3FDh} LSR (line status reg)
-		testflag al,mask LSR_RBF
+;		testflag al,mask LSR_RBF
+	test al, mask LSR_RBF
 		 jnz	@@newbyte		; jump if data ready
 		cmp	ah,byte ptr [BIOS_timer]
-	  until_ ne				; loop until next timer tick
-	 end_ countloop				; loop until end of 2nd tick
+;	  until_ ne				; loop until next timer tick
+	jz @@tmrzloop
+;	 end_ countloop				; loop until end of 2nd tick
+	loop @@tmr3loop
 		j	@@parsePnP		; stream terminated by silence
 
 ;----- save and show next byte
 
 @@newbyte:	dec	bx
-	 if_ zero
+;	 if_ zero
+	jnz @@nbnz
 		say	@data:S_spaces		; out spaces after
 		mov	bl,20			;  right margin
-	 end_
+;	 end_
+@@nbnz:
 		movidx	dx,RBR_index,si
 		 in	al,dx			; {3F8h} receive byte
 
 		mov	cx,sp
 		sub	cx,di
 		test	ch,ch			; ZF=1 if CX<256
-	 if_ nz
+;	 if_ nz
+	jz @@nbz2
 		mov	[di],al			; store if space enough
 		inc	di
-	 end_
+;	 end_
+@@nbz2:
 		call	byte2hexa
 		mov	word ptr S_byte[1],ax
 		say	@data:S_byte
 
 		mov	ah,1
 		int	16h
-	until_ nz				; loop until keystroke
+;	until_ nz				; loop until keystroke
+	jz @@nokeyyet
 		j	@@resetdone		; then exit
 
 ;----- parse and show PnP data
@@ -412,12 +482,14 @@
 @@parsePnP:	mov	cx,di
 		mov	di,dataref:PnPdata
 
-	loop_					; find PnP data start '('
+;	loop_					; find PnP data start '('
+@@pnpnz:
 		cmp	di,cx
 		jae	@@resetdone
 		inc	di
 		cmp	byte ptr [di-1],'('-20h
-	until_ eq
+;	until_ eq
+	jnz @@pnpnz
 
 		say	@data:CRLF2
 		mov	dx,dataref:S_wrongPnP
@@ -426,7 +498,8 @@
 		mov	bx,di
 		inc	bx			; BX=start of PnP data
 		mov	al,')'-20h+3*20h	; count checksum in AL
-	loop_
+;	loop_
+@@pnpnz2:
 		inc	di
 		cmp	di,cx
 		jae	saystr
@@ -434,7 +507,8 @@
 		sub	al,20h
 		add	byte ptr [di],20h	; ...and decode PnP data
 		cmp	byte ptr [di],')'	; ...until PnP data end ')'
-	until_ eq
+;	until_ eq
+	jnz @@pnpnz2
 
 		movsub	di,,2			; verify checksum
 		call	byte2hexa		; convert checksum to ASCII
@@ -442,30 +516,46 @@
 		jne	saystr
 
 		say	@data:PnP_OEM		; show "Manufacturer" field
-	countloop_ 3
+;	countloop_ 3
+	mov cx,3
+@@write3:
 		mov	dl,[bx]
 		inc	bx
 		DosWriteC
-	end_
+;	end_
+	loop @@write3
 
 		mov	cx,dataref:PnP_header
-	loop_
+	; BEGIN TOTALLY CONFUSING SECTION
+;	loop_
+@@untilaeloop:
 		say	@data:CRLF		; show other PnP fields
-		say	cx
+;		say	cx
+	mov dx,cx
+	call saystr
 
-	 loop_
+;	 loop_
+@@someloop:
 		cmp	bx,di
-	 while_ below
+;	 while_ below
+	jnb @@nosomeloop
+@@whilebelowloop:
 		mov	dl,[bx]
 		inc	bx
 		cmp	dl,'\'
-	  breakif_ eq
+;	  breakif_ eq
+	jz @@nosomeloop
 		DosWriteC
-	 end_ loop
+;	 end_ loop
+	j @@someloop
+@@nosomeloop:
 
 		add	cx,PnP_hdnext-PnP_header
 		cmp	cx,dataref:PnP_hdend
-	until_ ae
+;	until_ ae
+	jb @@untilaeloop
+@@untilae:
+	; END TOTALLY CONFUSING SECTION
 
 @@resetdone:	mov	dx,dataref:CRLF2
 		;j	saystr
@@ -482,7 +572,7 @@
 
 byte2hexa	proc
 		mov	cl,4
-		_byte_hex_AX ,,cl
+		_byte_hex_AX al,0,cl
 		ret
 byte2hexa	endp
 
@@ -491,8 +581,12 @@
 
 IRQhandler	proc
 		assume	ds:nothing,es:nothing,ss:nothing
-		push	ax dx bx
-	CODE_	MOV_DX	IO_address,<dw ?>	; UART IO address
+		push	ax
+		push	dx
+		push	bx
+;	CODE_	MOV_DX	IO_address,<dw ?>	; UART IO address
+	OPCODE_MOV_DX
+IO_address	dw ?
 		push	dx
 		movidx	dx,LSR_index
 		 in	al,dx			; {3FDh} LSR: clear error bits
@@ -502,22 +596,32 @@
 		 in	al,dx			; {3F8h} flush receive buffer
 
 		shr	bl,LSR_RBF+1
-	if_ carry				; process data if data ready
-	CODE_	MOV_BX	queue@,<dw dataref:queue>
+;	if_ carry				; process data if data ready
+	jnc @@qnc
+;	CODE_	MOV_BX	queue@,<dw dataref:queue>
+	OPCODE_MOV_BX
+queue@	dw dataref:queue
 		cmp	bx,dataref:queue_end
-	 if_ ae
+;	 if_ ae
+	jb @@qb
 		mov	bx,dataref:queue
-	 end_
+;	 end_
+@@qb:
 		mov	cs:[bx],al
 		inc	bx
 		mov	[queue@],bx
-	end_
-		out_	PIC1_OCW2,%OCW2<OCW2_EOI> ; {20h} end of interrupt
-		pop	bx dx ax
+;	end_
+@@qnc:
+;		out_	PIC1_OCW2,%OCW2<OCW2_EOI> ; {20h} end of interrupt
+	mov al,00100000b	; aaabbccc - nonspecific EOF
+	out PIC1_OCW2,al
+		pop	bx
+		pop	dx
+		pop	ax
 		iret
 IRQhandler	endp
 		assume	ds:@data
 
 ;€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€
 
-end
+end start
Bin√§rdateien 21b4tasm/source/ctmouse/utility/protocol.com and 21b4jwasm/source/ctmouse/utility/protocol.com sind verschieden.
